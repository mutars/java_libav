package com.mutar.libav.bridge.avfilter;
import org.bridj.BridJ;
import org.bridj.CRuntime;
import org.bridj.Callback;
import org.bridj.FlagSet;
import org.bridj.IntValuedEnum;
import org.bridj.Pointer;
import org.bridj.ann.Library;
import org.bridj.ann.Name;
import org.bridj.ann.Ptr;
import org.bridj.ann.Runtime;
import org.bridj.util.DefaultParameterizedType;

import com.mutar.libav.bridge.avdevice.AvdeviceLibrary.AVDictionary;
import com.mutar.libav.bridge.avutil.AVClass;
import com.mutar.libav.bridge.avutil.AVFrame;
import com.mutar.libav.bridge.avutil.AVRational;
import com.mutar.libav.bridge.avutil.AvutilLibrary.AVMediaType;
/**
 * Wrapper for library <b>avfilter</b><br>
 * This file was autogenerated by <a href="http://jnaerator.googlecode.com/">JNAerator</a>,<br>
 * a tool written by <a href="http://ochafik.com/">Olivier Chafik</a> that <a href="http://code.google.com/p/jnaerator/wiki/CreditsAndLicense">uses a few opensource projects.</a>.<br>
 * For help, please visit <a href="http://nativelibs4java.googlecode.com/">NativeLibs4Java</a> or <a href="http://bridj.googlecode.com/">BridJ</a> .
 */
@Library(value = "avfilter", dependencies = {"postproc", "avresample"})
@Runtime(CRuntime.class)
public class AvfilterLibrary {
    static {
        BridJ.register();
    }
    /** < all automatic conversions enabled */
    public static final int AVFILTER_AUTO_CONVERT_ALL = 0;
    /** < all automatic conversions disabled */
    public static final int AVFILTER_AUTO_CONVERT_NONE = -1;
    public static final int AV_BUFFERSRC_FLAG_NO_CHECK_FORMAT = 1;
    public static final int AV_BUFFERSRC_FLAG_PUSH = 4;
    public static final int AV_BUFFERSRC_FLAG_KEEP_REF = 8;
    /**
     * Conversion Error : a.num<br>
     * SKIPPED:<br>
     * <i>native declaration : ffmpeg_build/include/libavutil/rational.h:0</i><br>
     * const int64_t tmp = a.num * (int64_t)b.den - b.num * (int64_t)a.den;
     */
    /** <i>native declaration : ffmpeg_build/include/libavfilter/version.h</i> */
    public static final int LIBAVFILTER_VERSION_MAJOR = (int)6;
    /** <i>native declaration : ffmpeg_build/include/libavfilter/version.h</i> */
    public static final int LIBAVFILTER_VERSION_MINOR = (int)12;
    /** <i>native declaration : ffmpeg_build/include/libavfilter/version.h</i> */
    public static final int LIBAVFILTER_VERSION_MICRO = (int)100;
    /** <i>native declaration : ffmpeg_build/include/libavfilter/version.h</i> */
    public static final int LIBAVFILTER_VERSION_INT = (int)((6) << 16 | (12) << 8 | (100));
    /**
     * define<br>
     * Conversion Error : 6.12.<br>
     * SKIPPED:<br>
     * <i>native declaration : ffmpeg_build/include/libavfilter/version.h:0</i><br>
     * 6.12.
     */
    /** <i>native declaration : ffmpeg_build/include/libavfilter/version.h</i> */
    public static final int LIBAVFILTER_BUILD = (int)((6) << 16 | (12) << 8 | (100));
    /** <i>native declaration : ffmpeg_build/include/libavfilter/version.h</i> */
    public static final String LIBAVFILTER_IDENT = (String)"Lavfi";
    /** <i>native declaration : ffmpeg_build/include/libavfilter/version.h</i> */
    public static final boolean FF_API_OLD_FILTER_OPTS = (boolean)(6 < 7);
    /** <i>native declaration : ffmpeg_build/include/libavfilter/version.h</i> */
    public static final boolean FF_API_OLD_FILTER_OPTS_ERROR = (boolean)(6 < 7);
    /** <i>native declaration : ffmpeg_build/include/libavfilter/version.h</i> */
    public static final boolean FF_API_AVFILTER_OPEN = (boolean)(6 < 7);
    /** <i>native declaration : ffmpeg_build/include/libavfilter/version.h</i> */
    public static final boolean FF_API_AVFILTER_INIT_FILTER = (boolean)(6 < 7);
    /** <i>native declaration : ffmpeg_build/include/libavfilter/version.h</i> */
    public static final boolean FF_API_OLD_FILTER_REGISTER = (boolean)(6 < 7);
    /** <i>native declaration : ffmpeg_build/include/libavfilter/version.h</i> */
    public static final boolean FF_API_NOCONST_GET_NAME = (boolean)(6 < 7);
    /** <i>native declaration : ffmpeg_build/include/libavfilter/avfilter.h</i> */
    public static final int AVFILTER_FLAG_DYNAMIC_INPUTS = (int)(1 << 0);
    /** <i>native declaration : ffmpeg_build/include/libavfilter/avfilter.h</i> */
    public static final int AVFILTER_FLAG_DYNAMIC_OUTPUTS = (int)(1 << 1);
    /** <i>native declaration : ffmpeg_build/include/libavfilter/avfilter.h</i> */
    public static final int AVFILTER_FLAG_SLICE_THREADS = (int)(1 << 2);
    /** <i>native declaration : ffmpeg_build/include/libavfilter/avfilter.h</i> */
    public static final int AVFILTER_FLAG_SUPPORT_TIMELINE_GENERIC = (int)(1 << 16);
    /** <i>native declaration : ffmpeg_build/include/libavfilter/avfilter.h</i> */
    public static final int AVFILTER_FLAG_SUPPORT_TIMELINE_INTERNAL = (int)(1 << 17);
    /** <i>native declaration : ffmpeg_build/include/libavfilter/avfilter.h</i> */
    public static final int AVFILTER_FLAG_SUPPORT_TIMELINE = (int)((1 << 16) | (1 << 17));
    /** <i>native declaration : ffmpeg_build/include/libavfilter/avfilter.h</i> */
    public static final int AVFILTER_THREAD_SLICE = (int)(1 << 0);
    /** <i>native declaration : ffmpeg_build/include/libavfilter/avfilter.h</i> */
    public static final int AVFILTER_CMD_FLAG_ONE = (int)1;
    /** <i>native declaration : ffmpeg_build/include/libavfilter/avfilter.h</i> */
    public static final int AVFILTER_CMD_FLAG_FAST = (int)2;
    /** <i>native declaration : ffmpeg_build/include/libavfilter/buffersink.h</i> */
    public static final int AV_BUFFERSINK_FLAG_PEEK = (int)1;
    /** <i>native declaration : ffmpeg_build/include/libavfilter/buffersink.h</i> */
    public static final int AV_BUFFERSINK_FLAG_NO_REQUEST = (int)2;
    /**
     * A function pointer passed to the @ref AVFilterGraph.execute callback to be<br>
     * executed multiple times, possibly in parallel.<br>
     * * @param ctx the filter context the job belongs to<br>
     * @param arg an opaque parameter passed through from @ref<br>
     *            AVFilterGraph.execute<br>
     * @param jobnr the index of the job being executed<br>
     * @param nb_jobs the total number of jobs<br>
     * * @return 0 on success, a negative AVERROR on error<br>
     * <i>native declaration : ffmpeg_build/include/libavfilter/avfilter.h:340</i>
     */
    public static abstract class avfilter_action_func extends Callback<avfilter_action_func > {
        public int apply(Pointer<AVFilterContext > ctx, Pointer<? > arg, int jobnr, int nb_jobs) {
            return apply(Pointer.getPeer(ctx), Pointer.getPeer(arg), jobnr, nb_jobs);
        }
        public int apply(@Ptr long ctx, @Ptr long arg, int jobnr, int nb_jobs) {
            return apply((Pointer)Pointer.pointerToAddress(ctx, AVFilterContext.class), Pointer.pointerToAddress(arg), jobnr, nb_jobs);
        }
    };
    /**
     * A function executing multiple jobs, possibly in parallel.<br>
     * * @param ctx the filter context to which the jobs belong<br>
     * @param func the function to be called multiple times<br>
     * @param arg the argument to be passed to func<br>
     * @param ret a nb_jobs-sized array to be filled with return values from each<br>
     *            invocation of func<br>
     * @param nb_jobs the number of jobs to execute<br>
     * * @return 0 on success, a negative AVERROR on error<br>
     * <i>native declaration : ffmpeg_build/include/libavfilter/avfilter.h:351</i>
     */
    public static abstract class avfilter_execute_func extends Callback<avfilter_execute_func > {
        public int apply(Pointer<AVFilterContext > ctx, Pointer<AvfilterLibrary.avfilter_action_func > func, Pointer<? > arg, Pointer<Integer > ret, int nb_jobs) {
            return apply(Pointer.getPeer(ctx), Pointer.getPeer(func), Pointer.getPeer(arg), Pointer.getPeer(ret), nb_jobs);
        }
        public int apply(@Ptr long ctx, @Ptr long func, @Ptr long arg, @Ptr long ret, int nb_jobs) {
            return apply((Pointer)Pointer.pointerToAddress(ctx, AVFilterContext.class), (Pointer)Pointer.pointerToAddress(func, AvfilterLibrary.avfilter_action_func.class), Pointer.pointerToAddress(arg), (Pointer)Pointer.pointerToAddress(ret, Integer.class), nb_jobs);
        }
    };
    /**
     * Return the LIBAVFILTER_VERSION_INT constant.<br>
     * Original signature : <code>int avfilter_version()</code><br>
     * <i>native declaration : ffmpeg_build/include/libavfilter/avfilter.h:4</i>
     */
    public native int avfilter_version();
    /**
     * Return the libavfilter build-time configuration.<br>
     * Original signature : <code>char* avfilter_configuration()</code><br>
     * <i>native declaration : ffmpeg_build/include/libavfilter/avfilter.h:9</i>
     */
    public Pointer<Byte > avfilter_configuration() {
        return (Pointer)Pointer.pointerToAddress(avfilter_configuration$2(), Byte.class);
    }
    @Ptr
    @Name("avfilter_configuration")
    protected native long avfilter_configuration$2();
    /**
     * Return the libavfilter license.<br>
     * Original signature : <code>char* avfilter_license()</code><br>
     * <i>native declaration : ffmpeg_build/include/libavfilter/avfilter.h:14</i>
     */
    public Pointer<Byte > avfilter_license() {
        return (Pointer)Pointer.pointerToAddress(avfilter_license$2(), Byte.class);
    }
    @Ptr
    @Name("avfilter_license")
    protected native long avfilter_license$2();
    /**
     * Get the number of elements in a NULL-terminated array of AVFilterPads (e.g.<br>
     * AVFilter.inputs/outputs).<br>
     * Original signature : <code>int avfilter_pad_count(const AVFilterPad*)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavfilter/avfilter.h:24</i>
     */
    public int avfilter_pad_count(Pointer<AvfilterLibrary.AVFilterPad > pads) {
        return avfilter_pad_count(Pointer.getPeer(pads));
    }
    protected native int avfilter_pad_count(@Ptr long pads);
    /**
     * Get the name of an AVFilterPad.<br>
     * @param pads an array of AVFilterPads<br>
     * @param pad_idx index of the pad in the array it; is the caller's<br>
     *                responsibility to ensure the index is valid<br>
     * @return name of the pad_idx'th pad in pads<br>
     * Original signature : <code>char* avfilter_pad_get_name(const AVFilterPad*, int)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavfilter/avfilter.h:33</i>
     */
    public Pointer<Byte > avfilter_pad_get_name(Pointer<AvfilterLibrary.AVFilterPad > pads, int pad_idx) {
        return (Pointer)Pointer.pointerToAddress(avfilter_pad_get_name(Pointer.getPeer(pads), pad_idx), Byte.class);
    }
    @Ptr
    protected native long avfilter_pad_get_name(@Ptr long pads, int pad_idx);
    /**
     * Get the type of an AVFilterPad.<br>
     * @param pads an array of AVFilterPads<br>
     * @param pad_idx index of the pad in the array; it is the caller's<br>
     *                responsibility to ensure the index is valid<br>
     * @return type of the pad_idx'th pad in pads<br>
     * Original signature : <code>AVMediaType avfilter_pad_get_type(const AVFilterPad*, int)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavfilter/avfilter.h:42</i>
     */
    public IntValuedEnum<AVMediaType > avfilter_pad_get_type(Pointer<AvfilterLibrary.AVFilterPad > pads, int pad_idx) {
        return FlagSet.fromValue(avfilter_pad_get_type(Pointer.getPeer(pads), pad_idx), AVMediaType.class);
    }
    protected native int avfilter_pad_get_type(@Ptr long pads, int pad_idx);
    /**
     * Link two filters together.<br>
     * @param src    the source filter<br>
     * @param srcpad index of the output pad on the source filter<br>
     * @param dst    the destination filter<br>
     * @param dstpad index of the input pad on the destination filter<br>
     * @return       zero on success<br>
     * Original signature : <code>int avfilter_link(AVFilterContext*, unsigned, AVFilterContext*, unsigned)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavfilter/avfilter.h:179</i>
     */
    public int avfilter_link(Pointer<AVFilterContext > src, int srcpad, Pointer<AVFilterContext > dst, int dstpad) {
        return avfilter_link(Pointer.getPeer(src), srcpad, Pointer.getPeer(dst), dstpad);
    }
    protected native int avfilter_link(@Ptr long src, int srcpad, @Ptr long dst, int dstpad);
    /**
     * Free the link in *link, and set its pointer to NULL.<br>
     * Original signature : <code>void avfilter_link_free(AVFilterLink**)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavfilter/avfilter.h:184</i>
     */
    public void avfilter_link_free(Pointer<Pointer<AVFilterLink > > link) {
        avfilter_link_free(Pointer.getPeer(link));
    }
    protected native void avfilter_link_free(@Ptr long link);
    /**
     * Get the number of channels of a link.<br>
     * Original signature : <code>int avfilter_link_get_channels(AVFilterLink*)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavfilter/avfilter.h:189</i>
     */
    public int avfilter_link_get_channels(Pointer<AVFilterLink > link) {
        return avfilter_link_get_channels(Pointer.getPeer(link));
    }
    protected native int avfilter_link_get_channels(@Ptr long link);
    /**
     * Set the closed field of a link.<br>
     * Original signature : <code>void avfilter_link_set_closed(AVFilterLink*, int)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavfilter/avfilter.h:194</i>
     */
    public void avfilter_link_set_closed(Pointer<AVFilterLink > link, int closed) {
        avfilter_link_set_closed(Pointer.getPeer(link), closed);
    }
    protected native void avfilter_link_set_closed(@Ptr long link, int closed);
    /**
     * Negotiate the media format, dimensions, etc of all inputs to a filter.<br>
     * @param filter the filter to negotiate the properties for its inputs<br>
     * @return       zero on successful negotiation<br>
     * Original signature : <code>int avfilter_config_links(AVFilterContext*)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavfilter/avfilter.h:201</i>
     */
    public int avfilter_config_links(Pointer<AVFilterContext > filter) {
        return avfilter_config_links(Pointer.getPeer(filter));
    }
    protected native int avfilter_config_links(@Ptr long filter);
    /**
     * Make the filter instance process a command.<br>
     * It is recommended to use avfilter_graph_send_command().<br>
     * Original signature : <code>int avfilter_process_command(AVFilterContext*, const char*, const char*, char*, int, int)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavfilter/avfilter.h:207</i>
     */
    public int avfilter_process_command(Pointer<AVFilterContext > filter, Pointer<Byte > cmd, Pointer<Byte > arg, Pointer<Byte > res, int res_len, int flags) {
        return avfilter_process_command(Pointer.getPeer(filter), Pointer.getPeer(cmd), Pointer.getPeer(arg), Pointer.getPeer(res), res_len, flags);
    }
    protected native int avfilter_process_command(@Ptr long filter, @Ptr long cmd, @Ptr long arg, @Ptr long res, int res_len, int flags);
    /**
     * Initialize the filter system. Register all builtin filters.<br>
     * Original signature : <code>void avfilter_register_all()</code><br>
     * <i>native declaration : ffmpeg_build/include/libavfilter/avfilter.h:212</i>
     */
    public native void avfilter_register_all();
    /**
     * Uninitialize the filter system. Unregister all filters.<br>
     * Original signature : <code>void avfilter_uninit()</code><br>
     * <i>native declaration : ffmpeg_build/include/libavfilter/avfilter.h:217</i>
     */
    public native void avfilter_uninit();
    /**
     * Register a filter. This is only needed if you plan to use<br>
     * avfilter_get_by_name later to lookup the AVFilter structure by name. A<br>
     * filter can still by instantiated with avfilter_graph_alloc_filter even if it<br>
     * is not registered.<br>
     * @param filter the filter to register<br>
     * @return 0 if the registration was successful, a negative value<br>
     * otherwise<br>
     * Original signature : <code>int avfilter_register(AVFilter*)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavfilter/avfilter.h:228</i>
     */
    public int avfilter_register(Pointer<AVFilter > filter) {
        return avfilter_register(Pointer.getPeer(filter));
    }
    protected native int avfilter_register(@Ptr long filter);
    /**
     * Get a filter definition matching the given name.<br>
     * @param name the filter name to find<br>
     * @return     the filter definition, if any matching one is registered.<br>
     *             NULL if none found.<br>
     * Original signature : <code>AVFilter* avfilter_get_by_name(const char*)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavfilter/avfilter.h:236</i>
     */
    public Pointer<AVFilter > avfilter_get_by_name(Pointer<Byte > name) {
        return (Pointer)Pointer.pointerToAddress(avfilter_get_by_name(Pointer.getPeer(name)), AVFilter.class);
    }
    @Ptr
    protected native long avfilter_get_by_name(@Ptr long name);
    /**
     * Iterate over all registered filters.<br>
     * @return If prev is non-NULL, next registered filter after prev or NULL if<br>
     * prev is the last filter. If prev is NULL, return the first registered filter.<br>
     * Original signature : <code>AVFilter* avfilter_next(const AVFilter*)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavfilter/avfilter.h:243</i>
     */
    public Pointer<AVFilter > avfilter_next(Pointer<AVFilter > prev) {
        return (Pointer)Pointer.pointerToAddress(avfilter_next(Pointer.getPeer(prev)), AVFilter.class);
    }
    @Ptr
    protected native long avfilter_next(@Ptr long prev);
    /**
     * If filter is NULL, returns a pointer to the first registered filter pointer,<br>
     * if filter is non-NULL, returns the next pointer after filter.<br>
     * If the returned pointer points to NULL, the last registered filter<br>
     * was already reached.<br>
     * @deprecated use avfilter_next()<br>
     * Original signature : <code>AVFilter** av_filter_next(AVFilter**)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavfilter/avfilter.h:252</i>
     */
    public Pointer<Pointer<AVFilter > > av_filter_next(Pointer<Pointer<AVFilter > > filter) {
        return (Pointer)Pointer.pointerToAddress(av_filter_next(Pointer.getPeer(filter)), DefaultParameterizedType.paramType(Pointer.class, AVFilter.class));
    }
    @Ptr
    protected native long av_filter_next(@Ptr long filter);
    /**
     * Create a filter instance.<br>
     * @param filter_ctx put here a pointer to the created filter context<br>
     * on success, NULL on failure<br>
     * @param filter    the filter to create an instance of<br>
     * @param inst_name Name to give to the new instance. Can be NULL for none.<br>
     * @return >= 0 in case of success, a negative error code otherwise<br>
     * @deprecated use avfilter_graph_alloc_filter() instead<br>
     * Original signature : <code>int avfilter_open(AVFilterContext**, AVFilter*, const char*)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavfilter/avfilter.h:263</i>
     */
    public int avfilter_open(Pointer<Pointer<AVFilterContext > > filter_ctx, Pointer<AVFilter > filter, Pointer<Byte > inst_name) {
        return avfilter_open(Pointer.getPeer(filter_ctx), Pointer.getPeer(filter), Pointer.getPeer(inst_name));
    }
    protected native int avfilter_open(@Ptr long filter_ctx, @Ptr long filter, @Ptr long inst_name);
    /**
     * Initialize a filter.<br>
     * @param filter the filter to initialize<br>
     * @param args   A string of parameters to use when initializing the filter.<br>
     *               The format and meaning of this string varies by filter.<br>
     * @param opaque Any extra non-string data needed by the filter. The meaning<br>
     *               of this parameter varies by filter.<br>
     * @return       zero on success<br>
     * Original signature : <code>int avfilter_init_filter(AVFilterContext*, const char*, void*)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavfilter/avfilter.h:274</i>
     */
    public int avfilter_init_filter(Pointer<AVFilterContext > filter, Pointer<Byte > args, Pointer<? > opaque) {
        return avfilter_init_filter(Pointer.getPeer(filter), Pointer.getPeer(args), Pointer.getPeer(opaque));
    }
    protected native int avfilter_init_filter(@Ptr long filter, @Ptr long args, @Ptr long opaque);
    /**
     * Initialize a filter with the supplied parameters.<br>
     * @param ctx  uninitialized filter context to initialize<br>
     * @param args Options to initialize the filter with. This must be a<br>
     *             ':'-separated list of options in the 'key=value' form.<br>
     *             May be NULL if the options have been set directly using the<br>
     *             AVOptions API or there are no options that need to be set.<br>
     * @return 0 on success, a negative AVERROR on failure<br>
     * Original signature : <code>int avfilter_init_str(AVFilterContext*, const char*)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavfilter/avfilter.h:285</i>
     */
    public int avfilter_init_str(Pointer<AVFilterContext > ctx, Pointer<Byte > args) {
        return avfilter_init_str(Pointer.getPeer(ctx), Pointer.getPeer(args));
    }
    protected native int avfilter_init_str(@Ptr long ctx, @Ptr long args);
    /**
     * Initialize a filter with the supplied dictionary of options.<br>
     * @param ctx     uninitialized filter context to initialize<br>
     * @param options An AVDictionary filled with options for this filter. On<br>
     *                return this parameter will be destroyed and replaced with<br>
     *                a dict containing options that were not found. This dictionary<br>
     *                must be freed by the caller.<br>
     *                May be NULL, then this function is equivalent to<br>
     *                avfilter_init_str() with the second parameter set to NULL.<br>
     * @return 0 on success, a negative AVERROR on failure<br>
     * @note This function and avfilter_init_str() do essentially the same thing,<br>
     * the difference is in manner in which the options are passed. It is up to the<br>
     * calling code to choose whichever is more preferable. The two functions also<br>
     * behave differently when some of the provided options are not declared as<br>
     * supported by the filter. In such a case, avfilter_init_str() will fail, but<br>
     * this function will leave those extra options in the options AVDictionary and<br>
     * continue as usual.<br>
     * Original signature : <code>int avfilter_init_dict(AVFilterContext*, AVDictionary**)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavfilter/avfilter.h:305</i>
     */
    public int avfilter_init_dict(Pointer<AVFilterContext > ctx, Pointer<Pointer<AVDictionary > > options) {
        return avfilter_init_dict(Pointer.getPeer(ctx), Pointer.getPeer(options));
    }
    protected native int avfilter_init_dict(@Ptr long ctx, @Ptr long options);
    /**
     * Free a filter context. This will also remove the filter from its<br>
     * filtergraph's list of filters.<br>
     * @param filter the filter to free<br>
     * Original signature : <code>void avfilter_free(AVFilterContext*)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavfilter/avfilter.h:312</i>
     */
    public void avfilter_free(Pointer<AVFilterContext > filter) {
        avfilter_free(Pointer.getPeer(filter));
    }
    protected native void avfilter_free(@Ptr long filter);
    /**
     * Insert a filter in the middle of an existing link.<br>
     * @param link the link into which the filter should be inserted<br>
     * @param filt the filter to be inserted<br>
     * @param filt_srcpad_idx the input pad on the filter to connect<br>
     * @param filt_dstpad_idx the output pad on the filter to connect<br>
     * @return     zero on success<br>
     * Original signature : <code>int avfilter_insert_filter(AVFilterLink*, AVFilterContext*, unsigned, unsigned)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavfilter/avfilter.h:322</i>
     */
    public int avfilter_insert_filter(Pointer<AVFilterLink > link, Pointer<AVFilterContext > filt, int filt_srcpad_idx, int filt_dstpad_idx) {
        return avfilter_insert_filter(Pointer.getPeer(link), Pointer.getPeer(filt), filt_srcpad_idx, filt_dstpad_idx);
    }
    protected native int avfilter_insert_filter(@Ptr long link, @Ptr long filt, int filt_srcpad_idx, int filt_dstpad_idx);
    /**
     * @return AVClass for AVFilterContext.<br>
     * @see av_opt_find().<br>
     * Original signature : <code>AVClass* avfilter_get_class()</code><br>
     * <i>native declaration : ffmpeg_build/include/libavfilter/avfilter.h:328</i>
     */
    public Pointer<AVClass > avfilter_get_class() {
        return (Pointer)Pointer.pointerToAddress(avfilter_get_class$2(), AVClass.class);
    }
    @Ptr
    @Name("avfilter_get_class")
    protected native long avfilter_get_class$2();
    /**
     * Allocate a filter graph.<br>
     * @return the allocated filter graph on success or NULL.<br>
     * Original signature : <code>AVFilterGraph* avfilter_graph_alloc()</code><br>
     * <i>native declaration : ffmpeg_build/include/libavfilter/avfilter.h:376</i>
     */
    public Pointer<AVFilterGraph > avfilter_graph_alloc() {
        return (Pointer)Pointer.pointerToAddress(avfilter_graph_alloc$2(), AVFilterGraph.class);
    }
    @Ptr
    @Name("avfilter_graph_alloc")
    protected native long avfilter_graph_alloc$2();
    /**
     * Create a new filter instance in a filter graph.<br>
     * @param graph graph in which the new filter will be used<br>
     * @param filter the filter to create an instance of<br>
     * @param name Name to give to the new instance (will be copied to<br>
     *             AVFilterContext.name). This may be used by the caller to identify<br>
     *             different filters, libavfilter itself assigns no semantics to<br>
     *             this parameter. May be NULL.<br>
     * @return the context of the newly created filter instance (note that it is<br>
     *         also retrievable directly through AVFilterGraph.filters or with<br>
     *         avfilter_graph_get_filter()) on success or NULL on failure.<br>
     * Original signature : <code>AVFilterContext* avfilter_graph_alloc_filter(AVFilterGraph*, const AVFilter*, const char*)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavfilter/avfilter.h:390</i>
     */
    public Pointer<AVFilterContext > avfilter_graph_alloc_filter(Pointer<AVFilterGraph > graph, Pointer<AVFilter > filter, Pointer<Byte > name) {
        return (Pointer)Pointer.pointerToAddress(avfilter_graph_alloc_filter(Pointer.getPeer(graph), Pointer.getPeer(filter), Pointer.getPeer(name)), AVFilterContext.class);
    }
    @Ptr
    protected native long avfilter_graph_alloc_filter(@Ptr long graph, @Ptr long filter, @Ptr long name);
    /**
     * Get a filter instance identified by instance name from graph.<br>
     * @param graph filter graph to search through.<br>
     * @param name filter instance name (should be unique in the graph).<br>
     * @return the pointer to the found filter instance or NULL if it<br>
     * cannot be found.<br>
     * Original signature : <code>AVFilterContext* avfilter_graph_get_filter(AVFilterGraph*, const char*)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavfilter/avfilter.h:399</i>
     */
    public Pointer<AVFilterContext > avfilter_graph_get_filter(Pointer<AVFilterGraph > graph, Pointer<Byte > name) {
        return (Pointer)Pointer.pointerToAddress(avfilter_graph_get_filter(Pointer.getPeer(graph), Pointer.getPeer(name)), AVFilterContext.class);
    }
    @Ptr
    protected native long avfilter_graph_get_filter(@Ptr long graph, @Ptr long name);
    /**
     * Add an existing filter instance to a filter graph.<br>
     * @param graphctx  the filter graph<br>
     * @param filter the filter to be added<br>
     * @deprecated use avfilter_graph_alloc_filter() to allocate a filter in a<br>
     * filter graph<br>
     * Original signature : <code>int avfilter_graph_add_filter(AVFilterGraph*, AVFilterContext*)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavfilter/avfilter.h:408</i>
     */
    public int avfilter_graph_add_filter(Pointer<AVFilterGraph > graphctx, Pointer<AVFilterContext > filter) {
        return avfilter_graph_add_filter(Pointer.getPeer(graphctx), Pointer.getPeer(filter));
    }
    protected native int avfilter_graph_add_filter(@Ptr long graphctx, @Ptr long filter);
    /**
     * Create and add a filter instance into an existing graph.<br>
     * The filter instance is created from the filter filt and inited<br>
     * with the parameters args and opaque.<br>
     * In case of success put in *filt_ctx the pointer to the created<br>
     * filter instance, otherwise set *filt_ctx to NULL.<br>
     * @param name the instance name to give to the created filter instance<br>
     * @param graph_ctx the filter graph<br>
     * @return a negative AVERROR error code in case of failure, a non<br>
     * negative value otherwise<br>
     * Original signature : <code>int avfilter_graph_create_filter(AVFilterContext**, const AVFilter*, const char*, const char*, void*, AVFilterGraph*)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavfilter/avfilter.h:421</i>
     */
    public int avfilter_graph_create_filter(Pointer<Pointer<AVFilterContext > > filt_ctx, Pointer<AVFilter > filt, Pointer<Byte > name, Pointer<Byte > args, Pointer<? > opaque, Pointer<AVFilterGraph > graph_ctx) {
        return avfilter_graph_create_filter(Pointer.getPeer(filt_ctx), Pointer.getPeer(filt), Pointer.getPeer(name), Pointer.getPeer(args), Pointer.getPeer(opaque), Pointer.getPeer(graph_ctx));
    }
    protected native int avfilter_graph_create_filter(@Ptr long filt_ctx, @Ptr long filt, @Ptr long name, @Ptr long args, @Ptr long opaque, @Ptr long graph_ctx);
    /**
     * Enable or disable automatic format conversion inside the graph.<br>
     * Note that format conversion can still happen inside explicitly inserted<br>
     * scale and aresample filters.<br>
     * @param flags  any of the AVFILTER_AUTO_CONVERT_* constants<br>
     * Original signature : <code>void avfilter_graph_set_auto_convert(AVFilterGraph*, unsigned)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavfilter/avfilter.h:429</i>
     */
    public void avfilter_graph_set_auto_convert(Pointer<AVFilterGraph > graph, int flags) {
        avfilter_graph_set_auto_convert(Pointer.getPeer(graph), flags);
    }
    protected native void avfilter_graph_set_auto_convert(@Ptr long graph, int flags);
    /**
     * Check validity and configure all the links and formats in the graph.<br>
     * @param graphctx the filter graph<br>
     * @param log_ctx context used for logging<br>
     * @return >= 0 in case of success, a negative AVERROR code otherwise<br>
     * Original signature : <code>int avfilter_graph_config(AVFilterGraph*, void*)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavfilter/avfilter.h:441</i>
     */
    public int avfilter_graph_config(Pointer<AVFilterGraph > graphctx, Pointer<? > log_ctx) {
        return avfilter_graph_config(Pointer.getPeer(graphctx), Pointer.getPeer(log_ctx));
    }
    protected native int avfilter_graph_config(@Ptr long graphctx, @Ptr long log_ctx);
    /**
     * Free a graph, destroy its links, and set *graph to NULL.<br>
     * If *graph is NULL, do nothing.<br>
     * Original signature : <code>void avfilter_graph_free(AVFilterGraph**)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavfilter/avfilter.h:447</i>
     */
    public void avfilter_graph_free(Pointer<Pointer<AVFilterGraph > > graph) {
        avfilter_graph_free(Pointer.getPeer(graph));
    }
    protected native void avfilter_graph_free(@Ptr long graph);
    /**
     * Allocate a single AVFilterInOut entry.<br>
     * Must be freed with avfilter_inout_free().<br>
     * @return allocated AVFilterInOut on success, NULL on failure.<br>
     * Original signature : <code>AVFilterInOut* avfilter_inout_alloc()</code><br>
     * <i>native declaration : ffmpeg_build/include/libavfilter/avfilter.h:468</i>
     */
    public Pointer<AVFilterInOut > avfilter_inout_alloc() {
        return (Pointer)Pointer.pointerToAddress(avfilter_inout_alloc$2(), AVFilterInOut.class);
    }
    @Ptr
    @Name("avfilter_inout_alloc")
    protected native long avfilter_inout_alloc$2();
    /**
     * Free the supplied list of AVFilterInOut and set *inout to NULL.<br>
     * If *inout is NULL, do nothing.<br>
     * Original signature : <code>void avfilter_inout_free(AVFilterInOut**)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavfilter/avfilter.h:474</i>
     */
    public void avfilter_inout_free(Pointer<Pointer<AVFilterInOut > > inout) {
        avfilter_inout_free(Pointer.getPeer(inout));
    }
    protected native void avfilter_inout_free(@Ptr long inout);
    /**
     * Add a graph described by a string to a graph.<br>
     * @note The caller must provide the lists of inputs and outputs,<br>
     * which therefore must be known before calling the function.<br>
     * @note The inputs parameter describes inputs of the already existing<br>
     * part of the graph; i.e. from the point of view of the newly created<br>
     * part, they are outputs. Similarly the outputs parameter describes<br>
     * outputs of the already existing filters, which are provided as<br>
     * inputs to the parsed filters.<br>
     * @param graph   the filter graph where to link the parsed graph context<br>
     * @param filters string to be parsed<br>
     * @param inputs  linked list to the inputs of the graph<br>
     * @param outputs linked list to the outputs of the graph<br>
     * @return zero on success, a negative AVERROR code on error<br>
     * Original signature : <code>int avfilter_graph_parse(AVFilterGraph*, const char*, AVFilterInOut*, AVFilterInOut*, void*)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavfilter/avfilter.h:491</i>
     */
    public int avfilter_graph_parse(Pointer<AVFilterGraph > graph, Pointer<Byte > filters, Pointer<AVFilterInOut > inputs, Pointer<AVFilterInOut > outputs, Pointer<? > log_ctx) {
        return avfilter_graph_parse(Pointer.getPeer(graph), Pointer.getPeer(filters), Pointer.getPeer(inputs), Pointer.getPeer(outputs), Pointer.getPeer(log_ctx));
    }
    protected native int avfilter_graph_parse(@Ptr long graph, @Ptr long filters, @Ptr long inputs, @Ptr long outputs, @Ptr long log_ctx);
    /**
     * Add a graph described by a string to a graph.<br>
     * In the graph filters description, if the input label of the first<br>
     * filter is not specified, "in" is assumed; if the output label of<br>
     * the last filter is not specified, "out" is assumed.<br>
     * @param graph   the filter graph where to link the parsed graph context<br>
     * @param filters string to be parsed<br>
     * @param inputs  pointer to a linked list to the inputs of the graph, may be NULL.<br>
     *                If non-NULL, *inputs is updated to contain the list of open inputs<br>
     *                after the parsing, should be freed with avfilter_inout_free().<br>
     * @param outputs pointer to a linked list to the outputs of the graph, may be NULL.<br>
     *                If non-NULL, *outputs is updated to contain the list of open outputs<br>
     *                after the parsing, should be freed with avfilter_inout_free().<br>
     * @return non negative on success, a negative AVERROR code on error<br>
     * Original signature : <code>int avfilter_graph_parse_ptr(AVFilterGraph*, const char*, AVFilterInOut**, AVFilterInOut**, void*)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavfilter/avfilter.h:508</i>
     */
    public int avfilter_graph_parse_ptr(Pointer<AVFilterGraph > graph, Pointer<Byte > filters, Pointer<Pointer<AVFilterInOut > > inputs, Pointer<Pointer<AVFilterInOut > > outputs, Pointer<? > log_ctx) {
        return avfilter_graph_parse_ptr(Pointer.getPeer(graph), Pointer.getPeer(filters), Pointer.getPeer(inputs), Pointer.getPeer(outputs), Pointer.getPeer(log_ctx));
    }
    protected native int avfilter_graph_parse_ptr(@Ptr long graph, @Ptr long filters, @Ptr long inputs, @Ptr long outputs, @Ptr long log_ctx);
    /**
     * Add a graph described by a string to a graph.<br>
     * @param[in]  graph   the filter graph where to link the parsed graph context<br>
     * @param[in]  filters string to be parsed<br>
     * @param[out] inputs  a linked list of all free (unlinked) inputs of the<br>
     *                     parsed graph will be returned here. It is to be freed<br>
     *                     by the caller using avfilter_inout_free().<br>
     * @param[out] outputs a linked list of all free (unlinked) outputs of the<br>
     *                     parsed graph will be returned here. It is to be freed by the<br>
     *                     caller using avfilter_inout_free().<br>
     * @return zero on success, a negative AVERROR code on error<br>
     * @note This function returns the inputs and outputs that are left<br>
     * unlinked after parsing the graph and the caller then deals with<br>
     * them.<br>
     * @note This function makes no reference whatsoever to already<br>
     * existing parts of the graph and the inputs parameter will on return<br>
     * contain inputs of the newly parsed part of the graph.  Analogously<br>
     * the outputs parameter will contain outputs of the newly created<br>
     * filters.<br>
     * Original signature : <code>int avfilter_graph_parse2(AVFilterGraph*, const char*, AVFilterInOut**, AVFilterInOut**)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavfilter/avfilter.h:530</i>
     */
    public int avfilter_graph_parse2(Pointer<AVFilterGraph > graph, Pointer<Byte > filters, Pointer<Pointer<AVFilterInOut > > inputs, Pointer<Pointer<AVFilterInOut > > outputs) {
        return avfilter_graph_parse2(Pointer.getPeer(graph), Pointer.getPeer(filters), Pointer.getPeer(inputs), Pointer.getPeer(outputs));
    }
    protected native int avfilter_graph_parse2(@Ptr long graph, @Ptr long filters, @Ptr long inputs, @Ptr long outputs);
    /**
     * Send a command to one or more filter instances.<br>
     * @param graph  the filter graph<br>
     * @param target the filter(s) to which the command should be sent<br>
     *               "all" sends to all filters<br>
     *               otherwise it can be a filter or filter instance name<br>
     *               which will send the command to all matching filters.<br>
     * @param cmd    the command to send, for handling simplicity all commands must be alphanumeric only<br>
     * @param arg    the argument for the command<br>
     * @param res    a buffer with size res_size where the filter(s) can return a response.<br>
     * @returns >=0 on success otherwise an error code.<br>
     *              AVERROR(ENOSYS) on unsupported commands<br>
     * Original signature : <code>int avfilter_graph_send_command(AVFilterGraph*, const char*, const char*, const char*, char*, int, int)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavfilter/avfilter.h:545</i>
     */
    public int avfilter_graph_send_command(Pointer<AVFilterGraph > graph, Pointer<Byte > target, Pointer<Byte > cmd, Pointer<Byte > arg, Pointer<Byte > res, int res_len, int flags) {
        return avfilter_graph_send_command(Pointer.getPeer(graph), Pointer.getPeer(target), Pointer.getPeer(cmd), Pointer.getPeer(arg), Pointer.getPeer(res), res_len, flags);
    }
    protected native int avfilter_graph_send_command(@Ptr long graph, @Ptr long target, @Ptr long cmd, @Ptr long arg, @Ptr long res, int res_len, int flags);
    /**
     * Queue a command for one or more filter instances.<br>
     * @param graph  the filter graph<br>
     * @param target the filter(s) to which the command should be sent<br>
     *               "all" sends to all filters<br>
     *               otherwise it can be a filter or filter instance name<br>
     *               which will send the command to all matching filters.<br>
     * @param cmd    the command to sent, for handling simplicity all commands must be alphanumeric only<br>
     * @param arg    the argument for the command<br>
     * @param ts     time at which the command should be sent to the filter<br>
     * @note As this executes commands after this function returns, no return code<br>
     *       from the filter is provided, also AVFILTER_CMD_FLAG_ONE is not supported.<br>
     * Original signature : <code>int avfilter_graph_queue_command(AVFilterGraph*, const char*, const char*, const char*, int, double)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavfilter/avfilter.h:560</i>
     */
    public int avfilter_graph_queue_command(Pointer<AVFilterGraph > graph, Pointer<Byte > target, Pointer<Byte > cmd, Pointer<Byte > arg, int flags, double ts) {
        return avfilter_graph_queue_command(Pointer.getPeer(graph), Pointer.getPeer(target), Pointer.getPeer(cmd), Pointer.getPeer(arg), flags, ts);
    }
    protected native int avfilter_graph_queue_command(@Ptr long graph, @Ptr long target, @Ptr long cmd, @Ptr long arg, int flags, double ts);
    /**
     * Dump a graph into a human-readable string representation.<br>
     * @param graph    the graph to dump<br>
     * @param options  formatting options; currently ignored<br>
     * @return  a string, or NULL in case of memory allocation failure;<br>
     *          the string must be freed using av_free<br>
     * Original signature : <code>char* avfilter_graph_dump(AVFilterGraph*, const char*)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavfilter/avfilter.h:569</i>
     */
    public Pointer<Byte > avfilter_graph_dump(Pointer<AVFilterGraph > graph, Pointer<Byte > options) {
        return (Pointer)Pointer.pointerToAddress(avfilter_graph_dump(Pointer.getPeer(graph), Pointer.getPeer(options)), Byte.class);
    }
    @Ptr
    protected native long avfilter_graph_dump(@Ptr long graph, @Ptr long options);
    /**
     * Request a frame on the oldest sink link.<br>
     * If the request returns AVERROR_EOF, try the next.<br>
     * Note that this function is not meant to be the sole scheduling mechanism<br>
     * of a filtergraph, only a convenience function to help drain a filtergraph<br>
     * in a balanced way under normal circumstances.<br>
     * Also note that AVERROR_EOF does not mean that frames did not arrive on<br>
     * some of the sinks during the process.<br>
     * When there are multiple sink links, in case the requested link<br>
     * returns an EOF, this may cause a filter to flush pending frames<br>
     * which are sent to another sink link, although unrequested.<br>
     * @return  the return value of ff_request_frame(),<br>
     *          or AVERROR_EOF if all links returned AVERROR_EOF<br>
     * Original signature : <code>int avfilter_graph_request_oldest(AVFilterGraph*)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavfilter/avfilter.h:585</i>
     */
    public int avfilter_graph_request_oldest(Pointer<AVFilterGraph > graph) {
        return avfilter_graph_request_oldest(Pointer.getPeer(graph));
    }
    protected native int avfilter_graph_request_oldest(@Ptr long graph);
    /**
     * Get the number of failed requests.<br>
     * A failed request is when the request_frame method is called while no<br>
     * frame is present in the buffer.<br>
     * The number is reset when a frame is added.<br>
     * Original signature : <code>int av_buffersrc_get_nb_failed_requests(AVFilterContext*)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavfilter/buffersrc.h:17</i>
     */
    public int av_buffersrc_get_nb_failed_requests(Pointer<AVFilterContext > buffer_src) {
        return av_buffersrc_get_nb_failed_requests(Pointer.getPeer(buffer_src));
    }
    protected native int av_buffersrc_get_nb_failed_requests(@Ptr long buffer_src);
    /**
     * Add a frame to the buffer source.<br>
     * @param ctx   an instance of the buffersrc filter<br>
     * @param frame frame to be added. If the frame is reference counted, this<br>
     * function will make a new reference to it. Otherwise the frame data will be<br>
     * copied.<br>
     * @return 0 on success, a negative AVERROR on error<br>
     * This function is equivalent to av_buffersrc_add_frame_flags() with the<br>
     * AV_BUFFERSRC_FLAG_KEEP_REF flag.<br>
     * Original signature : <code>int av_buffersrc_write_frame(AVFilterContext*, const AVFrame*)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavfilter/buffersrc.h:29</i>
     */
    public int av_buffersrc_write_frame(Pointer<AVFilterContext > ctx, Pointer<AVFrame > frame) {
        return av_buffersrc_write_frame(Pointer.getPeer(ctx), Pointer.getPeer(frame));
    }
    protected native int av_buffersrc_write_frame(@Ptr long ctx, @Ptr long frame);
    /**
     * Add a frame to the buffer source.<br>
     * @param ctx   an instance of the buffersrc filter<br>
     * @param frame frame to be added. If the frame is reference counted, this<br>
     * function will take ownership of the reference(s) and reset the frame.<br>
     * Otherwise the frame data will be copied. If this function returns an error,<br>
     * the input frame is not touched.<br>
     * @return 0 on success, a negative AVERROR on error.<br>
     * @note the difference between this function and av_buffersrc_write_frame() is<br>
     * that av_buffersrc_write_frame() creates a new reference to the input frame,<br>
     * while this function takes ownership of the reference passed to it.<br>
     * This function is equivalent to av_buffersrc_add_frame_flags() without the<br>
     * AV_BUFFERSRC_FLAG_KEEP_REF flag.<br>
     * Original signature : <code>int av_buffersrc_add_frame(AVFilterContext*, AVFrame*)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavfilter/buffersrc.h:45</i>
     */
    public int av_buffersrc_add_frame(Pointer<AVFilterContext > ctx, Pointer<AVFrame > frame) {
        return av_buffersrc_add_frame(Pointer.getPeer(ctx), Pointer.getPeer(frame));
    }
    protected native int av_buffersrc_add_frame(@Ptr long ctx, @Ptr long frame);
    /**
     * Add a frame to the buffer source.<br>
     * By default, if the frame is reference-counted, this function will take<br>
     * ownership of the reference(s) and reset the frame. This can be controlled<br>
     * using the flags.<br>
     * If this function returns an error, the input frame is not touched.<br>
     * @param buffer_src  pointer to a buffer source context<br>
     * @param frame       a frame, or NULL to mark EOF<br>
     * @param flags       a combination of AV_BUFFERSRC_FLAG_*<br>
     * @return            >= 0 in case of success, a negative AVERROR code<br>
     *                    in case of failure<br>
     * Original signature : <code>int av_buffersrc_add_frame_flags(AVFilterContext*, AVFrame*, int)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavfilter/buffersrc.h:59</i>
     */
    public int av_buffersrc_add_frame_flags(Pointer<AVFilterContext > buffer_src, Pointer<AVFrame > frame, int flags) {
        return av_buffersrc_add_frame_flags(Pointer.getPeer(buffer_src), Pointer.getPeer(frame), flags);
    }
    protected native int av_buffersrc_add_frame_flags(@Ptr long buffer_src, @Ptr long frame, int flags);
    /**
     * Get a frame with filtered data from sink and put it in frame.<br>
     * @param ctx    pointer to a buffersink or abuffersink filter context.<br>
     * @param frame  pointer to an allocated frame that will be filled with data.<br>
     *               The data must be freed using av_frame_unref() / av_frame_free()<br>
     * @param flags  a combination of AV_BUFFERSINK_FLAG_* flags<br>
     * @return  >= 0 in for success, a negative AVERROR code for failure.<br>
     * Original signature : <code>int av_buffersink_get_frame_flags(AVFilterContext*, AVFrame*, int)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavfilter/buffersink.h:9</i>
     */
    public int av_buffersink_get_frame_flags(Pointer<AVFilterContext > ctx, Pointer<AVFrame > frame, int flags) {
        return av_buffersink_get_frame_flags(Pointer.getPeer(ctx), Pointer.getPeer(frame), flags);
    }
    protected native int av_buffersink_get_frame_flags(@Ptr long ctx, @Ptr long frame, int flags);
    /**
     * Create an AVBufferSinkParams structure.<br>
     * Must be freed with av_free().<br>
     * Original signature : <code>AVBufferSinkParams* av_buffersink_params_alloc()</code><br>
     * <i>native declaration : ffmpeg_build/include/libavfilter/buffersink.h:22</i>
     */
    public Pointer<AVBufferSinkParams > av_buffersink_params_alloc() {
        return (Pointer)Pointer.pointerToAddress(av_buffersink_params_alloc$2(), AVBufferSinkParams.class);
    }
    @Ptr
    @Name("av_buffersink_params_alloc")
    protected native long av_buffersink_params_alloc$2();
    /**
     * Create an AVABufferSinkParams structure.<br>
     * Must be freed with av_free().<br>
     * Original signature : <code>AVABufferSinkParams* av_abuffersink_params_alloc()</code><br>
     * <i>native declaration : ffmpeg_build/include/libavfilter/buffersink.h:43</i>
     */
    public Pointer<AVABufferSinkParams > av_abuffersink_params_alloc() {
        return (Pointer)Pointer.pointerToAddress(av_abuffersink_params_alloc$2(), AVABufferSinkParams.class);
    }
    @Ptr
    @Name("av_abuffersink_params_alloc")
    protected native long av_abuffersink_params_alloc$2();
    /**
     * Set the frame size for an audio buffer sink.<br>
     * All calls to av_buffersink_get_buffer_ref will return a buffer with<br>
     * exactly the specified number of samples, or AVERROR(EAGAIN) if there is<br>
     * not enough. The last buffer at EOF will be padded with 0.<br>
     * Original signature : <code>void av_buffersink_set_frame_size(AVFilterContext*, unsigned)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavfilter/buffersink.h:51</i>
     */
    public void av_buffersink_set_frame_size(Pointer<AVFilterContext > ctx, int frame_size) {
        av_buffersink_set_frame_size(Pointer.getPeer(ctx), frame_size);
    }
    protected native void av_buffersink_set_frame_size(@Ptr long ctx, int frame_size);
    /**
     * Get the frame rate of the input.<br>
     * Original signature : <code>AVRational av_buffersink_get_frame_rate(AVFilterContext*)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavfilter/buffersink.h:56</i>
     */
    public AVRational av_buffersink_get_frame_rate(Pointer<AVFilterContext > ctx) {
        return av_buffersink_get_frame_rate(Pointer.getPeer(ctx));
    }
    protected native AVRational av_buffersink_get_frame_rate(@Ptr long ctx);
    /**
     * Get a frame with filtered data from sink and put it in frame.<br>
     * @param ctx pointer to a context of a buffersink or abuffersink AVFilter.<br>
     * @param frame pointer to an allocated frame that will be filled with data.<br>
     *              The data must be freed using av_frame_unref() / av_frame_free()<br>
     * @return<br>
     *         - >= 0 if a frame was successfully returned.<br>
     *         - AVERROR(EAGAIN) if no frames are available at this point; more<br>
     *           input frames must be added to the filtergraph to get more output.<br>
     *         - AVERROR_EOF if there will be no more output frames on this sink.<br>
     *         - A different negative AVERROR code in other failure cases.<br>
     * Original signature : <code>int av_buffersink_get_frame(AVFilterContext*, AVFrame*)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavfilter/buffersink.h:70</i>
     */
    public int av_buffersink_get_frame(Pointer<AVFilterContext > ctx, Pointer<AVFrame > frame) {
        return av_buffersink_get_frame(Pointer.getPeer(ctx), Pointer.getPeer(frame));
    }
    protected native int av_buffersink_get_frame(@Ptr long ctx, @Ptr long frame);
    /**
     * Same as av_buffersink_get_frame(), but with the ability to specify the number<br>
     * of samples read. This function is less efficient than<br>
     * av_buffersink_get_frame(), because it copies the data around.<br>
     * @param ctx pointer to a context of the abuffersink AVFilter.<br>
     * @param frame pointer to an allocated frame that will be filled with data.<br>
     *              The data must be freed using av_frame_unref() / av_frame_free()<br>
     *              frame will contain exactly nb_samples audio samples, except at<br>
     *              the end of stream, when it can contain less than nb_samples.<br>
     * @return The return codes have the same meaning as for<br>
     *         av_buffersink_get_samples().<br>
     * @warning do not mix this function with av_buffersink_get_frame(). Use only one or<br>
     * the other with a single sink, not both.<br>
     * Original signature : <code>int av_buffersink_get_samples(AVFilterContext*, AVFrame*, int)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavfilter/buffersink.h:86</i>
     */
    public int av_buffersink_get_samples(Pointer<AVFilterContext > ctx, Pointer<AVFrame > frame, int nb_samples) {
        return av_buffersink_get_samples(Pointer.getPeer(ctx), Pointer.getPeer(frame), nb_samples);
    }
    protected native int av_buffersink_get_samples(@Ptr long ctx, @Ptr long frame, int nb_samples);
    /** Undefined type */
    public static interface AVFilterPad {

    };
    /** Undefined type */
    public static interface AVFilterCommand {

    };
    /** Undefined type */
    public static interface AVFilterGraphInternal {

    };
    /** Undefined type */
    public static interface AVFilterFormats {

    };
    /** Undefined type */
    public static interface AVFilterChannelLayouts {

    };
    /** Undefined type */
    public static interface AVFilterInternal {

    };
}
