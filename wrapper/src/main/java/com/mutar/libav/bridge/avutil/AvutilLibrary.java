package com.mutar.libav.bridge.avutil;
import java.util.Collections;
import java.util.Iterator;

import org.bridj.BridJ;
import org.bridj.CRuntime;
import org.bridj.Callback;
import org.bridj.FlagSet;
import org.bridj.IntValuedEnum;
import org.bridj.Pointer;
import org.bridj.SizeT;
import org.bridj.ann.CLong;
import org.bridj.ann.Library;
import org.bridj.ann.Name;
import org.bridj.ann.Ptr;
import org.bridj.ann.Runtime;
import org.bridj.util.DefaultParameterizedType;

import com.mutar.libav.bridge.avdevice.AvdeviceLibrary.AVDictionary;
/**
 * Wrapper for library <b>avutil</b><br>
 * This file was autogenerated by <a href="http://jnaerator.googlecode.com/">JNAerator</a>,<br>
 * a tool written by <a href="http://ochafik.com/">Olivier Chafik</a> that <a href="http://code.google.com/p/jnaerator/wiki/CreditsAndLicense">uses a few opensource projects.</a>.<br>
 * For help, please visit <a href="http://nativelibs4java.googlecode.com/">NativeLibs4Java</a> or <a href="http://bridj.googlecode.com/">BridJ</a> .
 */
@Library("avutil")
@Runtime(CRuntime.class)
public class AvutilLibrary {
    static {
        BridJ.register();
    }
    /**
     * @addtogroup lavu_media Media Type<br>
     * @brief Media Type<br>
     * enum values<br>
     * <i>native declaration : ffmpeg_build/include/libavutil/avutil.h:37</i>
     */
    public enum AVMediaType implements IntValuedEnum<AVMediaType > {
        /** < Usually treated as AVMEDIA_TYPE_DATA */
        AVMEDIA_TYPE_UNKNOWN(-1),
        AVMEDIA_TYPE_VIDEO(0),
        AVMEDIA_TYPE_AUDIO(1),
        /** < Opaque data information usually continuous */
        AVMEDIA_TYPE_DATA(2),
        AVMEDIA_TYPE_SUBTITLE(3),
        /** < Opaque data information usually sparse */
        AVMEDIA_TYPE_ATTACHMENT(4),
        AVMEDIA_TYPE_NB(5);
        AVMediaType(long value) {
            this.value = value;
        }
        public final long value;
        public long value() {
            return this.value;
        }
        public Iterator<AVMediaType > iterator() {
            return Collections.singleton(this).iterator();
        }
        public static IntValuedEnum<AVMediaType > fromValue(int value) {
            return FlagSet.fromValue(value, values());
        }
    };
    /**
     * @}<br>
     * @}<br>
     * @defgroup lavu_picture Image related<br>
     * AVPicture types, pixel formats and basic image planes manipulation.<br>
     * @{<br>
     * enum values<br>
     * <i>native declaration : ffmpeg_build/include/libavutil/avutil.h:68</i>
     */
    public enum AVPictureType implements IntValuedEnum<AVPictureType > {
        /** < Undefined */
        AV_PICTURE_TYPE_NONE(0),
        /** < Intra */
        AV_PICTURE_TYPE_I(1),
        /** < Predicted */
        AV_PICTURE_TYPE_P(2),
        /** < Bi-dir predicted */
        AV_PICTURE_TYPE_B(3),
        /** < S(GMC)-VOP MPEG4 */
        AV_PICTURE_TYPE_S(4),
        /** < Switching Intra */
        AV_PICTURE_TYPE_SI(5),
        /** < Switching Predicted */
        AV_PICTURE_TYPE_SP(6),
        /** < BI type */
        AV_PICTURE_TYPE_BI(7);
        AVPictureType(long value) {
            this.value = value;
        }
        public final long value;
        public long value() {
            return this.value;
        }
        public Iterator<AVPictureType > iterator() {
            return Collections.singleton(this).iterator();
        }
        public static IntValuedEnum<AVPictureType > fromValue(int value) {
            return FlagSet.fromValue(value, values());
        }
    };
    /**
     * @addtogroup lavu_math<br>
     * @{<br>
     * enum values<br>
     * <i>native declaration : ffmpeg_build/include/libavutil/mathematics.h:17</i>
     */
    public enum AVRounding implements IntValuedEnum<AVRounding > {
        /** < Round toward zero. */
        AV_ROUND_ZERO(0),
        /** < Round away from zero. */
        AV_ROUND_INF(1),
        /** < Round toward -infinity. */
        AV_ROUND_DOWN(2),
        /** < Round toward +infinity. */
        AV_ROUND_UP(3),
        /** < Round to nearest and halfway cases away from zero. */
        AV_ROUND_NEAR_INF(5),
        /** < Flag to pass INT64_MIN/MAX through instead of rescaling, this avoids special cases for AV_NOPTS_VALUE */
        AV_ROUND_PASS_MINMAX(8192);
        AVRounding(long value) {
            this.value = value;
        }
        public final long value;
        public long value() {
            return this.value;
        }
        public Iterator<AVRounding > iterator() {
            return Collections.singleton(this).iterator();
        }
        public static IntValuedEnum<AVRounding > fromValue(int value) {
            return FlagSet.fromValue(value, values());
        }
    };
    /**
     * enum values<br>
     * <i>native declaration : ffmpeg_build/include/libavutil/log.h:19</i>
     */
    public enum AVClassCategory implements IntValuedEnum<AVClassCategory > {
        AV_CLASS_CATEGORY_NA(0),
        AV_CLASS_CATEGORY_INPUT(1),
        AV_CLASS_CATEGORY_OUTPUT(2),
        AV_CLASS_CATEGORY_MUXER(3),
        AV_CLASS_CATEGORY_DEMUXER(4),
        AV_CLASS_CATEGORY_ENCODER(5),
        AV_CLASS_CATEGORY_DECODER(6),
        AV_CLASS_CATEGORY_FILTER(7),
        AV_CLASS_CATEGORY_BITSTREAM_FILTER(8),
        AV_CLASS_CATEGORY_SWSCALER(9),
        AV_CLASS_CATEGORY_SWRESAMPLER(10),
        AV_CLASS_CATEGORY_DEVICE_VIDEO_OUTPUT(40),
        AV_CLASS_CATEGORY_DEVICE_VIDEO_INPUT(41),
        AV_CLASS_CATEGORY_DEVICE_AUDIO_OUTPUT(42),
        AV_CLASS_CATEGORY_DEVICE_AUDIO_INPUT(43),
        AV_CLASS_CATEGORY_DEVICE_OUTPUT(44),
        AV_CLASS_CATEGORY_DEVICE_INPUT(45),
        AV_CLASS_CATEGORY_NB(46);
        AVClassCategory(long value) {
            this.value = value;
        }
        public final long value;
        public long value() {
            return this.value;
        }
        public Iterator<AVClassCategory > iterator() {
            return Collections.singleton(this).iterator();
        }
        public static IntValuedEnum<AVClassCategory > fromValue(int value) {
            return FlagSet.fromValue(value, values());
        }
    };
    /**
     * Pixel format.<br>
     * @note<br>
     * AV_PIX_FMT_RGB32 is handled in an endian-specific manner. An RGBA<br>
     * color is put together as:<br>
     *  (A << 24) | (R << 16) | (G << 8) | B<br>
     * This is stored as BGRA on little-endian CPU architectures and ARGB on<br>
     * big-endian CPUs.<br>
     * @par<br>
     * When the pixel format is palettized RGB32 (AV_PIX_FMT_PAL8), the palettized<br>
     * image data is stored in AVFrame.data[0]. The palette is transported in<br>
     * AVFrame.data[1], is 1024 bytes long (256 4-byte entries) and is<br>
     * formatted the same as in AV_PIX_FMT_RGB32 described above (i.e., it is<br>
     * also endian-specific). Note also that the individual RGB32 palette<br>
     * components stored in AVFrame.data[1] should be in the range 0..255.<br>
     * This is important as many custom PAL8 video codecs that were designed<br>
     * to run on the IBM VGA graphics adapter use 6-bit palette components.<br>
     * @par<br>
     * For all the 8bit per pixel formats, an RGB32 palette is in data[1] like<br>
     * for pal8. This palette is filled in automatically by the function<br>
     * allocating the picture.<br>
     * enum values<br>
     * <i>native declaration : ffmpeg_build/include/libavutil/pixfmt.h:366</i>
     */
    public enum AVPixelFormat implements IntValuedEnum<AVPixelFormat > {
        AV_PIX_FMT_NONE(-1),
        /** < planar YUV 4:2:0, 12bpp, (1 Cr & Cb sample per 2x2 Y samples) */
        AV_PIX_FMT_YUV420P(0),
        /** < packed YUV 4:2:2, 16bpp, Y0 Cb Y1 Cr */
        AV_PIX_FMT_YUYV422(1),
        /** < packed RGB 8:8:8, 24bpp, RGBRGB... */
        AV_PIX_FMT_RGB24(2),
        /** < packed RGB 8:8:8, 24bpp, BGRBGR... */
        AV_PIX_FMT_BGR24(3),
        /** < planar YUV 4:2:2, 16bpp, (1 Cr & Cb sample per 2x1 Y samples) */
        AV_PIX_FMT_YUV422P(4),
        /** < planar YUV 4:4:4, 24bpp, (1 Cr & Cb sample per 1x1 Y samples) */
        AV_PIX_FMT_YUV444P(5),
        /** < planar YUV 4:1:0,  9bpp, (1 Cr & Cb sample per 4x4 Y samples) */
        AV_PIX_FMT_YUV410P(6),
        /** < planar YUV 4:1:1, 12bpp, (1 Cr & Cb sample per 4x1 Y samples) */
        AV_PIX_FMT_YUV411P(7),
        /** <        Y        ,  8bpp */
        AV_PIX_FMT_GRAY8(8),
        /** <        Y        ,  1bpp, 0 is white, 1 is black, in each byte pixels are ordered from the msb to the lsb */
        AV_PIX_FMT_MONOWHITE(9),
        /** <        Y        ,  1bpp, 0 is black, 1 is white, in each byte pixels are ordered from the msb to the lsb */
        AV_PIX_FMT_MONOBLACK(10),
        /** < 8 bit with AV_PIX_FMT_RGB32 palette */
        AV_PIX_FMT_PAL8(11),
        /** < planar YUV 4:2:0, 12bpp, full scale (JPEG), deprecated in favor of AV_PIX_FMT_YUV420P and setting color_range */
        AV_PIX_FMT_YUVJ420P(12),
        /** < planar YUV 4:2:2, 16bpp, full scale (JPEG), deprecated in favor of AV_PIX_FMT_YUV422P and setting color_range */
        AV_PIX_FMT_YUVJ422P(13),
        /** < planar YUV 4:4:4, 24bpp, full scale (JPEG), deprecated in favor of AV_PIX_FMT_YUV444P and setting color_range */
        AV_PIX_FMT_YUVJ444P(14),
        /** < XVideo Motion Acceleration via common packet passing */
        AV_PIX_FMT_XVMC_MPEG2_MC(15),
        AV_PIX_FMT_XVMC_MPEG2_IDCT(16),
        /** < packed YUV 4:2:2, 16bpp, Cb Y0 Cr Y1 */
        AV_PIX_FMT_UYVY422(17),
        /** < packed YUV 4:1:1, 12bpp, Cb Y0 Y1 Cr Y2 Y3 */
        AV_PIX_FMT_UYYVYY411(18),
        /** < packed RGB 3:3:2,  8bpp, (msb)2B 3G 3R(lsb) */
        AV_PIX_FMT_BGR8(19),
        /** < packed RGB 1:2:1 bitstream,  4bpp, (msb)1B 2G 1R(lsb), a byte contains two pixels, the first pixel in the byte is the one composed by the 4 msb bits */
        AV_PIX_FMT_BGR4(20),
        /** < packed RGB 1:2:1,  8bpp, (msb)1B 2G 1R(lsb) */
        AV_PIX_FMT_BGR4_BYTE(21),
        /** < packed RGB 3:3:2,  8bpp, (msb)2R 3G 3B(lsb) */
        AV_PIX_FMT_RGB8(22),
        /** < packed RGB 1:2:1 bitstream,  4bpp, (msb)1R 2G 1B(lsb), a byte contains two pixels, the first pixel in the byte is the one composed by the 4 msb bits */
        AV_PIX_FMT_RGB4(23),
        /** < packed RGB 1:2:1,  8bpp, (msb)1R 2G 1B(lsb) */
        AV_PIX_FMT_RGB4_BYTE(24),
        /** < planar YUV 4:2:0, 12bpp, 1 plane for Y and 1 plane for the UV components, which are interleaved (first byte U and the following byte V) */
        AV_PIX_FMT_NV12(25),
        /** < as above, but U and V bytes are swapped */
        AV_PIX_FMT_NV21(26),
        /** < packed ARGB 8:8:8:8, 32bpp, ARGBARGB... */
        AV_PIX_FMT_ARGB(27),
        /** < packed RGBA 8:8:8:8, 32bpp, RGBARGBA... */
        AV_PIX_FMT_RGBA(28),
        /** < packed ABGR 8:8:8:8, 32bpp, ABGRABGR... */
        AV_PIX_FMT_ABGR(29),
        /** < packed BGRA 8:8:8:8, 32bpp, BGRABGRA... */
        AV_PIX_FMT_BGRA(30),
        /** <        Y        , 16bpp, big-endian */
        AV_PIX_FMT_GRAY16BE(31),
        /** <        Y        , 16bpp, little-endian */
        AV_PIX_FMT_GRAY16LE(32),
        /** < planar YUV 4:4:0 (1 Cr & Cb sample per 1x2 Y samples) */
        AV_PIX_FMT_YUV440P(33),
        /** < planar YUV 4:4:0 full scale (JPEG), deprecated in favor of AV_PIX_FMT_YUV440P and setting color_range */
        AV_PIX_FMT_YUVJ440P(34),
        /** < planar YUV 4:2:0, 20bpp, (1 Cr & Cb sample per 2x2 Y & A samples) */
        AV_PIX_FMT_YUVA420P(35),
        /** < H.264 HW decoding with VDPAU, data[0] contains a vdpau_render_state struct which contains the bitstream of the slices as well as various fields extracted from headers */
        AV_PIX_FMT_VDPAU_H264(36),
        /** < MPEG-1 HW decoding with VDPAU, data[0] contains a vdpau_render_state struct which contains the bitstream of the slices as well as various fields extracted from headers */
        AV_PIX_FMT_VDPAU_MPEG1(37),
        /** < MPEG-2 HW decoding with VDPAU, data[0] contains a vdpau_render_state struct which contains the bitstream of the slices as well as various fields extracted from headers */
        AV_PIX_FMT_VDPAU_MPEG2(38),
        /** < WMV3 HW decoding with VDPAU, data[0] contains a vdpau_render_state struct which contains the bitstream of the slices as well as various fields extracted from headers */
        AV_PIX_FMT_VDPAU_WMV3(39),
        /** < VC-1 HW decoding with VDPAU, data[0] contains a vdpau_render_state struct which contains the bitstream of the slices as well as various fields extracted from headers */
        AV_PIX_FMT_VDPAU_VC1(40),
        /** < packed RGB 16:16:16, 48bpp, 16R, 16G, 16B, the 2-byte value for each R/G/B component is stored as big-endian */
        AV_PIX_FMT_RGB48BE(41),
        /** < packed RGB 16:16:16, 48bpp, 16R, 16G, 16B, the 2-byte value for each R/G/B component is stored as little-endian */
        AV_PIX_FMT_RGB48LE(42),
        /** < packed RGB 5:6:5, 16bpp, (msb)   5R 6G 5B(lsb), big-endian */
        AV_PIX_FMT_RGB565BE(43),
        /** < packed RGB 5:6:5, 16bpp, (msb)   5R 6G 5B(lsb), little-endian */
        AV_PIX_FMT_RGB565LE(44),
        /** < packed RGB 5:5:5, 16bpp, (msb)1X 5R 5G 5B(lsb), big-endian   , X=unused/undefined */
        AV_PIX_FMT_RGB555BE(45),
        /** < packed RGB 5:5:5, 16bpp, (msb)1X 5R 5G 5B(lsb), little-endian, X=unused/undefined */
        AV_PIX_FMT_RGB555LE(46),
        /** < packed BGR 5:6:5, 16bpp, (msb)   5B 6G 5R(lsb), big-endian */
        AV_PIX_FMT_BGR565BE(47),
        /** < packed BGR 5:6:5, 16bpp, (msb)   5B 6G 5R(lsb), little-endian */
        AV_PIX_FMT_BGR565LE(48),
        /** < packed BGR 5:5:5, 16bpp, (msb)1X 5B 5G 5R(lsb), big-endian   , X=unused/undefined */
        AV_PIX_FMT_BGR555BE(49),
        /** < packed BGR 5:5:5, 16bpp, (msb)1X 5B 5G 5R(lsb), little-endian, X=unused/undefined */
        AV_PIX_FMT_BGR555LE(50),
        /** < HW acceleration through VA API at motion compensation entry-point, Picture.data[3] contains a vaapi_render_state struct which contains macroblocks as well as various fields extracted from headers */
        AV_PIX_FMT_VAAPI_MOCO(51),
        /** < HW acceleration through VA API at IDCT entry-point, Picture.data[3] contains a vaapi_render_state struct which contains fields extracted from headers */
        AV_PIX_FMT_VAAPI_IDCT(52),
        /** < HW decoding through VA API, Picture.data[3] contains a vaapi_render_state struct which contains the bitstream of the slices as well as various fields extracted from headers */
        AV_PIX_FMT_VAAPI_VLD(53),
        AV_PIX_FMT_VAAPI(53),
        /** < planar YUV 4:2:0, 24bpp, (1 Cr & Cb sample per 2x2 Y samples), little-endian */
        AV_PIX_FMT_YUV420P16LE((53 + 1)),
        /** < planar YUV 4:2:0, 24bpp, (1 Cr & Cb sample per 2x2 Y samples), big-endian */
        AV_PIX_FMT_YUV420P16BE((53 + 2)),
        /** < planar YUV 4:2:2, 32bpp, (1 Cr & Cb sample per 2x1 Y samples), little-endian */
        AV_PIX_FMT_YUV422P16LE((53 + 3)),
        /** < planar YUV 4:2:2, 32bpp, (1 Cr & Cb sample per 2x1 Y samples), big-endian */
        AV_PIX_FMT_YUV422P16BE((53 + 4)),
        /** < planar YUV 4:4:4, 48bpp, (1 Cr & Cb sample per 1x1 Y samples), little-endian */
        AV_PIX_FMT_YUV444P16LE((53 + 5)),
        /** < planar YUV 4:4:4, 48bpp, (1 Cr & Cb sample per 1x1 Y samples), big-endian */
        AV_PIX_FMT_YUV444P16BE((53 + 6)),
        /** < MPEG4 HW decoding with VDPAU, data[0] contains a vdpau_render_state struct which contains the bitstream of the slices as well as various fields extracted from headers */
        AV_PIX_FMT_VDPAU_MPEG4((53 + 7)),
        /** < HW decoding through DXVA2, Picture.data[3] contains a LPDIRECT3DSURFACE9 pointer */
        AV_PIX_FMT_DXVA2_VLD((53 + 8)),
        /** < packed RGB 4:4:4, 16bpp, (msb)4X 4R 4G 4B(lsb), little-endian, X=unused/undefined */
        AV_PIX_FMT_RGB444LE((53 + 9)),
        /** < packed RGB 4:4:4, 16bpp, (msb)4X 4R 4G 4B(lsb), big-endian,    X=unused/undefined */
        AV_PIX_FMT_RGB444BE((53 + 10)),
        /** < packed BGR 4:4:4, 16bpp, (msb)4X 4B 4G 4R(lsb), little-endian, X=unused/undefined */
        AV_PIX_FMT_BGR444LE((53 + 11)),
        /** < packed BGR 4:4:4, 16bpp, (msb)4X 4B 4G 4R(lsb), big-endian,    X=unused/undefined */
        AV_PIX_FMT_BGR444BE((53 + 12)),
        /** < 8bit gray, 8bit alpha */
        AV_PIX_FMT_YA8((53 + 13)),
        /** < alias for AV_PIX_FMT_YA8 */
        AV_PIX_FMT_Y400A(53 + 13),
        /** < alias for AV_PIX_FMT_YA8 */
        AV_PIX_FMT_GRAY8A(53 + 13),
        /** < packed RGB 16:16:16, 48bpp, 16B, 16G, 16R, the 2-byte value for each R/G/B component is stored as big-endian */
        AV_PIX_FMT_BGR48BE((53 + 13 + 1)),
        /** < packed RGB 16:16:16, 48bpp, 16B, 16G, 16R, the 2-byte value for each R/G/B component is stored as little-endian */
        AV_PIX_FMT_BGR48LE((53 + 13 + 2)),
        /** < planar YUV 4:2:0, 13.5bpp, (1 Cr & Cb sample per 2x2 Y samples), big-endian */
        AV_PIX_FMT_YUV420P9BE((53 + 13 + 3)),
        /** < planar YUV 4:2:0, 13.5bpp, (1 Cr & Cb sample per 2x2 Y samples), little-endian */
        AV_PIX_FMT_YUV420P9LE((53 + 13 + 4)),
        /** < planar YUV 4:2:0, 15bpp, (1 Cr & Cb sample per 2x2 Y samples), big-endian */
        AV_PIX_FMT_YUV420P10BE((53 + 13 + 5)),
        /** < planar YUV 4:2:0, 15bpp, (1 Cr & Cb sample per 2x2 Y samples), little-endian */
        AV_PIX_FMT_YUV420P10LE((53 + 13 + 6)),
        /** < planar YUV 4:2:2, 20bpp, (1 Cr & Cb sample per 2x1 Y samples), big-endian */
        AV_PIX_FMT_YUV422P10BE((53 + 13 + 7)),
        /** < planar YUV 4:2:2, 20bpp, (1 Cr & Cb sample per 2x1 Y samples), little-endian */
        AV_PIX_FMT_YUV422P10LE((53 + 13 + 8)),
        /** < planar YUV 4:4:4, 27bpp, (1 Cr & Cb sample per 1x1 Y samples), big-endian */
        AV_PIX_FMT_YUV444P9BE((53 + 13 + 9)),
        /** < planar YUV 4:4:4, 27bpp, (1 Cr & Cb sample per 1x1 Y samples), little-endian */
        AV_PIX_FMT_YUV444P9LE((53 + 13 + 10)),
        /** < planar YUV 4:4:4, 30bpp, (1 Cr & Cb sample per 1x1 Y samples), big-endian */
        AV_PIX_FMT_YUV444P10BE((53 + 13 + 11)),
        /** < planar YUV 4:4:4, 30bpp, (1 Cr & Cb sample per 1x1 Y samples), little-endian */
        AV_PIX_FMT_YUV444P10LE((53 + 13 + 12)),
        /** < planar YUV 4:2:2, 18bpp, (1 Cr & Cb sample per 2x1 Y samples), big-endian */
        AV_PIX_FMT_YUV422P9BE((53 + 13 + 13)),
        /** < planar YUV 4:2:2, 18bpp, (1 Cr & Cb sample per 2x1 Y samples), little-endian */
        AV_PIX_FMT_YUV422P9LE((53 + 13 + 14)),
        /** < hardware decoding through VDA */
        AV_PIX_FMT_VDA_VLD((53 + 13 + 15)),
        /** < planar GBR 4:4:4 24bpp */
        AV_PIX_FMT_GBRP((53 + 13 + 16)),
        /** < planar GBR 4:4:4 27bpp, big-endian */
        AV_PIX_FMT_GBRP9BE((53 + 13 + 17)),
        /** < planar GBR 4:4:4 27bpp, little-endian */
        AV_PIX_FMT_GBRP9LE((53 + 13 + 18)),
        /** < planar GBR 4:4:4 30bpp, big-endian */
        AV_PIX_FMT_GBRP10BE((53 + 13 + 19)),
        /** < planar GBR 4:4:4 30bpp, little-endian */
        AV_PIX_FMT_GBRP10LE((53 + 13 + 20)),
        /** < planar GBR 4:4:4 48bpp, big-endian */
        AV_PIX_FMT_GBRP16BE((53 + 13 + 21)),
        /** < planar GBR 4:4:4 48bpp, little-endian */
        AV_PIX_FMT_GBRP16LE((53 + 13 + 22)),
        /** < planar YUV 4:2:2 24bpp, (1 Cr & Cb sample per 2x1 Y & A samples) */
        AV_PIX_FMT_YUVA422P((53 + 13 + 23)),
        /** < planar YUV 4:4:4 32bpp, (1 Cr & Cb sample per 1x1 Y & A samples) */
        AV_PIX_FMT_YUVA444P((53 + 13 + 24)),
        /** < planar YUV 4:2:0 22.5bpp, (1 Cr & Cb sample per 2x2 Y & A samples), big-endian */
        AV_PIX_FMT_YUVA420P9BE((53 + 13 + 25)),
        /** < planar YUV 4:2:0 22.5bpp, (1 Cr & Cb sample per 2x2 Y & A samples), little-endian */
        AV_PIX_FMT_YUVA420P9LE((53 + 13 + 26)),
        /** < planar YUV 4:2:2 27bpp, (1 Cr & Cb sample per 2x1 Y & A samples), big-endian */
        AV_PIX_FMT_YUVA422P9BE((53 + 13 + 27)),
        /** < planar YUV 4:2:2 27bpp, (1 Cr & Cb sample per 2x1 Y & A samples), little-endian */
        AV_PIX_FMT_YUVA422P9LE((53 + 13 + 28)),
        /** < planar YUV 4:4:4 36bpp, (1 Cr & Cb sample per 1x1 Y & A samples), big-endian */
        AV_PIX_FMT_YUVA444P9BE((53 + 13 + 29)),
        /** < planar YUV 4:4:4 36bpp, (1 Cr & Cb sample per 1x1 Y & A samples), little-endian */
        AV_PIX_FMT_YUVA444P9LE((53 + 13 + 30)),
        /** < planar YUV 4:2:0 25bpp, (1 Cr & Cb sample per 2x2 Y & A samples, big-endian) */
        AV_PIX_FMT_YUVA420P10BE((53 + 13 + 31)),
        /** < planar YUV 4:2:0 25bpp, (1 Cr & Cb sample per 2x2 Y & A samples, little-endian) */
        AV_PIX_FMT_YUVA420P10LE((53 + 13 + 32)),
        /** < planar YUV 4:2:2 30bpp, (1 Cr & Cb sample per 2x1 Y & A samples, big-endian) */
        AV_PIX_FMT_YUVA422P10BE((53 + 13 + 33)),
        /** < planar YUV 4:2:2 30bpp, (1 Cr & Cb sample per 2x1 Y & A samples, little-endian) */
        AV_PIX_FMT_YUVA422P10LE((53 + 13 + 34)),
        /** < planar YUV 4:4:4 40bpp, (1 Cr & Cb sample per 1x1 Y & A samples, big-endian) */
        AV_PIX_FMT_YUVA444P10BE((53 + 13 + 35)),
        /** < planar YUV 4:4:4 40bpp, (1 Cr & Cb sample per 1x1 Y & A samples, little-endian) */
        AV_PIX_FMT_YUVA444P10LE((53 + 13 + 36)),
        /** < planar YUV 4:2:0 40bpp, (1 Cr & Cb sample per 2x2 Y & A samples, big-endian) */
        AV_PIX_FMT_YUVA420P16BE((53 + 13 + 37)),
        /** < planar YUV 4:2:0 40bpp, (1 Cr & Cb sample per 2x2 Y & A samples, little-endian) */
        AV_PIX_FMT_YUVA420P16LE((53 + 13 + 38)),
        /** < planar YUV 4:2:2 48bpp, (1 Cr & Cb sample per 2x1 Y & A samples, big-endian) */
        AV_PIX_FMT_YUVA422P16BE((53 + 13 + 39)),
        /** < planar YUV 4:2:2 48bpp, (1 Cr & Cb sample per 2x1 Y & A samples, little-endian) */
        AV_PIX_FMT_YUVA422P16LE((53 + 13 + 40)),
        /** < planar YUV 4:4:4 64bpp, (1 Cr & Cb sample per 1x1 Y & A samples, big-endian) */
        AV_PIX_FMT_YUVA444P16BE((53 + 13 + 41)),
        /** < planar YUV 4:4:4 64bpp, (1 Cr & Cb sample per 1x1 Y & A samples, little-endian) */
        AV_PIX_FMT_YUVA444P16LE((53 + 13 + 42)),
        /** < HW acceleration through VDPAU, Picture.data[3] contains a VdpVideoSurface */
        AV_PIX_FMT_VDPAU((53 + 13 + 43)),
        /** < packed XYZ 4:4:4, 36 bpp, (msb) 12X, 12Y, 12Z (lsb), the 2-byte value for each X/Y/Z is stored as little-endian, the 4 lower bits are set to 0 */
        AV_PIX_FMT_XYZ12LE((53 + 13 + 44)),
        /** < packed XYZ 4:4:4, 36 bpp, (msb) 12X, 12Y, 12Z (lsb), the 2-byte value for each X/Y/Z is stored as big-endian, the 4 lower bits are set to 0 */
        AV_PIX_FMT_XYZ12BE((53 + 13 + 45)),
        /** < interleaved chroma YUV 4:2:2, 16bpp, (1 Cr & Cb sample per 2x1 Y samples) */
        AV_PIX_FMT_NV16((53 + 13 + 46)),
        /** < interleaved chroma YUV 4:2:2, 20bpp, (1 Cr & Cb sample per 2x1 Y samples), little-endian */
        AV_PIX_FMT_NV20LE((53 + 13 + 47)),
        /** < interleaved chroma YUV 4:2:2, 20bpp, (1 Cr & Cb sample per 2x1 Y samples), big-endian */
        AV_PIX_FMT_NV20BE((53 + 13 + 48)),
        /** < packed RGBA 16:16:16:16, 64bpp, 16R, 16G, 16B, 16A, the 2-byte value for each R/G/B/A component is stored as big-endian */
        AV_PIX_FMT_RGBA64BE((53 + 13 + 49)),
        /** < packed RGBA 16:16:16:16, 64bpp, 16R, 16G, 16B, 16A, the 2-byte value for each R/G/B/A component is stored as little-endian */
        AV_PIX_FMT_RGBA64LE((53 + 13 + 50)),
        /** < packed RGBA 16:16:16:16, 64bpp, 16B, 16G, 16R, 16A, the 2-byte value for each R/G/B/A component is stored as big-endian */
        AV_PIX_FMT_BGRA64BE((53 + 13 + 51)),
        /** < packed RGBA 16:16:16:16, 64bpp, 16B, 16G, 16R, 16A, the 2-byte value for each R/G/B/A component is stored as little-endian */
        AV_PIX_FMT_BGRA64LE((53 + 13 + 52)),
        /** < packed YUV 4:2:2, 16bpp, Y0 Cr Y1 Cb */
        AV_PIX_FMT_YVYU422((53 + 13 + 53)),
        /** < HW acceleration through VDA, data[3] contains a CVPixelBufferRef */
        AV_PIX_FMT_VDA((53 + 13 + 54)),
        /** < 16bit gray, 16bit alpha (big-endian) */
        AV_PIX_FMT_YA16BE((53 + 13 + 55)),
        /** < 16bit gray, 16bit alpha (little-endian) */
        AV_PIX_FMT_YA16LE((53 + 13 + 56)),
        /** < planar GBRA 4:4:4:4 32bpp */
        AV_PIX_FMT_GBRAP((53 + 13 + 57)),
        /** < planar GBRA 4:4:4:4 64bpp, big-endian */
        AV_PIX_FMT_GBRAP16BE((53 + 13 + 58)),
        /** < planar GBRA 4:4:4:4 64bpp, little-endian */
        AV_PIX_FMT_GBRAP16LE((53 + 13 + 59)),
        AV_PIX_FMT_QSV((53 + 13 + 60)),
        AV_PIX_FMT_MMAL((53 + 13 + 61)),
        /** < HW decoding through Direct3D11, Picture.data[3] contains a ID3D11VideoDecoderOutputView pointer */
        AV_PIX_FMT_D3D11VA_VLD((53 + 13 + 62)),
        /** < packed RGB 8:8:8, 32bpp, XRGBXRGB...   X=unused/undefined */
        AV_PIX_FMT_0RGB(0x123 + 4),
        /** < packed RGB 8:8:8, 32bpp, RGBXRGBX...   X=unused/undefined */
        AV_PIX_FMT_RGB0((0x123 + 4 + 1)),
        /** < packed BGR 8:8:8, 32bpp, XBGRXBGR...   X=unused/undefined */
        AV_PIX_FMT_0BGR((0x123 + 4 + 2)),
        /** < packed BGR 8:8:8, 32bpp, BGRXBGRX...   X=unused/undefined */
        AV_PIX_FMT_BGR0((0x123 + 4 + 3)),
        /** < planar YUV 4:2:0,18bpp, (1 Cr & Cb sample per 2x2 Y samples), big-endian */
        AV_PIX_FMT_YUV420P12BE((0x123 + 4 + 4)),
        /** < planar YUV 4:2:0,18bpp, (1 Cr & Cb sample per 2x2 Y samples), little-endian */
        AV_PIX_FMT_YUV420P12LE((0x123 + 4 + 5)),
        /** < planar YUV 4:2:0,21bpp, (1 Cr & Cb sample per 2x2 Y samples), big-endian */
        AV_PIX_FMT_YUV420P14BE((0x123 + 4 + 6)),
        /** < planar YUV 4:2:0,21bpp, (1 Cr & Cb sample per 2x2 Y samples), little-endian */
        AV_PIX_FMT_YUV420P14LE((0x123 + 4 + 7)),
        /** < planar YUV 4:2:2,24bpp, (1 Cr & Cb sample per 2x1 Y samples), big-endian */
        AV_PIX_FMT_YUV422P12BE((0x123 + 4 + 8)),
        /** < planar YUV 4:2:2,24bpp, (1 Cr & Cb sample per 2x1 Y samples), little-endian */
        AV_PIX_FMT_YUV422P12LE((0x123 + 4 + 9)),
        /** < planar YUV 4:2:2,28bpp, (1 Cr & Cb sample per 2x1 Y samples), big-endian */
        AV_PIX_FMT_YUV422P14BE((0x123 + 4 + 10)),
        /** < planar YUV 4:2:2,28bpp, (1 Cr & Cb sample per 2x1 Y samples), little-endian */
        AV_PIX_FMT_YUV422P14LE((0x123 + 4 + 11)),
        /** < planar YUV 4:4:4,36bpp, (1 Cr & Cb sample per 1x1 Y samples), big-endian */
        AV_PIX_FMT_YUV444P12BE((0x123 + 4 + 12)),
        /** < planar YUV 4:4:4,36bpp, (1 Cr & Cb sample per 1x1 Y samples), little-endian */
        AV_PIX_FMT_YUV444P12LE((0x123 + 4 + 13)),
        /** < planar YUV 4:4:4,42bpp, (1 Cr & Cb sample per 1x1 Y samples), big-endian */
        AV_PIX_FMT_YUV444P14BE((0x123 + 4 + 14)),
        /** < planar YUV 4:4:4,42bpp, (1 Cr & Cb sample per 1x1 Y samples), little-endian */
        AV_PIX_FMT_YUV444P14LE((0x123 + 4 + 15)),
        /** < planar GBR 4:4:4 36bpp, big-endian */
        AV_PIX_FMT_GBRP12BE((0x123 + 4 + 16)),
        /** < planar GBR 4:4:4 36bpp, little-endian */
        AV_PIX_FMT_GBRP12LE((0x123 + 4 + 17)),
        /** < planar GBR 4:4:4 42bpp, big-endian */
        AV_PIX_FMT_GBRP14BE((0x123 + 4 + 18)),
        /** < planar GBR 4:4:4 42bpp, little-endian */
        AV_PIX_FMT_GBRP14LE((0x123 + 4 + 19)),
        /** < planar YUV 4:1:1, 12bpp, (1 Cr & Cb sample per 4x1 Y samples) full scale (JPEG), deprecated in favor of AV_PIX_FMT_YUV411P and setting color_range */
        AV_PIX_FMT_YUVJ411P((0x123 + 4 + 20)),
        /** < bayer, BGBG..(odd line), GRGR..(even line), 8-bit samples * / */
        AV_PIX_FMT_BAYER_BGGR8((0x123 + 4 + 21)),
        /** < bayer, RGRG..(odd line), GBGB..(even line), 8-bit samples * / */
        AV_PIX_FMT_BAYER_RGGB8((0x123 + 4 + 22)),
        /** < bayer, GBGB..(odd line), RGRG..(even line), 8-bit samples * / */
        AV_PIX_FMT_BAYER_GBRG8((0x123 + 4 + 23)),
        /** < bayer, GRGR..(odd line), BGBG..(even line), 8-bit samples * / */
        AV_PIX_FMT_BAYER_GRBG8((0x123 + 4 + 24)),
        /** < bayer, BGBG..(odd line), GRGR..(even line), 16-bit samples, little-endian * / */
        AV_PIX_FMT_BAYER_BGGR16LE((0x123 + 4 + 25)),
        /** < bayer, BGBG..(odd line), GRGR..(even line), 16-bit samples, big-endian * / */
        AV_PIX_FMT_BAYER_BGGR16BE((0x123 + 4 + 26)),
        /** < bayer, RGRG..(odd line), GBGB..(even line), 16-bit samples, little-endian * / */
        AV_PIX_FMT_BAYER_RGGB16LE((0x123 + 4 + 27)),
        /** < bayer, RGRG..(odd line), GBGB..(even line), 16-bit samples, big-endian * / */
        AV_PIX_FMT_BAYER_RGGB16BE((0x123 + 4 + 28)),
        /** < bayer, GBGB..(odd line), RGRG..(even line), 16-bit samples, little-endian * / */
        AV_PIX_FMT_BAYER_GBRG16LE((0x123 + 4 + 29)),
        /** < bayer, GBGB..(odd line), RGRG..(even line), 16-bit samples, big-endian * / */
        AV_PIX_FMT_BAYER_GBRG16BE((0x123 + 4 + 30)),
        /** < bayer, GRGR..(odd line), BGBG..(even line), 16-bit samples, little-endian * / */
        AV_PIX_FMT_BAYER_GRBG16LE((0x123 + 4 + 31)),
        /** < bayer, GRGR..(odd line), BGBG..(even line), 16-bit samples, big-endian * / */
        AV_PIX_FMT_BAYER_GRBG16BE((0x123 + 4 + 32)),
        /** < planar YUV 4:4:0,20bpp, (1 Cr & Cb sample per 1x2 Y samples), little-endian */
        AV_PIX_FMT_YUV440P10LE((0x123 + 4 + 33)),
        /** < planar YUV 4:4:0,20bpp, (1 Cr & Cb sample per 1x2 Y samples), big-endian */
        AV_PIX_FMT_YUV440P10BE((0x123 + 4 + 34)),
        /** < planar YUV 4:4:0,24bpp, (1 Cr & Cb sample per 1x2 Y samples), little-endian */
        AV_PIX_FMT_YUV440P12LE((0x123 + 4 + 35)),
        /** < planar YUV 4:4:0,24bpp, (1 Cr & Cb sample per 1x2 Y samples), big-endian */
        AV_PIX_FMT_YUV440P12BE((0x123 + 4 + 36)),
        /** < packed AYUV 4:4:4,64bpp (1 Cr & Cb sample per 1x1 Y & A samples), little-endian */
        AV_PIX_FMT_AYUV64LE((0x123 + 4 + 37)),
        /** < packed AYUV 4:4:4,64bpp (1 Cr & Cb sample per 1x1 Y & A samples), big-endian */
        AV_PIX_FMT_AYUV64BE((0x123 + 4 + 38)),
        /** < hardware decoding through Videotoolbox */
        AV_PIX_FMT_VIDEOTOOLBOX((0x123 + 4 + 39)),
        /** < number of pixel formats, DO NOT USE THIS if you want to link with shared libav* because the number of formats might differ between versions */
        AV_PIX_FMT_NB((0x123 + 4 + 40));
        AVPixelFormat(long value) {
            this.value = value;
        }
        public final long value;
        public long value() {
            return this.value;
        }
        public Iterator<AVPixelFormat > iterator() {
            return Collections.singleton(this).iterator();
        }
        public static IntValuedEnum<AVPixelFormat > fromValue(int value) {
            return FlagSet.fromValue(value, values());
        }
    };
    /**
     * Chromaticity coordinates of the source primaries.<br>
     * enum values<br>
     * <i>native declaration : ffmpeg_build/include/libavutil/pixfmt.h:390</i>
     */
    public enum AVColorPrimaries implements IntValuedEnum<AVColorPrimaries > {
        AVCOL_PRI_RESERVED0(0),
        /** < also ITU-R BT1361 / IEC 61966-2-4 / SMPTE RP177 Annex B */
        AVCOL_PRI_BT709(1),
        AVCOL_PRI_UNSPECIFIED(2),
        AVCOL_PRI_RESERVED(3),
        /** < also FCC Title 47 Code of Federal Regulations 73.682 (a)(20) */
        AVCOL_PRI_BT470M(4),
        /** < also ITU-R BT601-6 625 / ITU-R BT1358 625 / ITU-R BT1700 625 PAL & SECAM */
        AVCOL_PRI_BT470BG(5),
        /** < also ITU-R BT601-6 525 / ITU-R BT1358 525 / ITU-R BT1700 NTSC */
        AVCOL_PRI_SMPTE170M(6),
        /** < functionally identical to above */
        AVCOL_PRI_SMPTE240M(7),
        /** < colour filters using Illuminant C */
        AVCOL_PRI_FILM(8),
        /** < ITU-R BT2020 */
        AVCOL_PRI_BT2020(9),
        /** < SMPTE ST 428-1 (CIE 1931 XYZ) */
        AVCOL_PRI_SMPTEST428_1(10),
        /** < Not part of ABI */
        AVCOL_PRI_NB(11);
        AVColorPrimaries(long value) {
            this.value = value;
        }
        public final long value;
        public long value() {
            return this.value;
        }
        public Iterator<AVColorPrimaries > iterator() {
            return Collections.singleton(this).iterator();
        }
        public static IntValuedEnum<AVColorPrimaries > fromValue(int value) {
            return FlagSet.fromValue(value, values());
        }
    };
    /**
     * Color Transfer Characteristic.<br>
     * enum values<br>
     * <i>native declaration : ffmpeg_build/include/libavutil/pixfmt.h:427</i>
     */
    public enum AVColorTransferCharacteristic implements IntValuedEnum<AVColorTransferCharacteristic > {
        AVCOL_TRC_RESERVED0(0),
        /** < also ITU-R BT1361 */
        AVCOL_TRC_BT709(1),
        AVCOL_TRC_UNSPECIFIED(2),
        AVCOL_TRC_RESERVED(3),
        /** < also ITU-R BT470M / ITU-R BT1700 625 PAL & SECAM */
        AVCOL_TRC_GAMMA22(4),
        /** < also ITU-R BT470BG */
        AVCOL_TRC_GAMMA28(5),
        /** < also ITU-R BT601-6 525 or 625 / ITU-R BT1358 525 or 625 / ITU-R BT1700 NTSC */
        AVCOL_TRC_SMPTE170M(6),
        AVCOL_TRC_SMPTE240M(7),
        /** < "Linear transfer characteristics" */
        AVCOL_TRC_LINEAR(8),
        /** < "Logarithmic transfer characteristic (100:1 range)" */
        AVCOL_TRC_LOG(9),
        /** < "Logarithmic transfer characteristic (100 * Sqrt(10) : 1 range)" */
        AVCOL_TRC_LOG_SQRT(10),
        /** < IEC 61966-2-4 */
        AVCOL_TRC_IEC61966_2_4(11),
        /** < ITU-R BT1361 Extended Colour Gamut */
        AVCOL_TRC_BT1361_ECG(12),
        /** < IEC 61966-2-1 (sRGB or sYCC) */
        AVCOL_TRC_IEC61966_2_1(13),
        /** < ITU-R BT2020 for 10 bit system */
        AVCOL_TRC_BT2020_10(14),
        /** < ITU-R BT2020 for 12 bit system */
        AVCOL_TRC_BT2020_12(15),
        /** < SMPTE ST 2084 for 10, 12, 14 and 16 bit systems */
        AVCOL_TRC_SMPTEST2084(16),
        /** < SMPTE ST 428-1 */
        AVCOL_TRC_SMPTEST428_1(17),
        /** < Not part of ABI */
        AVCOL_TRC_NB(18);
        AVColorTransferCharacteristic(long value) {
            this.value = value;
        }
        public final long value;
        public long value() {
            return this.value;
        }
        public Iterator<AVColorTransferCharacteristic > iterator() {
            return Collections.singleton(this).iterator();
        }
        public static IntValuedEnum<AVColorTransferCharacteristic > fromValue(int value) {
            return FlagSet.fromValue(value, values());
        }
    };
    /**
     * YUV colorspace type.<br>
     * enum values<br>
     * <i>native declaration : ffmpeg_build/include/libavutil/pixfmt.h:451</i>
     */
    public enum AVColorSpace implements IntValuedEnum<AVColorSpace > {
        /** < order of coefficients is actually GBR, also IEC 61966-2-1 (sRGB) */
        AVCOL_SPC_RGB(0),
        /** < also ITU-R BT1361 / IEC 61966-2-4 xvYCC709 / SMPTE RP177 Annex B */
        AVCOL_SPC_BT709(1),
        AVCOL_SPC_UNSPECIFIED(2),
        AVCOL_SPC_RESERVED(3),
        /** < FCC Title 47 Code of Federal Regulations 73.682 (a)(20) */
        AVCOL_SPC_FCC(4),
        /** < also ITU-R BT601-6 625 / ITU-R BT1358 625 / ITU-R BT1700 625 PAL & SECAM / IEC 61966-2-4 xvYCC601 */
        AVCOL_SPC_BT470BG(5),
        /** < also ITU-R BT601-6 525 / ITU-R BT1358 525 / ITU-R BT1700 NTSC / functionally identical to above */
        AVCOL_SPC_SMPTE170M(6),
        AVCOL_SPC_SMPTE240M(7),
        /** < Used by Dirac / VC-2 and H.264 FRext, see ITU-T SG16 */
        AVCOL_SPC_YCOCG(8),
        /** < ITU-R BT2020 non-constant luminance system */
        AVCOL_SPC_BT2020_NCL(9),
        /** < ITU-R BT2020 constant luminance system */
        AVCOL_SPC_BT2020_CL(10),
        /** < Not part of ABI */
        AVCOL_SPC_NB(11);
        AVColorSpace(long value) {
            this.value = value;
        }
        public final long value;
        public long value() {
            return this.value;
        }
        public Iterator<AVColorSpace > iterator() {
            return Collections.singleton(this).iterator();
        }
        public static IntValuedEnum<AVColorSpace > fromValue(int value) {
            return FlagSet.fromValue(value, values());
        }
    };
    /**
     * MPEG vs JPEG YUV range.<br>
     * enum values<br>
     * <i>native declaration : ffmpeg_build/include/libavutil/pixfmt.h:461</i>
     */
    public enum AVColorRange implements IntValuedEnum<AVColorRange > {
        AVCOL_RANGE_UNSPECIFIED(0),
        /** < the normal 219*2^(n-8) "MPEG" YUV ranges */
        AVCOL_RANGE_MPEG(1),
        /** < the normal     2^n-1   "JPEG" YUV ranges */
        AVCOL_RANGE_JPEG(2),
        /** < Not part of ABI */
        AVCOL_RANGE_NB(3);
        AVColorRange(long value) {
            this.value = value;
        }
        public final long value;
        public long value() {
            return this.value;
        }
        public Iterator<AVColorRange > iterator() {
            return Collections.singleton(this).iterator();
        }
        public static IntValuedEnum<AVColorRange > fromValue(int value) {
            return FlagSet.fromValue(value, values());
        }
    };
    /**
     * Location of chroma samples.<br>
     * Illustration showing the location of the first (top left) chroma sample of the<br>
     * image, the left shows only luma, the right<br>
     * shows the location of the chroma sample, the 2 could be imagined to overlay<br>
     * each other but are drawn separately due to limitations of ASCII<br>
     *                1st 2nd       1st 2nd horizontal luma sample positions<br>
     *                 v   v         v   v<br>
     *                 ______        ______<br>
     * 1st luma line > |X   X ...    |3 4 X ...     X are luma samples,<br>
     *                |             |1 2           1-6 are possible chroma positions<br>
     * 2nd luma line > |X   X ...    |5 6 X ...     0 is undefined/unknown position<br>
     * enum values<br>
     * <i>native declaration : ffmpeg_build/include/libavutil/pixfmt.h:488</i>
     */
    public enum AVChromaLocation implements IntValuedEnum<AVChromaLocation > {
        AVCHROMA_LOC_UNSPECIFIED(0),
        /** < mpeg2/4 4:2:0, h264 default for 4:2:0 */
        AVCHROMA_LOC_LEFT(1),
        /** < mpeg1 4:2:0, jpeg 4:2:0, h263 4:2:0 */
        AVCHROMA_LOC_CENTER(2),
        /** < ITU-R 601, SMPTE 274M 296M S314M(DV 4:1:1), mpeg2 4:2:2 */
        AVCHROMA_LOC_TOPLEFT(3),
        AVCHROMA_LOC_TOP(4),
        AVCHROMA_LOC_BOTTOMLEFT(5),
        AVCHROMA_LOC_BOTTOM(6),
        /** < Not part of ABI */
        AVCHROMA_LOC_NB(7);
        AVChromaLocation(long value) {
            this.value = value;
        }
        public final long value;
        public long value() {
            return this.value;
        }
        public Iterator<AVChromaLocation > iterator() {
            return Collections.singleton(this).iterator();
        }
        public static IntValuedEnum<AVChromaLocation > fromValue(int value) {
            return FlagSet.fromValue(value, values());
        }
    };
    /**
     * Audio sample formats<br>
     * - The data described by the sample format is always in native-endian order.<br>
     *   Sample values can be expressed by native C types, hence the lack of a signed<br>
     *   24-bit sample format even though it is a common raw audio data format.<br>
     * - The floating-point formats are based on full volume being in the range<br>
     *   [-1.0, 1.0]. Any values outside this range are beyond full volume level.<br>
     * - The data layout as used in av_samples_fill_arrays() and elsewhere in FFmpeg<br>
     *   (such as AVFrame in libavcodec) is as follows:<br>
     * @par<br>
     * For planar sample formats, each audio channel is in a separate data plane,<br>
     * and linesize is the buffer size, in bytes, for a single plane. All data<br>
     * planes must be the same size. For packed sample formats, only the first data<br>
     * plane is used, and samples for each channel are interleaved. In this case,<br>
     * linesize is the buffer size, in bytes, for the 1 plane.<br>
     * enum values<br>
     * <i>native declaration : ffmpeg_build/include/libavutil/samplefmt.h:40</i>
     */
    public enum AVSampleFormat implements IntValuedEnum<AVSampleFormat > {
        AV_SAMPLE_FMT_NONE(-1),
        /** < unsigned 8 bits */
        AV_SAMPLE_FMT_U8(0),
        /** < signed 16 bits */
        AV_SAMPLE_FMT_S16(1),
        /** < signed 32 bits */
        AV_SAMPLE_FMT_S32(2),
        /** < float */
        AV_SAMPLE_FMT_FLT(3),
        /** < double */
        AV_SAMPLE_FMT_DBL(4),
        /** < unsigned 8 bits, planar */
        AV_SAMPLE_FMT_U8P(5),
        /** < signed 16 bits, planar */
        AV_SAMPLE_FMT_S16P(6),
        /** < signed 32 bits, planar */
        AV_SAMPLE_FMT_S32P(7),
        /** < float, planar */
        AV_SAMPLE_FMT_FLTP(8),
        /** < double, planar */
        AV_SAMPLE_FMT_DBLP(9),
        /** < Number of sample formats. DO NOT USE if linking dynamically */
        AV_SAMPLE_FMT_NB(10);
        AVSampleFormat(long value) {
            this.value = value;
        }
        public final long value;
        public long value() {
            return this.value;
        }
        public Iterator<AVSampleFormat > iterator() {
            return Collections.singleton(this).iterator();
        }
        public static IntValuedEnum<AVSampleFormat > fromValue(int value) {
            return FlagSet.fromValue(value, values());
        }
    };
    /**
     * @}<br>
     * @defgroup channel_mask_c Audio channel layouts<br>
     * @{<br>
     * enum values<br>
     * <i>native declaration : ffmpeg_build/include/libavutil/channel_layout.h:14</i>
     */
    public enum AVMatrixEncoding implements IntValuedEnum<AVMatrixEncoding > {
        AV_MATRIX_ENCODING_NONE(0),
        AV_MATRIX_ENCODING_DOLBY(1),
        AV_MATRIX_ENCODING_DPLII(2),
        AV_MATRIX_ENCODING_DPLIIX(3),
        AV_MATRIX_ENCODING_DPLIIZ(4),
        AV_MATRIX_ENCODING_DOLBYEX(5),
        AV_MATRIX_ENCODING_DOLBYHEADPHONE(6),
        AV_MATRIX_ENCODING_NB(7);
        AVMatrixEncoding(long value) {
            this.value = value;
        }
        public final long value;
        public long value() {
            return this.value;
        }
        public Iterator<AVMatrixEncoding > iterator() {
            return Collections.singleton(this).iterator();
        }
        public static IntValuedEnum<AVMatrixEncoding > fromValue(int value) {
            return FlagSet.fromValue(value, values());
        }
    };
    /**
     * @defgroup lavu_frame AVFrame<br>
     * @ingroup lavu_data<br>
     * @{<br>
     * AVFrame is an abstraction for reference-counted raw multimedia data.<br>
     * enum values<br>
     * <i>native declaration : ffmpeg_build/include/libavutil/frame.h:18</i>
     */
    public enum AVFrameSideDataType implements IntValuedEnum<AVFrameSideDataType > {
        AV_FRAME_DATA_PANSCAN(0),
        AV_FRAME_DATA_A53_CC(1),
        AV_FRAME_DATA_STEREO3D(2),
        AV_FRAME_DATA_MATRIXENCODING(3),
        AV_FRAME_DATA_DOWNMIX_INFO(4),
        AV_FRAME_DATA_REPLAYGAIN(5),
        AV_FRAME_DATA_DISPLAYMATRIX(6),
        AV_FRAME_DATA_AFD(7),
        AV_FRAME_DATA_MOTION_VECTORS(8),
        AV_FRAME_DATA_SKIP_SAMPLES(9),
        AV_FRAME_DATA_AUDIO_SERVICE_TYPE(10);
        AVFrameSideDataType(long value) {
            this.value = value;
        }
        public final long value;
        public long value() {
            return this.value;
        }
        public Iterator<AVFrameSideDataType > iterator() {
            return Collections.singleton(this).iterator();
        }
        public static IntValuedEnum<AVFrameSideDataType > fromValue(int value) {
            return FlagSet.fromValue(value, values());
        }
    };
    /**
     * enum values<br>
     * <i>native declaration : ffmpeg_build/include/libavutil/frame.h:27</i>
     */
    public enum AVActiveFormatDescription implements IntValuedEnum<AVActiveFormatDescription > {
        AV_AFD_SAME(8),
        AV_AFD_4_3(9),
        AV_AFD_16_9(10),
        AV_AFD_14_9(11),
        AV_AFD_4_3_SP_14_9(13),
        AV_AFD_16_9_SP_14_9(14),
        AV_AFD_SP_4_3(15);
        AVActiveFormatDescription(long value) {
            this.value = value;
        }
        public final long value;
        public long value() {
            return this.value;
        }
        public Iterator<AVActiveFormatDescription > iterator() {
            return Collections.singleton(this).iterator();
        }
        public static IntValuedEnum<AVActiveFormatDescription > fromValue(int value) {
            return FlagSet.fromValue(value, values());
        }
    };
    /**
     * @defgroup avoptions AVOptions<br>
     * @ingroup lavu_data<br>
     * @{<br>
     * AVOptions provide a generic system to declare options on arbitrary structs<br>
     * ("objects"). An option can have a help text, a type and a range of possible<br>
     * values. Options may then be enumerated, read and written to.<br>
     * @section avoptions_implement Implementing AVOptions<br>
     * This section describes how to add AVOptions capabilities to a struct.<br>
     * All AVOptions-related information is stored in an AVClass. Therefore<br>
     * the first member of the struct should be a pointer to an AVClass describing it.<br>
     * The option field of the AVClass must be set to a NULL-terminated static array<br>
     * of AVOptions. Each AVOption must have a non-empty name, a type, a default<br>
     * value and for number-type AVOptions also a range of allowed values. It must<br>
     * also declare an offset in bytes from the start of the struct, where the field<br>
     * associated with this AVOption is located. Other fields in the AVOption struct<br>
     * should also be set when applicable, but are not required.<br>
     * The following example illustrates an AVOptions-enabled struct:<br>
     * @code<br>
     * typedef struct test_struct {<br>
     *     AVClass *class;<br>
     *     int      int_opt;<br>
     *     char    *str_opt;<br>
     *     uint8_t *bin_opt;<br>
     *     int      bin_len;<br>
     * } test_struct;<br>
     * static const AVOption test_options[] = {<br>
     *   { "test_int", "This is a test option of int type.", offsetof(test_struct, int_opt),<br>
     *     AV_OPT_TYPE_INT, { .i64 = -1 }, INT_MIN, INT_MAX },<br>
     *   { "test_str", "This is a test option of string type.", offsetof(test_struct, str_opt),<br>
     *     AV_OPT_TYPE_STRING },<br>
     *   { "test_bin", "This is a test option of binary type.", offsetof(test_struct, bin_opt),<br>
     *     AV_OPT_TYPE_BINARY },<br>
     *   { NULL },<br>
     * };<br>
     * static const AVClass test_class = {<br>
     *     .class_name = "test class",<br>
     *     .item_name  = av_default_item_name,<br>
     *     .option     = test_options,<br>
     *     .version    = LIBAVUTIL_VERSION_INT,<br>
     * };<br>
     * @endcode<br>
     * Next, when allocating your struct, you must ensure that the AVClass pointer<br>
     * is set to the correct value. Then, av_opt_set_defaults() can be called to<br>
     * initialize defaults. After that the struct is ready to be used with the<br>
     * AVOptions API.<br>
     * When cleaning up, you may use the av_opt_free() function to automatically<br>
     * free all the allocated string and binary options.<br>
     * Continuing with the above example:<br>
     * @code<br>
     * test_struct *alloc_test_struct(void)<br>
     * {<br>
     *     test_struct *ret = av_malloc(sizeof(*ret));<br>
     *     ret->class = &test_class;<br>
     *     av_opt_set_defaults(ret);<br>
     *     return ret;<br>
     * }<br>
     * void free_test_struct(test_struct **foo)<br>
     * {<br>
     *     av_opt_free(*foo);<br>
     *     av_freep(foo);<br>
     * }<br>
     * @endcode<br>
     * @subsection avoptions_implement_nesting Nesting<br>
     *      It may happen that an AVOptions-enabled struct contains another<br>
     *      AVOptions-enabled struct as a member (e.g. AVCodecContext in<br>
     *      libavcodec exports generic options, while its priv_data field exports<br>
     *      codec-specific options). In such a case, it is possible to set up the<br>
     *      parent struct to export a child's options. To do that, simply<br>
     *      implement AVClass.child_next() and AVClass.child_class_next() in the<br>
     *      parent struct's AVClass.<br>
     *      Assuming that the test_struct from above now also contains a<br>
     *      child_struct field:<br>
     *      @code<br>
     *      typedef struct child_struct {<br>
     *          AVClass *class;<br>
     *          int flags_opt;<br>
     *      } child_struct;<br>
     *      static const AVOption child_opts[] = {<br>
     *          { "test_flags", "This is a test option of flags type.",<br>
     *            offsetof(child_struct, flags_opt), AV_OPT_TYPE_FLAGS, { .i64 = 0 }, INT_MIN, INT_MAX },<br>
     *          { NULL },<br>
     *      };<br>
     *      static const AVClass child_class = {<br>
     *          .class_name = "child class",<br>
     *          .item_name  = av_default_item_name,<br>
     *          .option     = child_opts,<br>
     *          .version    = LIBAVUTIL_VERSION_INT,<br>
     *      };<br>
     *      void *child_next(void *obj, void *prev)<br>
     *      {<br>
     *          test_struct *t = obj;<br>
     *          if (!prev && t->child_struct)<br>
     *              return t->child_struct;<br>
     *          return NULL<br>
     *      }<br>
     *      const AVClass child_class_next(const AVClass *prev)<br>
     *      {<br>
     *          return prev ? NULL : &child_class;<br>
     *      }<br>
     *      @endcode<br>
     *      Putting child_next() and child_class_next() as defined above into<br>
     *      test_class will now make child_struct's options accessible through<br>
     *      test_struct (again, proper setup as described above needs to be done on<br>
     *      child_struct right after it is created).<br>
     *      From the above example it might not be clear why both child_next()<br>
     *      and child_class_next() are needed. The distinction is that child_next()<br>
     *      iterates over actually existing objects, while child_class_next()<br>
     *      iterates over all possible child classes. E.g. if an AVCodecContext<br>
     *      was initialized to use a codec which has private options, then its<br>
     *      child_next() will return AVCodecContext.priv_data and finish<br>
     *      iterating. OTOH child_class_next() on AVCodecContext.av_class will<br>
     *      iterate over all available codecs with private options.<br>
     * @subsection avoptions_implement_named_constants Named constants<br>
     *      It is possible to create named constants for options. Simply set the unit<br>
     *      field of the option the constants should apply to a string and<br>
     *      create the constants themselves as options of type AV_OPT_TYPE_CONST<br>
     *      with their unit field set to the same string.<br>
     *      Their default_val field should contain the value of the named<br>
     *      constant.<br>
     *      For example, to add some named constants for the test_flags option<br>
     *      above, put the following into the child_opts array:<br>
     *      @code<br>
     *      { "test_flags", "This is a test option of flags type.",<br>
     *        offsetof(child_struct, flags_opt), AV_OPT_TYPE_FLAGS, { .i64 = 0 }, INT_MIN, INT_MAX, "test_unit" },<br>
     *      { "flag1", "This is a flag with value 16", 0, AV_OPT_TYPE_CONST, { .i64 = 16 }, 0, 0, "test_unit" },<br>
     *      @endcode<br>
     * @section avoptions_use Using AVOptions<br>
     * This section deals with accessing options in an AVOptions-enabled struct.<br>
     * Such structs in FFmpeg are e.g. AVCodecContext in libavcodec or<br>
     * AVFormatContext in libavformat.<br>
     * @subsection avoptions_use_examine Examining AVOptions<br>
     * The basic functions for examining options are av_opt_next(), which iterates<br>
     * over all options defined for one object, and av_opt_find(), which searches<br>
     * for an option with the given name.<br>
     * The situation is more complicated with nesting. An AVOptions-enabled struct<br>
     * may have AVOptions-enabled children. Passing the AV_OPT_SEARCH_CHILDREN flag<br>
     * to av_opt_find() will make the function search children recursively.<br>
     * For enumerating there are basically two cases. The first is when you want to<br>
     * get all options that may potentially exist on the struct and its children<br>
     * (e.g.  when constructing documentation). In that case you should call<br>
     * av_opt_child_class_next() recursively on the parent struct's AVClass.  The<br>
     * second case is when you have an already initialized struct with all its<br>
     * children and you want to get all options that can be actually written or read<br>
     * from it. In that case you should call av_opt_child_next() recursively (and<br>
     * av_opt_next() on each result).<br>
     * @subsection avoptions_use_get_set Reading and writing AVOptions<br>
     * When setting options, you often have a string read directly from the<br>
     * user. In such a case, simply passing it to av_opt_set() is enough. For<br>
     * non-string type options, av_opt_set() will parse the string according to the<br>
     * option type.<br>
     * Similarly av_opt_get() will read any option type and convert it to a string<br>
     * which will be returned. Do not forget that the string is allocated, so you<br>
     * have to free it with av_free().<br>
     * In some cases it may be more convenient to put all options into an<br>
     * AVDictionary and call av_opt_set_dict() on it. A specific case of this<br>
     * are the format/codec open functions in lavf/lavc which take a dictionary<br>
     * filled with option as a parameter. This makes it possible to set some options<br>
     * that cannot be set otherwise, since e.g. the input file format is not known<br>
     * before the file is actually opened.<br>
     * enum values<br>
     * <i>native declaration : ffmpeg_build/include/libavutil/opt.h:183</i>
     */
    public enum AVOptionType implements IntValuedEnum<AVOptionType > {
        AV_OPT_TYPE_FLAGS(0),
        AV_OPT_TYPE_INT(1),
        AV_OPT_TYPE_INT64(2),
        AV_OPT_TYPE_DOUBLE(3),
        AV_OPT_TYPE_FLOAT(4),
        AV_OPT_TYPE_STRING(5),
        AV_OPT_TYPE_RATIONAL(6),
        /** < offset must point to a pointer immediately followed by an int for the length */
        AV_OPT_TYPE_BINARY(7),
        AV_OPT_TYPE_DICT(8),
        AV_OPT_TYPE_CONST(128),
        /** < offset must point to two consecutive integers */
        AV_OPT_TYPE_IMAGE_SIZE((('E') | (('Z') << 8) | (('I') << 16) | ('S' << 24))),
        AV_OPT_TYPE_PIXEL_FMT((('T') | (('M') << 8) | (('F') << 16) | ('P' << 24))),
        AV_OPT_TYPE_SAMPLE_FMT((('T') | (('M') << 8) | (('F') << 16) | ('S' << 24))),
        /** < offset must point to AVRational */
        AV_OPT_TYPE_VIDEO_RATE((('T') | (('A') << 8) | (('R') << 16) | ('V' << 24))),
        AV_OPT_TYPE_DURATION(((' ') | (('R') << 8) | (('U') << 16) | ('D' << 24))),
        AV_OPT_TYPE_COLOR((('R') | (('L') << 8) | (('O') << 16) | ('C' << 24))),
        AV_OPT_TYPE_CHANNEL_LAYOUT((('A') | (('L') << 8) | (('H') << 16) | ('C' << 24))),
        AV_OPT_TYPE_BOOL((('L') | (('O') << 8) | (('O') << 16) | ('B' << 24)));
        AVOptionType(long value) {
            this.value = value;
        }
        public final long value;
        public long value() {
            return this.value;
        }
        public Iterator<AVOptionType > iterator() {
            return Collections.singleton(this).iterator();
        }
        public static IntValuedEnum<AVOptionType > fromValue(int value) {
            return FlagSet.fromValue(value, values());
        }
    };
    public static final int AV_OPT_FLAG_IMPLICIT_KEY = 1;
    /**
     * Possible downmix types.<br>
     * enum values<br>
     * <i>native declaration : ffmpeg_build/include/libavutil/downmix_info.h:7</i>
     */
    public enum AVDownmixType implements IntValuedEnum<AVDownmixType > {
        /** < Not indicated. */
        AV_DOWNMIX_TYPE_UNKNOWN(0),
        /** < Lo/Ro 2-channel downmix (Stereo). */
        AV_DOWNMIX_TYPE_LORO(1),
        /** < Lt/Rt 2-channel downmix, Dolby Surround compatible. */
        AV_DOWNMIX_TYPE_LTRT(2),
        /** < Lt/Rt 2-channel downmix, Dolby Pro Logic II compatible. */
        AV_DOWNMIX_TYPE_DPLII(3),
        /** < Number of downmix types. Not part of ABI. */
        AV_DOWNMIX_TYPE_NB(4);
        AVDownmixType(long value) {
            this.value = value;
        }
        public final long value;
        public long value() {
            return this.value;
        }
        public Iterator<AVDownmixType > iterator() {
            return Collections.singleton(this).iterator();
        }
        public static IntValuedEnum<AVDownmixType > fromValue(int value) {
            return FlagSet.fromValue(value, values());
        }
    };
    /**
     * List of possible 3D Types<br>
     * enum values<br>
     * <i>native declaration : ffmpeg_build/include/libavutil/stereo3d.h:10</i>
     */
    public enum AVStereo3DType implements IntValuedEnum<AVStereo3DType > {
        AV_STEREO3D_2D(0),
        AV_STEREO3D_SIDEBYSIDE(1),
        AV_STEREO3D_TOPBOTTOM(2),
        AV_STEREO3D_FRAMESEQUENCE(3),
        AV_STEREO3D_CHECKERBOARD(4),
        AV_STEREO3D_SIDEBYSIDE_QUINCUNX(5),
        AV_STEREO3D_LINES(6),
        AV_STEREO3D_COLUMNS(7);
        AVStereo3DType(long value) {
            this.value = value;
        }
        public final long value;
        public long value() {
            return this.value;
        }
        public Iterator<AVStereo3DType > iterator() {
            return Collections.singleton(this).iterator();
        }
        public static IntValuedEnum<AVStereo3DType > fromValue(int value) {
            return FlagSet.fromValue(value, values());
        }
    };
    /**
     * @defgroup lavu_hmac HMAC<br>
     * @ingroup lavu_crypto<br>
     * @{<br>
     * enum values<br>
     * <i>native declaration : ffmpeg_build/include/libavutil/hmac.h:12</i>
     */
    public enum AVHMACType implements IntValuedEnum<AVHMACType > {
        AV_HMAC_MD5(0),
        AV_HMAC_SHA1(1),
        AV_HMAC_SHA224(2),
        AV_HMAC_SHA256(3),
        AV_HMAC_SHA384(12),
        AV_HMAC_SHA512(13);
        AVHMACType(long value) {
            this.value = value;
        }
        public final long value;
        public long value() {
            return this.value;
        }
        public Iterator<AVHMACType > iterator() {
            return Collections.singleton(this).iterator();
        }
        public static IntValuedEnum<AVHMACType > fromValue(int value) {
            return FlagSet.fromValue(value, values());
        }
    };
    /**
     * enum values<br>
     * <i>native declaration : ffmpeg_build/include/libavutil/timecode.h:7</i>
     */
    public enum AVTimecodeFlag implements IntValuedEnum<AVTimecodeFlag > {
        /** < timecode is drop frame */
        AV_TIMECODE_FLAG_DROPFRAME(1 << 0),
        /** < timecode wraps after 24 hours */
        AV_TIMECODE_FLAG_24HOURSMAX(1 << 1),
        /** < negative time values are allowed */
        AV_TIMECODE_FLAG_ALLOWNEGATIVE(1 << 2);
        AVTimecodeFlag(long value) {
            this.value = value;
        }
        public final long value;
        public long value() {
            return this.value;
        }
        public Iterator<AVTimecodeFlag > iterator() {
            return Collections.singleton(this).iterator();
        }
        public static IntValuedEnum<AVTimecodeFlag > fromValue(int value) {
            return FlagSet.fromValue(value, values());
        }
    };
    /**
     * enum values<br>
     * <i>native declaration : ffmpeg_build/include/libavutil/threadmessage.h:17</i>
     */
    public enum AVThreadMessageFlags implements IntValuedEnum<AVThreadMessageFlags > {
        AV_THREAD_MESSAGE_NONBLOCK(1);
        AVThreadMessageFlags(long value) {
            this.value = value;
        }
        public final long value;
        public long value() {
            return this.value;
        }
        public Iterator<AVThreadMessageFlags > iterator() {
            return Collections.singleton(this).iterator();
        }
        public static IntValuedEnum<AVThreadMessageFlags > fromValue(int value) {
            return FlagSet.fromValue(value, values());
        }
    };
    /**
     * enum values<br>
     * <i>native declaration : ffmpeg_build/include/libavutil/crc.h:15</i>
     */
    public enum AVCRCId implements IntValuedEnum<AVCRCId > {
        AV_CRC_8_ATM(0),
        AV_CRC_16_ANSI(1),
        AV_CRC_16_CCITT(2),
        AV_CRC_32_IEEE(3),
        AV_CRC_32_IEEE_LE(4),
        AV_CRC_16_ANSI_LE(5),
        AV_CRC_24_IEEE(12),
        AV_CRC_MAX(13);
        AVCRCId(long value) {
            this.value = value;
        }
        public final long value;
        public long value() {
            return this.value;
        }
        public Iterator<AVCRCId > iterator() {
            return Collections.singleton(this).iterator();
        }
        public static IntValuedEnum<AVCRCId > fromValue(int value) {
            return FlagSet.fromValue(value, values());
        }
    };
    /**
     * Conversion Error : a.num<br>
     * SKIPPED:<br>
     * <i>native declaration : ffmpeg_build/include/libavutil/rational.h:0</i><br>
     * const int64_t tmp = a.num * (int64_t)b.den - b.num * (int64_t)a.den;
     */
    /** <i>native declaration : ffmpeg_build/include/libavutil/avutil.h</i> */
    public static final int FF_LAMBDA_SHIFT = (int)7;
    /** <i>native declaration : ffmpeg_build/include/libavutil/avutil.h</i> */
    public static final int FF_LAMBDA_SCALE = (int)(1 << 7);
    /** <i>native declaration : ffmpeg_build/include/libavutil/avutil.h</i> */
    public static final int FF_QP2LAMBDA = (int)118;
    /** <i>native declaration : ffmpeg_build/include/libavutil/avutil.h</i> */
    public static final int FF_LAMBDA_MAX = (int)(256 * 128 - 1);
    /** <i>native declaration : ffmpeg_build/include/libavutil/avutil.h</i> */
    public static final int FF_QUALITY_SCALE = (int)(1 << 7);
    /** <i>native declaration : ffmpeg_build/include/libavutil/avutil.h</i> */
    public static final long AV_NOPTS_VALUE = (long)(0x8000000000000000L);
    /** <i>native declaration : ffmpeg_build/include/libavutil/avutil.h</i> */
    public static final int AV_TIME_BASE = (int)1000000;
    /** <i>native declaration : ffmpeg_build/include/libavutil/version.h</i> */
    public static final int LIBAVUTIL_VERSION_MAJOR = (int)55;
    /** <i>native declaration : ffmpeg_build/include/libavutil/version.h</i> */
    public static final int LIBAVUTIL_VERSION_MINOR = (int)4;
    /** <i>native declaration : ffmpeg_build/include/libavutil/version.h</i> */
    public static final int LIBAVUTIL_VERSION_MICRO = (int)100;
    /** <i>native declaration : ffmpeg_build/include/libavutil/version.h</i> */
    public static final int LIBAVUTIL_VERSION_INT = (int)((55) << 16 | (4) << 8 | (100));
    /**
     * define<br>
     * Conversion Error : 55.4.<br>
     * SKIPPED:<br>
     * <i>native declaration : ffmpeg_build/include/libavutil/version.h:0</i><br>
     * 55.4.
     */
    /** <i>native declaration : ffmpeg_build/include/libavutil/version.h</i> */
    public static final int LIBAVUTIL_BUILD = (int)((55) << 16 | (4) << 8 | (100));
    /** <i>native declaration : ffmpeg_build/include/libavutil/version.h</i> */
    public static final String LIBAVUTIL_IDENT = (String)"Lavu";
    /** <i>native declaration : ffmpeg_build/include/libavutil/version.h</i> */
    public static final boolean FF_API_VDPAU = (boolean)(55 < 56);
    /** <i>native declaration : ffmpeg_build/include/libavutil/version.h</i> */
    public static final boolean FF_API_XVMC = (boolean)(55 < 56);
    /** <i>native declaration : ffmpeg_build/include/libavutil/version.h</i> */
    public static final boolean FF_API_OPT_TYPE_METADATA = (boolean)(55 < 56);
    /** <i>native declaration : ffmpeg_build/include/libavutil/version.h</i> */
    public static final boolean FF_API_DLOG = (boolean)(55 < 56);
    /** <i>native declaration : ffmpeg_build/include/libavutil/version.h</i> */
    public static final boolean FF_API_VAAPI = (boolean)(55 < 56);
    /** <i>native declaration : ffmpeg_build/include/libavutil/version.h</i> */
    public static final boolean FF_API_FRAME_QP = (boolean)(55 < 56);
    /** <i>native declaration : ffmpeg_build/include/libavutil/version.h</i> */
    public static final boolean FF_API_PLUS1_MINUS1 = (boolean)(55 < 56);
    /** <i>native declaration : ffmpeg_build/include/libavutil/version.h</i> */
    public static final boolean FF_API_ERROR_FRAME = (boolean)(55 < 56);
    /** <i>native declaration : ffmpeg_build/include/libavutil/avconfig.h</i> */
    public static final int AV_HAVE_BIGENDIAN = (int)0;
    /** <i>native declaration : ffmpeg_build/include/libavutil/avconfig.h</i> */
    public static final int AV_HAVE_FAST_UNALIGNED = (int)1;
    /** <i>native declaration : ffmpeg_build/include/libavutil/avconfig.h</i> */
    public static final int AV_HAVE_INCOMPATIBLE_LIBAV_ABI = (int)0;
    /** <i>native declaration : ffmpeg_build/include/libavutil/error.h</i> */
    public static final int AVERROR_BSF_NOT_FOUND = (int)(-(0xF8) | (('B') << 8) | (('S') << 16) | ('F' << 24));
    /** <i>native declaration : ffmpeg_build/include/libavutil/error.h</i> */
    public static final int AVERROR_BUG = (int)(-('B') | (('U') << 8) | (('G') << 16) | ('!' << 24));
    /** <i>native declaration : ffmpeg_build/include/libavutil/error.h</i> */
    public static final int AVERROR_BUFFER_TOO_SMALL = (int)(-('B') | (('U') << 8) | (('F') << 16) | ('S' << 24));
    /** <i>native declaration : ffmpeg_build/include/libavutil/error.h</i> */
    public static final int AVERROR_DECODER_NOT_FOUND = (int)(-(0xF8) | (('D') << 8) | (('E') << 16) | ('C' << 24));
    /** <i>native declaration : ffmpeg_build/include/libavutil/error.h</i> */
    public static final int AVERROR_DEMUXER_NOT_FOUND = (int)(-(0xF8) | (('D') << 8) | (('E') << 16) | ('M' << 24));
    /** <i>native declaration : ffmpeg_build/include/libavutil/error.h</i> */
    public static final int AVERROR_ENCODER_NOT_FOUND = (int)(-(0xF8) | (('E') << 8) | (('N') << 16) | ('C' << 24));
    /** <i>native declaration : ffmpeg_build/include/libavutil/error.h</i> */
    public static final int AVERROR_EOF = (int)(-('E') | (('O') << 8) | (('F') << 16) | (' ' << 24));
    /** <i>native declaration : ffmpeg_build/include/libavutil/error.h</i> */
    public static final int AVERROR_EXIT = (int)(-('E') | (('X') << 8) | (('I') << 16) | ('T' << 24));
    /** <i>native declaration : ffmpeg_build/include/libavutil/error.h</i> */
    public static final int AVERROR_EXTERNAL = (int)(-('E') | (('X') << 8) | (('T') << 16) | (' ' << 24));
    /** <i>native declaration : ffmpeg_build/include/libavutil/error.h</i> */
    public static final int AVERROR_FILTER_NOT_FOUND = (int)(-(0xF8) | (('F') << 8) | (('I') << 16) | ('L' << 24));
    /** <i>native declaration : ffmpeg_build/include/libavutil/error.h</i> */
    public static final int AVERROR_INVALIDDATA = (int)(-('I') | (('N') << 8) | (('D') << 16) | ('A' << 24));
    /** <i>native declaration : ffmpeg_build/include/libavutil/error.h</i> */
    public static final int AVERROR_MUXER_NOT_FOUND = (int)(-(0xF8) | (('M') << 8) | (('U') << 16) | ('X' << 24));
    /** <i>native declaration : ffmpeg_build/include/libavutil/error.h</i> */
    public static final int AVERROR_OPTION_NOT_FOUND = (int)(-(0xF8) | (('O') << 8) | (('P') << 16) | ('T' << 24));
    /** <i>native declaration : ffmpeg_build/include/libavutil/error.h</i> */
    public static final int AVERROR_PATCHWELCOME = (int)(-('P') | (('A') << 8) | (('W') << 16) | ('E' << 24));
    /** <i>native declaration : ffmpeg_build/include/libavutil/error.h</i> */
    public static final int AVERROR_PROTOCOL_NOT_FOUND = (int)(-(0xF8) | (('P') << 8) | (('R') << 16) | ('O' << 24));
    /** <i>native declaration : ffmpeg_build/include/libavutil/error.h</i> */
    public static final int AVERROR_STREAM_NOT_FOUND = (int)(-(0xF8) | (('S') << 8) | (('T') << 16) | ('R' << 24));
    /** <i>native declaration : ffmpeg_build/include/libavutil/error.h</i> */
    public static final int AVERROR_BUG2 = (int)(-('B') | (('U') << 8) | (('G') << 16) | (' ' << 24));
    /** <i>native declaration : ffmpeg_build/include/libavutil/error.h</i> */
    public static final int AVERROR_UNKNOWN = (int)(-('U') | (('N') << 8) | (('K') << 16) | ('N' << 24));
    /** <i>native declaration : ffmpeg_build/include/libavutil/error.h</i> */
    public static final int AVERROR_EXPERIMENTAL = (int)(0x2bb2afa8);
    /** <i>native declaration : ffmpeg_build/include/libavutil/error.h</i> */
    public static final int AVERROR_INPUT_CHANGED = (int)(0x636e6701);
    /** <i>native declaration : ffmpeg_build/include/libavutil/error.h</i> */
    public static final int AVERROR_OUTPUT_CHANGED = (int)(0x636e6702);
    /** <i>native declaration : ffmpeg_build/include/libavutil/error.h</i> */
    public static final int AVERROR_HTTP_BAD_REQUEST = (int)(-(0xF8) | (('4') << 8) | (('0') << 16) | ('0' << 24));
    /** <i>native declaration : ffmpeg_build/include/libavutil/error.h</i> */
    public static final int AVERROR_HTTP_UNAUTHORIZED = (int)(-(0xF8) | (('4') << 8) | (('0') << 16) | ('1' << 24));
    /** <i>native declaration : ffmpeg_build/include/libavutil/error.h</i> */
    public static final int AVERROR_HTTP_FORBIDDEN = (int)(-(0xF8) | (('4') << 8) | (('0') << 16) | ('3' << 24));
    /** <i>native declaration : ffmpeg_build/include/libavutil/error.h</i> */
    public static final int AVERROR_HTTP_NOT_FOUND = (int)(-(0xF8) | (('4') << 8) | (('0') << 16) | ('4' << 24));
    /** <i>native declaration : ffmpeg_build/include/libavutil/error.h</i> */
    public static final int AVERROR_HTTP_OTHER_4XX = (int)(-(0xF8) | (('4') << 8) | (('X') << 16) | ('X' << 24));
    /** <i>native declaration : ffmpeg_build/include/libavutil/error.h</i> */
    public static final int AVERROR_HTTP_SERVER_ERROR = (int)(-(0xF8) | (('5') << 8) | (('X') << 16) | ('X' << 24));
    /** <i>native declaration : ffmpeg_build/include/libavutil/error.h</i> */
    public static final int AV_ERROR_MAX_STRING_SIZE = (int)64;
    /** <i>native declaration : ffmpeg_build/include/libavutil/mathematics.h</i> */
    public static final double M_LOG2_10 = (double)3.32192809488736234787;
    /** <i>native declaration : ffmpeg_build/include/libavutil/mathematics.h</i> */
    public static final double M_PHI = (double)1.61803398874989484820;
    /** <i>native declaration : ffmpeg_build/include/libavutil/log.h</i> */
    public static final int AV_LOG_QUIET = (int)-8;
    /** <i>native declaration : ffmpeg_build/include/libavutil/log.h</i> */
    public static final int AV_LOG_PANIC = (int)0;
    /** <i>native declaration : ffmpeg_build/include/libavutil/log.h</i> */
    public static final int AV_LOG_FATAL = (int)8;
    /** <i>native declaration : ffmpeg_build/include/libavutil/log.h</i> */
    public static final int AV_LOG_ERROR = (int)16;
    /** <i>native declaration : ffmpeg_build/include/libavutil/log.h</i> */
    public static final int AV_LOG_WARNING = (int)24;
    /** <i>native declaration : ffmpeg_build/include/libavutil/log.h</i> */
    public static final int AV_LOG_INFO = (int)32;
    /** <i>native declaration : ffmpeg_build/include/libavutil/log.h</i> */
    public static final int AV_LOG_VERBOSE = (int)40;
    /** <i>native declaration : ffmpeg_build/include/libavutil/log.h</i> */
    public static final int AV_LOG_DEBUG = (int)48;
    /** <i>native declaration : ffmpeg_build/include/libavutil/log.h</i> */
    public static final int AV_LOG_TRACE = (int)56;
    /** <i>native declaration : ffmpeg_build/include/libavutil/log.h</i> */
    public static final int AV_LOG_MAX_OFFSET = (int)(56 - -8);
    /** <i>native declaration : ffmpeg_build/include/libavutil/log.h</i> */
    public static final int AV_LOG_SKIP_REPEATED = (int)1;
    /** <i>native declaration : ffmpeg_build/include/libavutil/log.h</i> */
    public static final int AV_LOG_PRINT_LEVEL = (int)2;
    /** <i>native declaration : ffmpeg_build/include/libavutil/pixfmt.h</i> */
    public static final int AVPALETTE_SIZE = (int)1024;
    /** <i>native declaration : ffmpeg_build/include/libavutil/pixfmt.h</i> */
    public static final int AVPALETTE_COUNT = (int)256;
    /** <i>native declaration : ffmpeg_build/include/libavutil/buffer.h</i> */
    public static final int AV_BUFFER_FLAG_READONLY = (int)(1 << 0);
    /** <i>native declaration : ffmpeg_build/include/libavutil/cpu.h</i> */
    public static final int AV_CPU_FLAG_FORCE = (int)0x80000000;
    /** <i>native declaration : ffmpeg_build/include/libavutil/cpu.h</i> */
    public static final int AV_CPU_FLAG_MMX = (int)0x0001;
    /** <i>native declaration : ffmpeg_build/include/libavutil/cpu.h</i> */
    public static final int AV_CPU_FLAG_MMXEXT = (int)0x0002;
    /** <i>native declaration : ffmpeg_build/include/libavutil/cpu.h</i> */
    public static final int AV_CPU_FLAG_MMX2 = (int)0x0002;
    /** <i>native declaration : ffmpeg_build/include/libavutil/cpu.h</i> */
    public static final int AV_CPU_FLAG_3DNOW = (int)0x0004;
    /** <i>native declaration : ffmpeg_build/include/libavutil/cpu.h</i> */
    public static final int AV_CPU_FLAG_SSE = (int)0x0008;
    /** <i>native declaration : ffmpeg_build/include/libavutil/cpu.h</i> */
    public static final int AV_CPU_FLAG_SSE2 = (int)0x0010;
    /** <i>native declaration : ffmpeg_build/include/libavutil/cpu.h</i> */
    public static final int AV_CPU_FLAG_SSE2SLOW = (int)0x40000000;
    /** <i>native declaration : ffmpeg_build/include/libavutil/cpu.h</i> */
    public static final int AV_CPU_FLAG_3DNOWEXT = (int)0x0020;
    /** <i>native declaration : ffmpeg_build/include/libavutil/cpu.h</i> */
    public static final int AV_CPU_FLAG_SSE3 = (int)0x0040;
    /** <i>native declaration : ffmpeg_build/include/libavutil/cpu.h</i> */
    public static final int AV_CPU_FLAG_SSE3SLOW = (int)0x20000000;
    /** <i>native declaration : ffmpeg_build/include/libavutil/cpu.h</i> */
    public static final int AV_CPU_FLAG_SSSE3 = (int)0x0080;
    /** <i>native declaration : ffmpeg_build/include/libavutil/cpu.h</i> */
    public static final int AV_CPU_FLAG_ATOM = (int)0x10000000;
    /** <i>native declaration : ffmpeg_build/include/libavutil/cpu.h</i> */
    public static final int AV_CPU_FLAG_SSE4 = (int)0x0100;
    /** <i>native declaration : ffmpeg_build/include/libavutil/cpu.h</i> */
    public static final int AV_CPU_FLAG_SSE42 = (int)0x0200;
    /** <i>native declaration : ffmpeg_build/include/libavutil/cpu.h</i> */
    public static final int AV_CPU_FLAG_AVX = (int)0x4000;
    /** <i>native declaration : ffmpeg_build/include/libavutil/cpu.h</i> */
    public static final int AV_CPU_FLAG_AVXSLOW = (int)0x8000000;
    /** <i>native declaration : ffmpeg_build/include/libavutil/cpu.h</i> */
    public static final int AV_CPU_FLAG_XOP = (int)0x0400;
    /** <i>native declaration : ffmpeg_build/include/libavutil/cpu.h</i> */
    public static final int AV_CPU_FLAG_FMA4 = (int)0x0800;
    /** <i>native declaration : ffmpeg_build/include/libavutil/cpu.h</i> */
    public static final int AV_CPU_FLAG_CMOV = (int)0x1000;
    /** <i>native declaration : ffmpeg_build/include/libavutil/cpu.h</i> */
    public static final int AV_CPU_FLAG_AVX2 = (int)0x8000;
    /** <i>native declaration : ffmpeg_build/include/libavutil/cpu.h</i> */
    public static final int AV_CPU_FLAG_FMA3 = (int)0x10000;
    /** <i>native declaration : ffmpeg_build/include/libavutil/cpu.h</i> */
    public static final int AV_CPU_FLAG_BMI1 = (int)0x20000;
    /** <i>native declaration : ffmpeg_build/include/libavutil/cpu.h</i> */
    public static final int AV_CPU_FLAG_BMI2 = (int)0x40000;
    /** <i>native declaration : ffmpeg_build/include/libavutil/cpu.h</i> */
    public static final int AV_CPU_FLAG_ALTIVEC = (int)0x0001;
    /** <i>native declaration : ffmpeg_build/include/libavutil/cpu.h</i> */
    public static final int AV_CPU_FLAG_VSX = (int)0x0002;
    /** <i>native declaration : ffmpeg_build/include/libavutil/cpu.h</i> */
    public static final int AV_CPU_FLAG_POWER8 = (int)0x0004;
    /** <i>native declaration : ffmpeg_build/include/libavutil/cpu.h</i> */
    public static final int AV_CPU_FLAG_ARMV5TE = (int)(1 << 0);
    /** <i>native declaration : ffmpeg_build/include/libavutil/cpu.h</i> */
    public static final int AV_CPU_FLAG_ARMV6 = (int)(1 << 1);
    /** <i>native declaration : ffmpeg_build/include/libavutil/cpu.h</i> */
    public static final int AV_CPU_FLAG_ARMV6T2 = (int)(1 << 2);
    /** <i>native declaration : ffmpeg_build/include/libavutil/cpu.h</i> */
    public static final int AV_CPU_FLAG_VFP = (int)(1 << 3);
    /** <i>native declaration : ffmpeg_build/include/libavutil/cpu.h</i> */
    public static final int AV_CPU_FLAG_VFPV3 = (int)(1 << 4);
    /** <i>native declaration : ffmpeg_build/include/libavutil/cpu.h</i> */
    public static final int AV_CPU_FLAG_NEON = (int)(1 << 5);
    /** <i>native declaration : ffmpeg_build/include/libavutil/cpu.h</i> */
    public static final int AV_CPU_FLAG_ARMV8 = (int)(1 << 6);
    /** <i>native declaration : ffmpeg_build/include/libavutil/cpu.h</i> */
    public static final int AV_CPU_FLAG_SETEND = (int)(1 << 16);
    /** <i>native declaration : ffmpeg_build/include/libavutil/channel_layout.h</i> */
    public static final int AV_CH_FRONT_LEFT = (int)0x00000001;
    /** <i>native declaration : ffmpeg_build/include/libavutil/channel_layout.h</i> */
    public static final int AV_CH_FRONT_RIGHT = (int)0x00000002;
    /** <i>native declaration : ffmpeg_build/include/libavutil/channel_layout.h</i> */
    public static final int AV_CH_FRONT_CENTER = (int)0x00000004;
    /** <i>native declaration : ffmpeg_build/include/libavutil/channel_layout.h</i> */
    public static final int AV_CH_LOW_FREQUENCY = (int)0x00000008;
    /** <i>native declaration : ffmpeg_build/include/libavutil/channel_layout.h</i> */
    public static final int AV_CH_BACK_LEFT = (int)0x00000010;
    /** <i>native declaration : ffmpeg_build/include/libavutil/channel_layout.h</i> */
    public static final int AV_CH_BACK_RIGHT = (int)0x00000020;
    /** <i>native declaration : ffmpeg_build/include/libavutil/channel_layout.h</i> */
    public static final int AV_CH_FRONT_LEFT_OF_CENTER = (int)0x00000040;
    /** <i>native declaration : ffmpeg_build/include/libavutil/channel_layout.h</i> */
    public static final int AV_CH_FRONT_RIGHT_OF_CENTER = (int)0x00000080;
    /** <i>native declaration : ffmpeg_build/include/libavutil/channel_layout.h</i> */
    public static final int AV_CH_BACK_CENTER = (int)0x00000100;
    /** <i>native declaration : ffmpeg_build/include/libavutil/channel_layout.h</i> */
    public static final int AV_CH_SIDE_LEFT = (int)0x00000200;
    /** <i>native declaration : ffmpeg_build/include/libavutil/channel_layout.h</i> */
    public static final int AV_CH_SIDE_RIGHT = (int)0x00000400;
    /** <i>native declaration : ffmpeg_build/include/libavutil/channel_layout.h</i> */
    public static final int AV_CH_TOP_CENTER = (int)0x00000800;
    /** <i>native declaration : ffmpeg_build/include/libavutil/channel_layout.h</i> */
    public static final int AV_CH_TOP_FRONT_LEFT = (int)0x00001000;
    /** <i>native declaration : ffmpeg_build/include/libavutil/channel_layout.h</i> */
    public static final int AV_CH_TOP_FRONT_CENTER = (int)0x00002000;
    /** <i>native declaration : ffmpeg_build/include/libavutil/channel_layout.h</i> */
    public static final int AV_CH_TOP_FRONT_RIGHT = (int)0x00004000;
    /** <i>native declaration : ffmpeg_build/include/libavutil/channel_layout.h</i> */
    public static final int AV_CH_TOP_BACK_LEFT = (int)0x00008000;
    /** <i>native declaration : ffmpeg_build/include/libavutil/channel_layout.h</i> */
    public static final int AV_CH_TOP_BACK_CENTER = (int)0x00010000;
    /** <i>native declaration : ffmpeg_build/include/libavutil/channel_layout.h</i> */
    public static final int AV_CH_TOP_BACK_RIGHT = (int)0x00020000;
    /** <i>native declaration : ffmpeg_build/include/libavutil/channel_layout.h</i> */
    public static final int AV_CH_STEREO_LEFT = (int)0x20000000;
    /** <i>native declaration : ffmpeg_build/include/libavutil/channel_layout.h</i> */
    public static final int AV_CH_STEREO_RIGHT = (int)0x40000000;
    /** <i>native declaration : ffmpeg_build/include/libavutil/channel_layout.h</i> */
    public static final long AV_CH_WIDE_LEFT = (long)0x0000000080000000L;
    /** <i>native declaration : ffmpeg_build/include/libavutil/channel_layout.h</i> */
    public static final long AV_CH_WIDE_RIGHT = (long)0x0000000100000000L;
    /** <i>native declaration : ffmpeg_build/include/libavutil/channel_layout.h</i> */
    public static final long AV_CH_SURROUND_DIRECT_LEFT = (long)0x0000000200000000L;
    /** <i>native declaration : ffmpeg_build/include/libavutil/channel_layout.h</i> */
    public static final long AV_CH_SURROUND_DIRECT_RIGHT = (long)0x0000000400000000L;
    /** <i>native declaration : ffmpeg_build/include/libavutil/channel_layout.h</i> */
    public static final long AV_CH_LOW_FREQUENCY_2 = (long)0x0000000800000000L;
    /** <i>native declaration : ffmpeg_build/include/libavutil/channel_layout.h</i> */
    public static final long AV_CH_LAYOUT_NATIVE = (long)0x8000000000000000L;
    /** <i>native declaration : ffmpeg_build/include/libavutil/channel_layout.h</i> */
    public static final int AV_CH_LAYOUT_MONO = (int)(0x00000004);
    /** <i>native declaration : ffmpeg_build/include/libavutil/channel_layout.h</i> */
    public static final int AV_CH_LAYOUT_STEREO = (int)(0x00000001 | 0x00000002);
    /** <i>native declaration : ffmpeg_build/include/libavutil/channel_layout.h</i> */
    public static final int AV_CH_LAYOUT_2POINT1 = (int)((0x00000001 | 0x00000002) | 0x00000008);
    /** <i>native declaration : ffmpeg_build/include/libavutil/channel_layout.h</i> */
    public static final int AV_CH_LAYOUT_2_1 = (int)((0x00000001 | 0x00000002) | 0x00000100);
    /** <i>native declaration : ffmpeg_build/include/libavutil/channel_layout.h</i> */
    public static final int AV_CH_LAYOUT_SURROUND = (int)((0x00000001 | 0x00000002) | 0x00000004);
    /** <i>native declaration : ffmpeg_build/include/libavutil/channel_layout.h</i> */
    public static final int AV_CH_LAYOUT_3POINT1 = (int)(((0x00000001 | 0x00000002) | 0x00000004) | 0x00000008);
    /** <i>native declaration : ffmpeg_build/include/libavutil/channel_layout.h</i> */
    public static final int AV_CH_LAYOUT_4POINT0 = (int)(((0x00000001 | 0x00000002) | 0x00000004) | 0x00000100);
    /** <i>native declaration : ffmpeg_build/include/libavutil/channel_layout.h</i> */
    public static final int AV_CH_LAYOUT_4POINT1 = (int)((((0x00000001 | 0x00000002) | 0x00000004) | 0x00000100) | 0x00000008);
    /** <i>native declaration : ffmpeg_build/include/libavutil/channel_layout.h</i> */
    public static final int AV_CH_LAYOUT_2_2 = (int)((0x00000001 | 0x00000002) | 0x00000200 | 0x00000400);
    /** <i>native declaration : ffmpeg_build/include/libavutil/channel_layout.h</i> */
    public static final int AV_CH_LAYOUT_QUAD = (int)((0x00000001 | 0x00000002) | 0x00000010 | 0x00000020);
    /** <i>native declaration : ffmpeg_build/include/libavutil/channel_layout.h</i> */
    public static final int AV_CH_LAYOUT_5POINT0 = (int)(((0x00000001 | 0x00000002) | 0x00000004) | 0x00000200 | 0x00000400);
    /** <i>native declaration : ffmpeg_build/include/libavutil/channel_layout.h</i> */
    public static final int AV_CH_LAYOUT_5POINT1 = (int)((((0x00000001 | 0x00000002) | 0x00000004) | 0x00000200 | 0x00000400) | 0x00000008);
    /** <i>native declaration : ffmpeg_build/include/libavutil/channel_layout.h</i> */
    public static final int AV_CH_LAYOUT_5POINT0_BACK = (int)(((0x00000001 | 0x00000002) | 0x00000004) | 0x00000010 | 0x00000020);
    /** <i>native declaration : ffmpeg_build/include/libavutil/channel_layout.h</i> */
    public static final int AV_CH_LAYOUT_5POINT1_BACK = (int)((((0x00000001 | 0x00000002) | 0x00000004) | 0x00000010 | 0x00000020) | 0x00000008);
    /** <i>native declaration : ffmpeg_build/include/libavutil/channel_layout.h</i> */
    public static final int AV_CH_LAYOUT_6POINT0 = (int)((((0x00000001 | 0x00000002) | 0x00000004) | 0x00000200 | 0x00000400) | 0x00000100);
    /** <i>native declaration : ffmpeg_build/include/libavutil/channel_layout.h</i> */
    public static final int AV_CH_LAYOUT_6POINT0_FRONT = (int)(((0x00000001 | 0x00000002) | 0x00000200 | 0x00000400) | 0x00000040 | 0x00000080);
    /** <i>native declaration : ffmpeg_build/include/libavutil/channel_layout.h</i> */
    public static final int AV_CH_LAYOUT_HEXAGONAL = (int)((((0x00000001 | 0x00000002) | 0x00000004) | 0x00000010 | 0x00000020) | 0x00000100);
    /** <i>native declaration : ffmpeg_build/include/libavutil/channel_layout.h</i> */
    public static final int AV_CH_LAYOUT_6POINT1 = (int)(((((0x00000001 | 0x00000002) | 0x00000004) | 0x00000200 | 0x00000400) | 0x00000008) | 0x00000100);
    /** <i>native declaration : ffmpeg_build/include/libavutil/channel_layout.h</i> */
    public static final int AV_CH_LAYOUT_6POINT1_BACK = (int)(((((0x00000001 | 0x00000002) | 0x00000004) | 0x00000010 | 0x00000020) | 0x00000008) | 0x00000100);
    /** <i>native declaration : ffmpeg_build/include/libavutil/channel_layout.h</i> */
    public static final int AV_CH_LAYOUT_6POINT1_FRONT = (int)((((0x00000001 | 0x00000002) | 0x00000200 | 0x00000400) | 0x00000040 | 0x00000080) | 0x00000008);
    /** <i>native declaration : ffmpeg_build/include/libavutil/channel_layout.h</i> */
    public static final int AV_CH_LAYOUT_7POINT0 = (int)((((0x00000001 | 0x00000002) | 0x00000004) | 0x00000200 | 0x00000400) | 0x00000010 | 0x00000020);
    /** <i>native declaration : ffmpeg_build/include/libavutil/channel_layout.h</i> */
    public static final int AV_CH_LAYOUT_7POINT0_FRONT = (int)((((0x00000001 | 0x00000002) | 0x00000004) | 0x00000200 | 0x00000400) | 0x00000040 | 0x00000080);
    /** <i>native declaration : ffmpeg_build/include/libavutil/channel_layout.h</i> */
    public static final int AV_CH_LAYOUT_7POINT1 = (int)(((((0x00000001 | 0x00000002) | 0x00000004) | 0x00000200 | 0x00000400) | 0x00000008) | 0x00000010 | 0x00000020);
    /** <i>native declaration : ffmpeg_build/include/libavutil/channel_layout.h</i> */
    public static final int AV_CH_LAYOUT_7POINT1_WIDE = (int)(((((0x00000001 | 0x00000002) | 0x00000004) | 0x00000200 | 0x00000400) | 0x00000008) | 0x00000040 | 0x00000080);
    /** <i>native declaration : ffmpeg_build/include/libavutil/channel_layout.h</i> */
    public static final int AV_CH_LAYOUT_7POINT1_WIDE_BACK = (int)(((((0x00000001 | 0x00000002) | 0x00000004) | 0x00000010 | 0x00000020) | 0x00000008) | 0x00000040 | 0x00000080);
    /** <i>native declaration : ffmpeg_build/include/libavutil/channel_layout.h</i> */
    public static final int AV_CH_LAYOUT_OCTAGONAL = (int)((((0x00000001 | 0x00000002) | 0x00000004) | 0x00000200 | 0x00000400) | 0x00000010 | 0x00000100 | 0x00000020);
    /** <i>native declaration : ffmpeg_build/include/libavutil/channel_layout.h</i> */
    public static final long AV_CH_LAYOUT_HEXADECAGONAL = (long)(((((0x00000001 | 0x00000002) | 0x00000004) | 0x00000200 | 0x00000400) | 0x00000010 | 0x00000100 | 0x00000020) | 0x0000000080000000L | 0x0000000100000000L | 0x00008000 | 0x00020000 | 0x00010000 | 0x00002000 | 0x00001000 | 0x00004000);
    /** <i>native declaration : ffmpeg_build/include/libavutil/channel_layout.h</i> */
    public static final int AV_CH_LAYOUT_STEREO_DOWNMIX = (int)(0x20000000 | 0x40000000);
    /** <i>native declaration : ffmpeg_build/include/libavutil/dict.h</i> */
    public static final int AV_DICT_MATCH_CASE = (int)1;
    /** <i>native declaration : ffmpeg_build/include/libavutil/dict.h</i> */
    public static final int AV_DICT_IGNORE_SUFFIX = (int)2;
    /** <i>native declaration : ffmpeg_build/include/libavutil/dict.h</i> */
    public static final int AV_DICT_DONT_STRDUP_KEY = (int)4;
    /** <i>native declaration : ffmpeg_build/include/libavutil/dict.h</i> */
    public static final int AV_DICT_DONT_STRDUP_VAL = (int)8;
    /** <i>native declaration : ffmpeg_build/include/libavutil/dict.h</i> */
    public static final int AV_DICT_DONT_OVERWRITE = (int)16;
    /** <i>native declaration : ffmpeg_build/include/libavutil/dict.h</i> */
    public static final int AV_DICT_APPEND = (int)32;
    /** <i>native declaration : ffmpeg_build/include/libavutil/frame.h</i> */
    public static final int AV_NUM_DATA_POINTERS = (int)8;
    /** <i>native declaration : ffmpeg_build/include/libavutil/frame.h</i> */
    public static final int AV_FRAME_FLAG_CORRUPT = (int)(1 << 0);
    /** <i>native declaration : ffmpeg_build/include/libavutil/frame.h</i> */
    public static final int FF_DECODE_ERROR_INVALID_BITSTREAM = (int)1;
    /** <i>native declaration : ffmpeg_build/include/libavutil/frame.h</i> */
    public static final int FF_DECODE_ERROR_MISSING_REFERENCE = (int)2;
    /** <i>native declaration : ffmpeg_build/include/libavutil/opt.h</i> */
    public static final int AV_OPT_FLAG_ENCODING_PARAM = (int)1;
    /** <i>native declaration : ffmpeg_build/include/libavutil/opt.h</i> */
    public static final int AV_OPT_FLAG_DECODING_PARAM = (int)2;
    /** <i>native declaration : ffmpeg_build/include/libavutil/opt.h</i> */
    public static final int AV_OPT_FLAG_METADATA = (int)4;
    /** <i>native declaration : ffmpeg_build/include/libavutil/opt.h</i> */
    public static final int AV_OPT_FLAG_AUDIO_PARAM = (int)8;
    /** <i>native declaration : ffmpeg_build/include/libavutil/opt.h</i> */
    public static final int AV_OPT_FLAG_VIDEO_PARAM = (int)16;
    /** <i>native declaration : ffmpeg_build/include/libavutil/opt.h</i> */
    public static final int AV_OPT_FLAG_SUBTITLE_PARAM = (int)32;
    /** <i>native declaration : ffmpeg_build/include/libavutil/opt.h</i> */
    public static final int AV_OPT_FLAG_EXPORT = (int)64;
    /** <i>native declaration : ffmpeg_build/include/libavutil/opt.h</i> */
    public static final int AV_OPT_FLAG_READONLY = (int)128;
    /** <i>native declaration : ffmpeg_build/include/libavutil/opt.h</i> */
    public static final int AV_OPT_FLAG_FILTERING_PARAM = (int)(1 << 16);
    /** <i>native declaration : ffmpeg_build/include/libavutil/opt.h</i> */
    public static final int AV_OPT_SEARCH_CHILDREN = (int)(1 << 0);
    /** <i>native declaration : ffmpeg_build/include/libavutil/opt.h</i> */
    public static final int AV_OPT_SEARCH_FAKE_OBJ = (int)(1 << 1);
    /** <i>native declaration : ffmpeg_build/include/libavutil/opt.h</i> */
    public static final int AV_OPT_ALLOW_NULL = (int)(1 << 2);
    /** <i>native declaration : ffmpeg_build/include/libavutil/opt.h</i> */
    public static final int AV_OPT_MULTI_COMPONENT_RANGE = (int)(1 << 12);
    /** <i>native declaration : ffmpeg_build/include/libavutil/opt.h</i> */
    public static final int AV_OPT_SERIALIZE_SKIP_DEFAULTS = (int)0x00000001;
    /** <i>native declaration : ffmpeg_build/include/libavutil/opt.h</i> */
    public static final int AV_OPT_SERIALIZE_OPT_FLAGS_EXACT = (int)0x00000002;
    /** <i>native declaration : ffmpeg_build/include/libavutil/stereo3d.h</i> */
    public static final int AV_STEREO3D_FLAG_INVERT = (int)(1 << 0);
    /** <i>native declaration : ffmpeg_build/include/libavutil/timestamp.h</i> */
    public static final int AV_TS_MAX_STRING_SIZE = (int)32;
    /** <i>native declaration : ffmpeg_build/include/libavutil/hash.h</i> */
    public static final int AV_HASH_MAX_SIZE = (int)64;
    /** <i>native declaration : ffmpeg_build/include/libavutil/blowfish.h</i> */
    public static final int AV_BF_ROUNDS = (int)16;
    /** <i>native declaration : ffmpeg_build/include/libavutil/avstring.h</i> */
    public static final int AV_ESCAPE_FLAG_WHITESPACE = (int)(1 << 0);
    /** <i>native declaration : ffmpeg_build/include/libavutil/avstring.h</i> */
    public static final int AV_ESCAPE_FLAG_STRICT = (int)(1 << 1);
    /** <i>native declaration : ffmpeg_build/include/libavutil/avstring.h</i> */
    public static final int AV_UTF8_FLAG_ACCEPT_INVALID_BIG_CODES = (int)1;
    /** <i>native declaration : ffmpeg_build/include/libavutil/avstring.h</i> */
    public static final int AV_UTF8_FLAG_ACCEPT_NON_CHARACTERS = (int)2;
    /** <i>native declaration : ffmpeg_build/include/libavutil/avstring.h</i> */
    public static final int AV_UTF8_FLAG_ACCEPT_SURROGATES = (int)4;
    /** <i>native declaration : ffmpeg_build/include/libavutil/avstring.h</i> */
    public static final int AV_UTF8_FLAG_EXCLUDE_XML_INVALID_CONTROL_CODES = (int)8;
    /** <i>native declaration : ffmpeg_build/include/libavutil/avstring.h</i> */
    public static final int AV_UTF8_FLAG_ACCEPT_ALL = (int)(1 | 2 | 4);
    /** <i>native declaration : ffmpeg_build/include/libavutil/bprint.h</i> */
    public static final int AV_BPRINT_SIZE_UNLIMITED = (int)(-1);
    /** <i>native declaration : ffmpeg_build/include/libavutil/bprint.h</i> */
    public static final int AV_BPRINT_SIZE_AUTOMATIC = (int)1;
    /** <i>native declaration : ffmpeg_build/include/libavutil/bprint.h</i> */
    public static final int AV_BPRINT_SIZE_COUNT_ONLY = (int)0;
    /** <i>native declaration : ffmpeg_build/include/libavutil/timecode.h</i> */
    public static final int AV_TIMECODE_STR_SIZE = (int)16;
    /** <i>native declaration : ffmpeg_build/include/libavutil/pixdesc.h</i> */
    public static final int AV_PIX_FMT_FLAG_BE = (int)(1 << 0);
    /** <i>native declaration : ffmpeg_build/include/libavutil/pixdesc.h</i> */
    public static final int AV_PIX_FMT_FLAG_PAL = (int)(1 << 1);
    /** <i>native declaration : ffmpeg_build/include/libavutil/pixdesc.h</i> */
    public static final int AV_PIX_FMT_FLAG_BITSTREAM = (int)(1 << 2);
    /** <i>native declaration : ffmpeg_build/include/libavutil/pixdesc.h</i> */
    public static final int AV_PIX_FMT_FLAG_HWACCEL = (int)(1 << 3);
    /** <i>native declaration : ffmpeg_build/include/libavutil/pixdesc.h</i> */
    public static final int AV_PIX_FMT_FLAG_PLANAR = (int)(1 << 4);
    /** <i>native declaration : ffmpeg_build/include/libavutil/pixdesc.h</i> */
    public static final int AV_PIX_FMT_FLAG_RGB = (int)(1 << 5);
    /** <i>native declaration : ffmpeg_build/include/libavutil/pixdesc.h</i> */
    public static final int AV_PIX_FMT_FLAG_PSEUDOPAL = (int)(1 << 6);
    /** <i>native declaration : ffmpeg_build/include/libavutil/pixdesc.h</i> */
    public static final int AV_PIX_FMT_FLAG_ALPHA = (int)(1 << 7);
    /** <i>native declaration : ffmpeg_build/include/libavutil/pixdesc.h</i> */
    public static final int FF_LOSS_RESOLUTION = (int)0x0001;
    /** <i>native declaration : ffmpeg_build/include/libavutil/pixdesc.h</i> */
    public static final int FF_LOSS_DEPTH = (int)0x0002;
    /** <i>native declaration : ffmpeg_build/include/libavutil/pixdesc.h</i> */
    public static final int FF_LOSS_COLORSPACE = (int)0x0004;
    /** <i>native declaration : ffmpeg_build/include/libavutil/pixdesc.h</i> */
    public static final int FF_LOSS_ALPHA = (int)0x0008;
    /** <i>native declaration : ffmpeg_build/include/libavutil/pixdesc.h</i> */
    public static final int FF_LOSS_COLORQUANT = (int)0x0010;
    /** <i>native declaration : ffmpeg_build/include/libavutil/pixdesc.h</i> */
    public static final int FF_LOSS_CHROMA = (int)0x0020;
    /** <i>native declaration : ffmpeg_build/include/libavutil/ffversion.h</i> */
    public static final String FFMPEG_VERSION = (String)"N-76131-g416e35e";
    /** <i>native declaration : ffmpeg_build/include/libavutil/lzo.h</i> */
    public static final int AV_LZO_INPUT_DEPLETED = (int)1;
    /** <i>native declaration : ffmpeg_build/include/libavutil/lzo.h</i> */
    public static final int AV_LZO_OUTPUT_FULL = (int)2;
    /** <i>native declaration : ffmpeg_build/include/libavutil/lzo.h</i> */
    public static final int AV_LZO_INVALID_BACKPTR = (int)4;
    /** <i>native declaration : ffmpeg_build/include/libavutil/lzo.h</i> */
    public static final int AV_LZO_ERROR = (int)8;
    /** <i>native declaration : ffmpeg_build/include/libavutil/lzo.h</i> */
    public static final int AV_LZO_INPUT_PADDING = (int)8;
    /** <i>native declaration : ffmpeg_build/include/libavutil/lzo.h</i> */
    public static final int AV_LZO_OUTPUT_PADDING = (int)12;
    /** <i>native declaration : ffmpeg_build/include/libavutil/log.h:138</i> */
    public static abstract class av_log_set_callback_callback_callback extends Callback<av_log_set_callback_callback_callback > {
        public void apply(Pointer<? > voidPtr1, int int1, Pointer<Byte > charPtr1, Object... va_list1) {
            apply(Pointer.getPeer(voidPtr1), int1, Pointer.getPeer(charPtr1), va_list1);
        }
        public void apply(@Ptr long voidPtr1, int int1, @Ptr long charPtr1, Object... va_list1) {
            apply(Pointer.pointerToAddress(voidPtr1), int1, (Pointer)Pointer.pointerToAddress(charPtr1, Byte.class), va_list1);
        }
    };
    /** <i>native declaration : ffmpeg_build/include/libavutil/buffer.h:136</i> */
    public static abstract class av_buffer_create_free_callback extends Callback<av_buffer_create_free_callback > {
        public void apply(Pointer<? > opaque, Pointer<Byte > data) {
            apply(Pointer.getPeer(opaque), Pointer.getPeer(data));
        }
        public void apply(@Ptr long opaque, @Ptr long data) {
            apply(Pointer.pointerToAddress(opaque), (Pointer)Pointer.pointerToAddress(data, Byte.class));
        }
    };
    /** <i>native declaration : ffmpeg_build/include/libavutil/buffer.h:137</i> */
    public static abstract class av_buffer_pool_init_alloc_callback extends Callback<av_buffer_pool_init_alloc_callback > {
        public Pointer<AVBufferRef > apply(int size) {
            return (Pointer)Pointer.pointerToAddress(apply$2(size), AVBufferRef.class);
        }
        @Ptr
        public long apply$2(int size) {
            return Pointer.getPeer(apply(size));
        }
    };
    /** <i>native declaration : ffmpeg_build/include/libavutil/eval.h:69</i> */
    public static abstract class av_expr_parse_and_eval_funcs1_callback extends Callback<av_expr_parse_and_eval_funcs1_callback > {
        public double apply(Pointer<? > voidPtr1, double double1) {
            return apply(Pointer.getPeer(voidPtr1), double1);
        }
        public double apply(@Ptr long voidPtr1, double double1) {
            return apply(Pointer.pointerToAddress(voidPtr1), double1);
        }
    };
    /** <i>native declaration : ffmpeg_build/include/libavutil/eval.h:70</i> */
    public static abstract class av_expr_parse_and_eval_funcs2_callback extends Callback<av_expr_parse_and_eval_funcs2_callback > {
        public double apply(Pointer<? > voidPtr1, double double1, double double2) {
            return apply(Pointer.getPeer(voidPtr1), double1, double2);
        }
        public double apply(@Ptr long voidPtr1, double double1, double double2) {
            return apply(Pointer.pointerToAddress(voidPtr1), double1, double2);
        }
    };
    /** <i>native declaration : ffmpeg_build/include/libavutil/eval.h:71</i> */
    public static abstract class av_expr_parse_funcs1_callback extends Callback<av_expr_parse_funcs1_callback > {
        public double apply(Pointer<? > voidPtr1, double double1) {
            return apply(Pointer.getPeer(voidPtr1), double1);
        }
        public double apply(@Ptr long voidPtr1, double double1) {
            return apply(Pointer.pointerToAddress(voidPtr1), double1);
        }
    };
    /** <i>native declaration : ffmpeg_build/include/libavutil/eval.h:72</i> */
    public static abstract class av_expr_parse_funcs2_callback extends Callback<av_expr_parse_funcs2_callback > {
        public double apply(Pointer<? > voidPtr1, double double1, double double2) {
            return apply(Pointer.getPeer(voidPtr1), double1, double2);
        }
        public double apply(@Ptr long voidPtr1, double double1, double double2) {
            return apply(Pointer.pointerToAddress(voidPtr1), double1, double2);
        }
    };
    /** <i>native declaration : ffmpeg_build/include/libavutil/pixelutils.h:1</i> */
    public static abstract class av_pixelutils_sad_fn extends Callback<av_pixelutils_sad_fn > {
        public int apply(Pointer<Byte > src1, @Ptr long stride1, Pointer<Byte > src2, @Ptr long stride2) {
            return apply(Pointer.getPeer(src1), stride1, Pointer.getPeer(src2), stride2);
        }
        public int apply(@Ptr long src1, @Ptr long stride1, @Ptr long src2, @Ptr long stride2) {
            return apply((Pointer)Pointer.pointerToAddress(src1, Byte.class), stride1, (Pointer)Pointer.pointerToAddress(src2, Byte.class), stride2);
        }
    };
    /** <i>native declaration : ffmpeg_build/include/libavutil/fifo.h:147</i> */
    public static abstract class av_fifo_generic_peek_at_func_callback extends Callback<av_fifo_generic_peek_at_func_callback > {
        public void apply(Pointer<? > voidPtr1, Pointer<? > voidPtr2, int int1) {
            apply(Pointer.getPeer(voidPtr1), Pointer.getPeer(voidPtr2), int1);
        }
        public void apply(@Ptr long voidPtr1, @Ptr long voidPtr2, int int1) {
            apply(Pointer.pointerToAddress(voidPtr1), Pointer.pointerToAddress(voidPtr2), int1);
        }
    };
    /** <i>native declaration : ffmpeg_build/include/libavutil/fifo.h:148</i> */
    public static abstract class av_fifo_generic_peek_func_callback extends Callback<av_fifo_generic_peek_func_callback > {
        public void apply(Pointer<? > voidPtr1, Pointer<? > voidPtr2, int int1) {
            apply(Pointer.getPeer(voidPtr1), Pointer.getPeer(voidPtr2), int1);
        }
        public void apply(@Ptr long voidPtr1, @Ptr long voidPtr2, int int1) {
            apply(Pointer.pointerToAddress(voidPtr1), Pointer.pointerToAddress(voidPtr2), int1);
        }
    };
    /** <i>native declaration : ffmpeg_build/include/libavutil/fifo.h:149</i> */
    public static abstract class av_fifo_generic_read_func_callback extends Callback<av_fifo_generic_read_func_callback > {
        public void apply(Pointer<? > voidPtr1, Pointer<? > voidPtr2, int int1) {
            apply(Pointer.getPeer(voidPtr1), Pointer.getPeer(voidPtr2), int1);
        }
        public void apply(@Ptr long voidPtr1, @Ptr long voidPtr2, int int1) {
            apply(Pointer.pointerToAddress(voidPtr1), Pointer.pointerToAddress(voidPtr2), int1);
        }
    };
    /** <i>native declaration : ffmpeg_build/include/libavutil/fifo.h:150</i> */
    public static abstract class av_fifo_generic_write_func_callback extends Callback<av_fifo_generic_write_func_callback > {
        public int apply(Pointer<? > voidPtr1, Pointer<? > voidPtr2, int int1) {
            return apply(Pointer.getPeer(voidPtr1), Pointer.getPeer(voidPtr2), int1);
        }
        public int apply(@Ptr long voidPtr1, @Ptr long voidPtr2, int int1) {
            return apply(Pointer.pointerToAddress(voidPtr1), Pointer.pointerToAddress(voidPtr2), int1);
        }
    };
    /**
     * Return the LIBAVUTIL_VERSION_INT constant.<br>
     * Original signature : <code>int avutil_version()</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/avutil.h:4</i>
     */
    public native int avutil_version();
    /**
     * Return an informative version string. This usually is the actual release<br>
     * version number or a git commit description. This string has no fixed format<br>
     * and can change any time. It should never be parsed by code.<br>
     * Original signature : <code>char* av_version_info()</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/avutil.h:11</i>
     */
    public Pointer<Byte > av_version_info() {
        return (Pointer)Pointer.pointerToAddress(av_version_info$2(), Byte.class);
    }
    @Ptr
    @Name("av_version_info")
    protected native long av_version_info$2();
    /**
     * Return the libavutil build-time configuration.<br>
     * Original signature : <code>char* avutil_configuration()</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/avutil.h:16</i>
     */
    public Pointer<Byte > avutil_configuration() {
        return (Pointer)Pointer.pointerToAddress(avutil_configuration$2(), Byte.class);
    }
    @Ptr
    @Name("avutil_configuration")
    protected native long avutil_configuration$2();
    /**
     * Return the libavutil license.<br>
     * Original signature : <code>char* avutil_license()</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/avutil.h:21</i>
     */
    public Pointer<Byte > avutil_license() {
        return (Pointer)Pointer.pointerToAddress(avutil_license$2(), Byte.class);
    }
    @Ptr
    @Name("avutil_license")
    protected native long avutil_license$2();
    /**
     * Return a string describing the media_type enum, NULL if media_type<br>
     * is unknown.<br>
     * Original signature : <code>char* av_get_media_type_string(AVMediaType)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/avutil.h:43</i>
     */
    public Pointer<Byte > av_get_media_type_string(IntValuedEnum<AvutilLibrary.AVMediaType > media_type) {
        return (Pointer)Pointer.pointerToAddress(av_get_media_type_string((int)media_type.value()), Byte.class);
    }
    @Ptr
    protected native long av_get_media_type_string(int media_type);
    /**
     * Return a single letter to describe the given picture type<br>
     * pict_type.<br>
     * @param[in] pict_type the picture type @return a single character<br>
     * representing the picture type, '?' if pict_type is unknown<br>
     * Original signature : <code>char av_get_picture_type_char(AVPictureType)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/avutil.h:76</i>
     */
    public byte av_get_picture_type_char(IntValuedEnum<AvutilLibrary.AVPictureType > pict_type) {
        return av_get_picture_type_char((int)pict_type.value());
    }
    protected native byte av_get_picture_type_char(int pict_type);
    /**
     * Original signature : <code>int av_log2(unsigned)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/common.h:1</i>
     */
    public native int av_log2(int v);
    /**
     * Original signature : <code>int av_log2_16bit(unsigned)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/common.h:3</i>
     */
    public native int av_log2_16bit(int v);
    /**
     * Put a description of the AVERROR code errnum in errbuf.<br>
     * In case of failure the global variable errno is set to indicate the<br>
     * error. Even in case of failure av_strerror() will print a generic<br>
     * error message indicating the errnum provided to errbuf.<br>
     * @param errnum      error code to describe<br>
     * @param errbuf      buffer to which description is written<br>
     * @param errbuf_size the size in bytes of errbuf<br>
     * @return 0 on success, a negative value if a description for errnum<br>
     * cannot be found<br>
     * Original signature : <code>int av_strerror(int, char*, size_t)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/error.h:12</i>
     */
    public int av_strerror(int errnum, Pointer<Byte > errbuf, @Ptr long errbuf_size) {
        return av_strerror(errnum, Pointer.getPeer(errbuf), errbuf_size);
    }
    protected native int av_strerror(int errnum, @Ptr long errbuf, @Ptr long errbuf_size);
    /**
     * Allocate a block of size bytes with alignment suitable for all<br>
     * memory accesses (including vectors if available on the CPU).<br>
     * @param size Size in bytes for the memory block to be allocated.<br>
     * @return Pointer to the allocated block, NULL if the block cannot<br>
     * be allocated.<br>
     * @see av_mallocz()<br>
     * Original signature : <code>void* av_malloc(size_t)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/mem.h:9</i>
     */
    public Pointer<? > av_malloc(@Ptr long size) {
        return Pointer.pointerToAddress(av_malloc$2(size));
    }
    @Ptr
    @Name("av_malloc")
    protected native long av_malloc$2(@Ptr long size);
    /**
     * Allocate or reallocate a block of memory.<br>
     * If ptr is NULL and size > 0, allocate a new block. If<br>
     * size is zero, free the memory block pointed to by ptr.<br>
     * @param ptr Pointer to a memory block already allocated with<br>
     * av_realloc() or NULL.<br>
     * @param size Size in bytes of the memory block to be allocated or<br>
     * reallocated.<br>
     * @return Pointer to a newly-reallocated block or NULL if the block<br>
     * cannot be reallocated or the function is used to free the memory block.<br>
     * @warning Pointers originating from the av_malloc() family of functions must<br>
     *          not be passed to av_realloc(). The former can be implemented using<br>
     *          memalign() (or other functions), and there is no guarantee that<br>
     *          pointers from such functions can be passed to realloc() at all.<br>
     *          The situation is undefined according to POSIX and may crash with<br>
     *          some libc implementations.<br>
     * @see av_fast_realloc()<br>
     * Original signature : <code>void* av_realloc(void*, size_t)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/mem.h:43</i>
     */
    public Pointer<? > av_realloc(Pointer<? > ptr, @Ptr long size) {
        return Pointer.pointerToAddress(av_realloc(Pointer.getPeer(ptr), size));
    }
    @Ptr
    protected native long av_realloc(@Ptr long ptr, @Ptr long size);
    /**
     * Allocate or reallocate a block of memory.<br>
     * This function does the same thing as av_realloc, except:<br>
     * - It takes two arguments and checks the result of the multiplication for<br>
     *   integer overflow.<br>
     * - It frees the input block in case of failure, thus avoiding the memory<br>
     *   leak with the classic "buf = realloc(buf); if (!buf) return -1;".<br>
     * Original signature : <code>void* av_realloc_f(void*, size_t, size_t)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/mem.h:53</i>
     */
    public Pointer<? > av_realloc_f(Pointer<? > ptr, @Ptr long nelem, @Ptr long elsize) {
        return Pointer.pointerToAddress(av_realloc_f(Pointer.getPeer(ptr), nelem, elsize));
    }
    @Ptr
    protected native long av_realloc_f(@Ptr long ptr, @Ptr long nelem, @Ptr long elsize);
    /**
     * Allocate or reallocate a block of memory.<br>
     * If *ptr is NULL and size > 0, allocate a new block. If<br>
     * size is zero, free the memory block pointed to by ptr.<br>
     * @param   ptr Pointer to a pointer to a memory block already allocated<br>
     *          with av_realloc(), or pointer to a pointer to NULL.<br>
     *          The pointer is updated on success, or freed on failure.<br>
     * @param   size Size in bytes for the memory block to be allocated or<br>
     *          reallocated<br>
     * @return  Zero on success, an AVERROR error code on failure.<br>
     * @warning Pointers originating from the av_malloc() family of functions must<br>
     *          not be passed to av_reallocp(). The former can be implemented using<br>
     *          memalign() (or other functions), and there is no guarantee that<br>
     *          pointers from such functions can be passed to realloc() at all.<br>
     *          The situation is undefined according to POSIX and may crash with<br>
     *          some libc implementations.<br>
     * Original signature : <code>int av_reallocp(void*, size_t)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/mem.h:72</i>
     */
    public int av_reallocp(Pointer<? > ptr, @Ptr long size) {
        return av_reallocp(Pointer.getPeer(ptr), size);
    }
    protected native int av_reallocp(@Ptr long ptr, @Ptr long size);
    /**
     * Allocate or reallocate an array.<br>
     * If ptr is NULL and nmemb > 0, allocate a new block. If<br>
     * nmemb is zero, free the memory block pointed to by ptr.<br>
     * @param ptr Pointer to a memory block already allocated with<br>
     * av_realloc() or NULL.<br>
     * @param nmemb Number of elements<br>
     * @param size Size of the single element<br>
     * @return Pointer to a newly-reallocated block or NULL if the block<br>
     * cannot be reallocated or the function is used to free the memory block.<br>
     * @warning Pointers originating from the av_malloc() family of functions must<br>
     *          not be passed to av_realloc(). The former can be implemented using<br>
     *          memalign() (or other functions), and there is no guarantee that<br>
     *          pointers from such functions can be passed to realloc() at all.<br>
     *          The situation is undefined according to POSIX and may crash with<br>
     *          some libc implementations.<br>
     * Original signature : <code>void* av_realloc_array(void*, size_t, size_t)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/mem.h:91</i>
     */
    public Pointer<? > av_realloc_array(Pointer<? > ptr, @Ptr long nmemb, @Ptr long size) {
        return Pointer.pointerToAddress(av_realloc_array(Pointer.getPeer(ptr), nmemb, size));
    }
    @Ptr
    protected native long av_realloc_array(@Ptr long ptr, @Ptr long nmemb, @Ptr long size);
    /**
     * Allocate or reallocate an array through a pointer to a pointer.<br>
     * If *ptr is NULL and nmemb > 0, allocate a new block. If<br>
     * nmemb is zero, free the memory block pointed to by ptr.<br>
     * @param ptr Pointer to a pointer to a memory block already allocated<br>
     * with av_realloc(), or pointer to a pointer to NULL.<br>
     * The pointer is updated on success, or freed on failure.<br>
     * @param nmemb Number of elements<br>
     * @param size Size of the single element<br>
     * @return Zero on success, an AVERROR error code on failure.<br>
     * @warning Pointers originating from the av_malloc() family of functions must<br>
     *          not be passed to av_realloc(). The former can be implemented using<br>
     *          memalign() (or other functions), and there is no guarantee that<br>
     *          pointers from such functions can be passed to realloc() at all.<br>
     *          The situation is undefined according to POSIX and may crash with<br>
     *          some libc implementations.<br>
     * Original signature : <code>int av_reallocp_array(void*, size_t, size_t)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/mem.h:110</i>
     */
    public int av_reallocp_array(Pointer<? > ptr, @Ptr long nmemb, @Ptr long size) {
        return av_reallocp_array(Pointer.getPeer(ptr), nmemb, size);
    }
    protected native int av_reallocp_array(@Ptr long ptr, @Ptr long nmemb, @Ptr long size);
    /**
     * Free a memory block which has been allocated with av_malloc(z)() or<br>
     * av_realloc().<br>
     * @param ptr Pointer to the memory block which should be freed.<br>
     * @note ptr = NULL is explicitly allowed.<br>
     * @note It is recommended that you use av_freep() instead.<br>
     * @see av_freep()<br>
     * Original signature : <code>void av_free(void*)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/mem.h:120</i>
     */
    public void av_free(Pointer<? > ptr) {
        av_free(Pointer.getPeer(ptr));
    }
    protected native void av_free(@Ptr long ptr);
    /**
     * Allocate a block of size bytes with alignment suitable for all<br>
     * memory accesses (including vectors if available on the CPU) and<br>
     * zero all the bytes of the block.<br>
     * @param size Size in bytes for the memory block to be allocated.<br>
     * @return Pointer to the allocated block, NULL if it cannot be allocated.<br>
     * @see av_malloc()<br>
     * Original signature : <code>void* av_mallocz(size_t)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/mem.h:130</i>
     */
    public Pointer<? > av_mallocz(@Ptr long size) {
        return Pointer.pointerToAddress(av_mallocz$2(size));
    }
    @Ptr
    @Name("av_mallocz")
    protected native long av_mallocz$2(@Ptr long size);
    /**
     * Allocate a block of nmemb * size bytes with alignment suitable for all<br>
     * memory accesses (including vectors if available on the CPU) and<br>
     * zero all the bytes of the block.<br>
     * The allocation will fail if nmemb * size is greater than or equal<br>
     * to INT_MAX.<br>
     * @param nmemb<br>
     * @param size<br>
     * @return Pointer to the allocated block, NULL if it cannot be allocated.<br>
     * Original signature : <code>void* av_calloc(size_t, size_t)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/mem.h:142</i>
     */
    public Pointer<? > av_calloc(@Ptr long nmemb, @Ptr long size) {
        return Pointer.pointerToAddress(av_calloc$2(nmemb, size));
    }
    @Ptr
    @Name("av_calloc")
    protected native long av_calloc$2(@Ptr long nmemb, @Ptr long size);
    /**
     * Duplicate the string s.<br>
     * @param s string to be duplicated<br>
     * @return Pointer to a newly-allocated string containing a<br>
     * copy of s or NULL if the string cannot be allocated.<br>
     * Original signature : <code>char* av_strdup(const char*)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/mem.h:165</i>
     */
    public Pointer<Byte > av_strdup(Pointer<Byte > s) {
        return (Pointer)Pointer.pointerToAddress(av_strdup(Pointer.getPeer(s)), Byte.class);
    }
    @Ptr
    protected native long av_strdup(@Ptr long s);
    /**
     * Duplicate a substring of the string s.<br>
     * @param s string to be duplicated<br>
     * @param len the maximum length of the resulting string (not counting the<br>
     *            terminating byte).<br>
     * @return Pointer to a newly-allocated string containing a<br>
     * copy of s or NULL if the string cannot be allocated.<br>
     * Original signature : <code>char* av_strndup(const char*, size_t)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/mem.h:175</i>
     */
    public Pointer<Byte > av_strndup(Pointer<Byte > s, @Ptr long len) {
        return (Pointer)Pointer.pointerToAddress(av_strndup(Pointer.getPeer(s), len), Byte.class);
    }
    @Ptr
    protected native long av_strndup(@Ptr long s, @Ptr long len);
    /**
     * Duplicate the buffer p.<br>
     * @param p buffer to be duplicated<br>
     * @return Pointer to a newly allocated buffer containing a<br>
     * copy of p or NULL if the buffer cannot be allocated.<br>
     * Original signature : <code>void* av_memdup(const void*, size_t)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/mem.h:183</i>
     */
    public Pointer<? > av_memdup(Pointer<? > p, @Ptr long size) {
        return Pointer.pointerToAddress(av_memdup(Pointer.getPeer(p), size));
    }
    @Ptr
    protected native long av_memdup(@Ptr long p, @Ptr long size);
    /**
     * Free a memory block which has been allocated with av_malloc(z)() or<br>
     * av_realloc() and set the pointer pointing to it to NULL.<br>
     * @param ptr Pointer to the pointer to the memory block which should<br>
     * be freed.<br>
     * @note passing a pointer to a NULL pointer is safe and leads to no action.<br>
     * @see av_free()<br>
     * Original signature : <code>void av_freep(void*)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/mem.h:193</i>
     */
    public void av_freep(Pointer<? > ptr) {
        av_freep(Pointer.getPeer(ptr));
    }
    protected native void av_freep(@Ptr long ptr);
    /**
     * Add an element to a dynamic array.<br>
     * The array to grow is supposed to be an array of pointers to<br>
     * structures, and the element to add must be a pointer to an already<br>
     * allocated structure.<br>
     * The array is reallocated when its size reaches powers of 2.<br>
     * Therefore, the amortized cost of adding an element is constant.<br>
     * In case of success, the pointer to the array is updated in order to<br>
     * point to the new grown array, and the number pointed to by nb_ptr<br>
     * is incremented.<br>
     * In case of failure, the array is freed, *tab_ptr is set to NULL and<br>
     * *nb_ptr is set to 0.<br>
     * @param tab_ptr pointer to the array to grow<br>
     * @param nb_ptr  pointer to the number of elements in the array<br>
     * @param elem    element to add<br>
     * @see av_dynarray_add_nofree(), av_dynarray2_add()<br>
     * Original signature : <code>void av_dynarray_add(void*, int*, void*)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/mem.h:212</i>
     */
    public void av_dynarray_add(Pointer<? > tab_ptr, Pointer<Integer > nb_ptr, Pointer<? > elem) {
        av_dynarray_add(Pointer.getPeer(tab_ptr), Pointer.getPeer(nb_ptr), Pointer.getPeer(elem));
    }
    protected native void av_dynarray_add(@Ptr long tab_ptr, @Ptr long nb_ptr, @Ptr long elem);
    /**
     * Add an element to a dynamic array.<br>
     * Function has the same functionality as av_dynarray_add(),<br>
     * but it doesn't free memory on fails. It returns error code<br>
     * instead and leave current buffer untouched.<br>
     * @param tab_ptr pointer to the array to grow<br>
     * @param nb_ptr  pointer to the number of elements in the array<br>
     * @param elem    element to add<br>
     * @return >=0 on success, negative otherwise.<br>
     * @see av_dynarray_add(), av_dynarray2_add()<br>
     * Original signature : <code>int av_dynarray_add_nofree(void*, int*, void*)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/mem.h:225</i>
     */
    public int av_dynarray_add_nofree(Pointer<? > tab_ptr, Pointer<Integer > nb_ptr, Pointer<? > elem) {
        return av_dynarray_add_nofree(Pointer.getPeer(tab_ptr), Pointer.getPeer(nb_ptr), Pointer.getPeer(elem));
    }
    protected native int av_dynarray_add_nofree(@Ptr long tab_ptr, @Ptr long nb_ptr, @Ptr long elem);
    /**
     * Add an element of size elem_size to a dynamic array.<br>
     * The array is reallocated when its number of elements reaches powers of 2.<br>
     * Therefore, the amortized cost of adding an element is constant.<br>
     * In case of success, the pointer to the array is updated in order to<br>
     * point to the new grown array, and the number pointed to by nb_ptr<br>
     * is incremented.<br>
     * In case of failure, the array is freed, *tab_ptr is set to NULL and<br>
     * *nb_ptr is set to 0.<br>
     * @param tab_ptr   pointer to the array to grow<br>
     * @param nb_ptr    pointer to the number of elements in the array<br>
     * @param elem_size size in bytes of the elements in the array<br>
     * @param elem_data pointer to the data of the element to add. If NULL, the space of<br>
     *                  the new added element is not filled.<br>
     * @return          pointer to the data of the element to copy in the new allocated space.<br>
     *                  If NULL, the new allocated space is left uninitialized."<br>
     * @see av_dynarray_add(), av_dynarray_add_nofree()<br>
     * Original signature : <code>void* av_dynarray2_add(void**, int*, size_t, const uint8_t*)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/mem.h:245</i>
     */
    public Pointer<? > av_dynarray2_add(Pointer<Pointer<? > > tab_ptr, Pointer<Integer > nb_ptr, @Ptr long elem_size, Pointer<Byte > elem_data) {
        return Pointer.pointerToAddress(av_dynarray2_add(Pointer.getPeer(tab_ptr), Pointer.getPeer(nb_ptr), elem_size, Pointer.getPeer(elem_data)));
    }
    @Ptr
    protected native long av_dynarray2_add(@Ptr long tab_ptr, @Ptr long nb_ptr, @Ptr long elem_size, @Ptr long elem_data);
    /**
     * Set the maximum size that may me allocated in one block.<br>
     * Original signature : <code>void av_max_alloc(size_t)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/mem.h:262</i>
     */
    public native void av_max_alloc(@Ptr long max);
    /**
     * deliberately overlapping memcpy implementation<br>
     * @param dst destination buffer<br>
     * @param back how many bytes back we start (the initial size of the overlapping window), must be > 0<br>
     * @param cnt number of bytes to copy, must be >= 0<br>
     * cnt > back is valid, this will copy the bytes we just copied,<br>
     * thus creating a repeating pattern with a period length of back.<br>
     * Original signature : <code>void av_memcpy_backptr(uint8_t*, int, int)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/mem.h:272</i>
     */
    public void av_memcpy_backptr(Pointer<Byte > dst, int back, int cnt) {
        av_memcpy_backptr(Pointer.getPeer(dst), back, cnt);
    }
    protected native void av_memcpy_backptr(@Ptr long dst, int back, int cnt);
    /**
     * Reallocate the given block if it is not large enough, otherwise do nothing.<br>
     * @see av_realloc<br>
     * Original signature : <code>void* av_fast_realloc(void*, unsigned int*, size_t)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/mem.h:278</i>
     */
    public Pointer<? > av_fast_realloc(Pointer<? > ptr, Pointer<Integer > size, @Ptr long min_size) {
        return Pointer.pointerToAddress(av_fast_realloc(Pointer.getPeer(ptr), Pointer.getPeer(size), min_size));
    }
    @Ptr
    protected native long av_fast_realloc(@Ptr long ptr, @Ptr long size, @Ptr long min_size);
    /**
     * Allocate a buffer, reusing the given one if large enough.<br>
     * Contrary to av_fast_realloc the current buffer contents might not be<br>
     * preserved and on error the old buffer is freed, thus no special<br>
     * handling to avoid memleaks is necessary.<br>
     * @param ptr pointer to pointer to already allocated buffer, overwritten with pointer to new buffer<br>
     * @param size size of the buffer *ptr points to<br>
     * @param min_size minimum size of *ptr buffer after returning, *ptr will be NULL and<br>
     *                 *size 0 if an error occurred.<br>
     * Original signature : <code>void av_fast_malloc(void*, unsigned int*, size_t)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/mem.h:290</i>
     */
    public void av_fast_malloc(Pointer<? > ptr, Pointer<Integer > size, @Ptr long min_size) {
        av_fast_malloc(Pointer.getPeer(ptr), Pointer.getPeer(size), min_size);
    }
    protected native void av_fast_malloc(@Ptr long ptr, @Ptr long size, @Ptr long min_size);
    /**
     * Reduce a fraction.<br>
     * This is useful for framerate calculations.<br>
     * @param dst_num destination numerator<br>
     * @param dst_den destination denominator<br>
     * @param num source numerator<br>
     * @param den source denominator<br>
     * @param max the maximum allowed for dst_num & dst_den<br>
     * @return 1 if exact, 0 otherwise<br>
     * Original signature : <code>int av_reduce(int*, int*, int64_t, int64_t, int64_t)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/rational.h:58</i>
     */
    public int av_reduce(Pointer<Integer > dst_num, Pointer<Integer > dst_den, long num, long den, long max) {
        return av_reduce(Pointer.getPeer(dst_num), Pointer.getPeer(dst_den), num, den, max);
    }
    protected native int av_reduce(@Ptr long dst_num, @Ptr long dst_den, long num, long den, long max);
    /**
     * Multiply two rationals.<br>
     * @param b first rational<br>
     * @param c second rational<br>
     * @return b*c<br>
     * Original signature : <code>AVRational av_mul_q(AVRational, AVRational)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/rational.h:66</i>
     */
    public native AVRational av_mul_q(AVRational b, AVRational c);
    /**
     * Divide one rational by another.<br>
     * @param b first rational<br>
     * @param c second rational<br>
     * @return b/c<br>
     * Original signature : <code>AVRational av_div_q(AVRational, AVRational)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/rational.h:74</i>
     */
    public native AVRational av_div_q(AVRational b, AVRational c);
    /**
     * Add two rationals.<br>
     * @param b first rational<br>
     * @param c second rational<br>
     * @return b+c<br>
     * Original signature : <code>AVRational av_add_q(AVRational, AVRational)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/rational.h:82</i>
     */
    public native AVRational av_add_q(AVRational b, AVRational c);
    /**
     * Subtract one rational from another.<br>
     * @param b first rational<br>
     * @param c second rational<br>
     * @return b-c<br>
     * Original signature : <code>AVRational av_sub_q(AVRational, AVRational)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/rational.h:90</i>
     */
    public native AVRational av_sub_q(AVRational b, AVRational c);
    /**
     * Convert a double precision floating point number to a rational.<br>
     * inf is expressed as {1,0} or {-1,0} depending on the sign.<br>
     * @param d double to convert<br>
     * @param max the maximum allowed numerator and denominator<br>
     * @return (AVRational) d<br>
     * Original signature : <code>AVRational av_d2q(double, int)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/rational.h:109</i>
     */
    public native AVRational av_d2q(double d, int max);
    /**
     * @return 1 if q1 is nearer to q than q2, -1 if q2 is nearer<br>
     * than q1, 0 if they have the same distance.<br>
     * Original signature : <code>int av_nearer_q(AVRational, AVRational, AVRational)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/rational.h:115</i>
     */
    public native int av_nearer_q(AVRational q, AVRational q1, AVRational q2);
    /**
     * Find the nearest value in q_list to q.<br>
     * @param q_list an array of rationals terminated by {0, 0}<br>
     * @return the index of the nearest value found in the array<br>
     * Original signature : <code>int av_find_nearest_q_idx(AVRational, const AVRational*)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/rational.h:122</i>
     */
    public int av_find_nearest_q_idx(AVRational q, Pointer<AVRational > q_list) {
        return av_find_nearest_q_idx(q, Pointer.getPeer(q_list));
    }
    protected native int av_find_nearest_q_idx(AVRational q, @Ptr long q_list);
    /**
     * Converts a AVRational to a IEEE 32bit float.<br>
     * The float is returned in a uint32_t and its value is platform indepenant.<br>
     * Original signature : <code>uint32_t av_q2intfloat(AVRational)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/rational.h:128</i>
     */
    public native int av_q2intfloat(AVRational q);
    /**
     * Return the greatest common divisor of a and b.<br>
     * If both a and b are 0 or either or both are <0 then behavior is<br>
     * undefined.<br>
     * Original signature : <code>int64_t av_gcd(int64_t, int64_t)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/mathematics.h:24</i>
     */
    public native long av_gcd(long a, long b);
    /**
     * Rescale a 64-bit integer with rounding to nearest.<br>
     * A simple a*b/c isn't possible as it can overflow.<br>
     * Original signature : <code>int64_t av_rescale(int64_t, int64_t, int64_t)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/mathematics.h:30</i>
     */
    public native long av_rescale(long a, long b, long c);
    /**
     * Rescale a 64-bit integer with specified rounding.<br>
     * A simple a*b/c isn't possible as it can overflow.<br>
     * @return rescaled value a, or if AV_ROUND_PASS_MINMAX is set and a is<br>
     *         INT64_MIN or INT64_MAX then a is passed through unchanged.<br>
     * Original signature : <code>int64_t av_rescale_rnd(int64_t, int64_t, int64_t, AVRounding)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/mathematics.h:38</i>
     */
    public long av_rescale_rnd(long a, long b, long c, IntValuedEnum<AvutilLibrary.AVRounding > arg1) {
        return av_rescale_rnd(a, b, c, (int)arg1.value());
    }
    protected native long av_rescale_rnd(long a, long b, long c, int arg1);
    /**
     * Rescale a 64-bit integer by 2 rational numbers.<br>
     * Original signature : <code>int64_t av_rescale_q(int64_t, AVRational, AVRational)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/mathematics.h:43</i>
     */
    public native long av_rescale_q(long a, AVRational bq, AVRational cq);
    /**
     * Rescale a 64-bit integer by 2 rational numbers with specified rounding.<br>
     * @return rescaled value a, or if AV_ROUND_PASS_MINMAX is set and a is<br>
     *         INT64_MIN or INT64_MAX then a is passed through unchanged.<br>
     * Original signature : <code>int64_t av_rescale_q_rnd(int64_t, AVRational, AVRational, AVRounding)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/mathematics.h:50</i>
     */
    public long av_rescale_q_rnd(long a, AVRational bq, AVRational cq, IntValuedEnum<AvutilLibrary.AVRounding > arg1) {
        return av_rescale_q_rnd(a, bq, cq, (int)arg1.value());
    }
    protected native long av_rescale_q_rnd(long a, AVRational bq, AVRational cq, int arg1);
    /**
     * Compare 2 timestamps each in its own timebases.<br>
     * The result of the function is undefined if one of the timestamps<br>
     * is outside the int64_t range when represented in the others timebase.<br>
     * @return -1 if ts_a is before ts_b, 1 if ts_a is after ts_b or 0 if they represent the same position<br>
     * Original signature : <code>int av_compare_ts(int64_t, AVRational, int64_t, AVRational)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/mathematics.h:58</i>
     */
    public native int av_compare_ts(long ts_a, AVRational tb_a, long ts_b, AVRational tb_b);
    /**
     * Compare 2 integers modulo mod.<br>
     * That is we compare integers a and b for which only the least<br>
     * significant log2(mod) bits are known.<br>
     * @param mod must be a power of 2<br>
     * @return a negative value if a is smaller than b<br>
     *         a positive value if a is greater than b<br>
     *         0                if a equals          b<br>
     * Original signature : <code>int64_t av_compare_mod(uint64_t, uint64_t, uint64_t)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/mathematics.h:69</i>
     */
    public native long av_compare_mod(long a, long b, long mod);
    /**
     * Rescale a timestamp while preserving known durations.<br>
     * @param in_ts Input timestamp<br>
     * @param in_tb Input timebase<br>
     * @param fs_tb Duration and *last timebase<br>
     * @param duration duration till the next call<br>
     * @param out_tb Output timebase<br>
     * Original signature : <code>int64_t av_rescale_delta(AVRational, int64_t, AVRational, int, int64_t*, AVRational)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/mathematics.h:79</i>
     */
    public long av_rescale_delta(AVRational in_tb, long in_ts, AVRational fs_tb, int duration, Pointer<Long > last, AVRational out_tb) {
        return av_rescale_delta(in_tb, in_ts, fs_tb, duration, Pointer.getPeer(last), out_tb);
    }
    protected native long av_rescale_delta(AVRational in_tb, long in_ts, AVRational fs_tb, int duration, @Ptr long last, AVRational out_tb);
    /**
     * Add a value to a timestamp.<br>
     * This function guarantees that when the same value is repeatly added that<br>
     * no accumulation of rounding errors occurs.<br>
     * @param ts Input timestamp<br>
     * @param ts_tb Input timestamp timebase<br>
     * @param inc value to add to ts<br>
     * @param inc_tb inc timebase<br>
     * Original signature : <code>int64_t av_add_stable(AVRational, int64_t, AVRational, int64_t)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/mathematics.h:90</i>
     */
    public native long av_add_stable(AVRational ts_tb, long ts, AVRational inc_tb, long inc);
    /**
     * Send the specified message to the log if the level is less than or equal<br>
     * to the current av_log_level. By default, all logging messages are sent to<br>
     * stderr. This behavior can be altered by setting a different logging callback<br>
     * function.<br>
     * @see av_log_set_callback<br>
     * @param avcl A pointer to an arbitrary struct of which the first field is a<br>
     *        pointer to an AVClass struct or NULL if general log.<br>
     * @param level The importance level of the message expressed using a @ref<br>
     *        lavu_log_constants "Logging Constant".<br>
     * @param fmt The format string (printf-compatible) that specifies how<br>
     *        subsequent arguments are converted to output.<br>
     * Original signature : <code>void av_log(void*, int, const char*, null)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/log.h:58</i>
     */
    public void av_log(Pointer<? > avcl, int level, Pointer<Byte > fmt, Object... varArgs1) {
        av_log(Pointer.getPeer(avcl), level, Pointer.getPeer(fmt), varArgs1);
    }
    protected native void av_log(@Ptr long avcl, int level, @Ptr long fmt, Object... varArgs1);
    /**
     * Send the specified message to the log if the level is less than or equal<br>
     * to the current av_log_level. By default, all logging messages are sent to<br>
     * stderr. This behavior can be altered by setting a different logging callback<br>
     * function.<br>
     * @see av_log_set_callback<br>
     * @param avcl A pointer to an arbitrary struct of which the first field is a<br>
     *        pointer to an AVClass struct.<br>
     * @param level The importance level of the message expressed using a @ref<br>
     *        lavu_log_constants "Logging Constant".<br>
     * @param fmt The format string (printf-compatible) that specifies how<br>
     *        subsequent arguments are converted to output.<br>
     * @param vl The arguments referenced by the format string.<br>
     * Original signature : <code>void av_vlog(void*, int, const char*, va_list)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/log.h:74</i>
     */
    public void av_vlog(Pointer<? > avcl, int level, Pointer<Byte > fmt, Object... vl) {
        av_vlog(Pointer.getPeer(avcl), level, Pointer.getPeer(fmt), vl);
    }
    protected native void av_vlog(@Ptr long avcl, int level, @Ptr long fmt, Object... vl);
    /**
     * Get the current log level<br>
     * @see lavu_log_constants<br>
     * @return Current log level<br>
     * Original signature : <code>int av_log_get_level()</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/log.h:81</i>
     */
    public native int av_log_get_level();
    /**
     * Set the log level<br>
     * @see lavu_log_constants<br>
     * @param level Logging level<br>
     * Original signature : <code>void av_log_set_level(int)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/log.h:88</i>
     */
    public native void av_log_set_level(int level);
    /**
     * Set the logging callback<br>
     * @note The callback must be thread safe, even if the application does not use<br>
     *       threads itself as some codecs are multithreaded.<br>
     * @see av_log_default_callback<br>
     * @param callback A logging function with a compatible signature.<br>
     * Original signature : <code>void av_log_set_callback(av_log_set_callback_callback_callback*)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/log.h:97</i>
     */
    public void av_log_set_callback(Pointer<AvutilLibrary.av_log_set_callback_callback_callback > callback) {
        av_log_set_callback(Pointer.getPeer(callback));
    }
    protected native void av_log_set_callback(@Ptr long callback);
    /**
     * Default logging callback<br>
     * It prints the message to stderr, optionally colorizing it.<br>
     * @param avcl A pointer to an arbitrary struct of which the first field is a<br>
     *        pointer to an AVClass struct.<br>
     * @param level The importance level of the message expressed using a @ref<br>
     *        lavu_log_constants "Logging Constant".<br>
     * @param fmt The format string (printf-compatible) that specifies how<br>
     *        subsequent arguments are converted to output.<br>
     * @param vl The arguments referenced by the format string.<br>
     * Original signature : <code>void av_log_default_callback(void*, int, const char*, va_list)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/log.h:110</i>
     */
    public void av_log_default_callback(Pointer<? > avcl, int level, Pointer<Byte > fmt, Object... vl) {
        av_log_default_callback(Pointer.getPeer(avcl), level, Pointer.getPeer(fmt), vl);
    }
    protected native void av_log_default_callback(@Ptr long avcl, int level, @Ptr long fmt, Object... vl);
    /**
     * Return the context name<br>
     * @param  ctx The AVClass context<br>
     * @return The AVClass class_name<br>
     * Original signature : <code>char* av_default_item_name(void*)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/log.h:117</i>
     */
    public Pointer<Byte > av_default_item_name(Pointer<? > ctx) {
        return (Pointer)Pointer.pointerToAddress(av_default_item_name(Pointer.getPeer(ctx)), Byte.class);
    }
    @Ptr
    protected native long av_default_item_name(@Ptr long ctx);
    /**
     * Original signature : <code>AVClassCategory av_default_get_category(void*)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/log.h:119</i>
     */
    public IntValuedEnum<AvutilLibrary.AVClassCategory > av_default_get_category(Pointer<? > ptr) {
        return FlagSet.fromValue(av_default_get_category(Pointer.getPeer(ptr)), AvutilLibrary.AVClassCategory.class);
    }
    protected native int av_default_get_category(@Ptr long ptr);
    /**
     * Format a line of log the same way as the default callback.<br>
     * @param line          buffer to receive the formatted line<br>
     * @param line_size     size of the buffer<br>
     * @param print_prefix  used to store whether the prefix must be printed;<br>
     *                      must point to a persistent integer initially set to 1<br>
     * Original signature : <code>void av_log_format_line(void*, int, const char*, va_list, char*, int, int*)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/log.h:128</i>
     */
    public void av_log_format_line(Pointer<? > ptr, int level, Pointer<Byte > fmt, Pointer<? > vl, Pointer<Byte > line, int line_size, Pointer<Integer > print_prefix) {
        av_log_format_line(Pointer.getPeer(ptr), level, Pointer.getPeer(fmt), Pointer.getPeer(vl), Pointer.getPeer(line), line_size, Pointer.getPeer(print_prefix));
    }
    protected native void av_log_format_line(@Ptr long ptr, int level, @Ptr long fmt, @Ptr long vl, @Ptr long line, int line_size, @Ptr long print_prefix);
    /**
     * Include the log severity in messages originating from codecs.<br>
     * Results in messages such as:<br>
     * [rawvideo @ 0xDEADBEEF] [error] encode did not produce valid pts<br>
     * Original signature : <code>void av_log_set_flags(int)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/log.h:135</i>
     */
    public native void av_log_set_flags(int arg);
    /**
     * Original signature : <code>int av_log_get_flags()</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/log.h:137</i>
     */
    public native int av_log_get_flags();
    /**
     * Compute the length of an integer list.<br>
     * @param elsize  size in bytes of each list element (only 1, 2, 4 or 8)<br>
     * @param term    list terminator (usually 0 or -1)<br>
     * @param list    pointer to the list<br>
     * @return  length of the list, in elements, not counting the terminator<br>
     * Original signature : <code>int av_int_list_length_for_size(unsigned, const void*, uint64_t)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/avutil.h:15</i>
     */
    public int av_int_list_length_for_size(int elsize, Pointer<? > list, long term) {
        return av_int_list_length_for_size(elsize, Pointer.getPeer(list), term);
    }
    protected native int av_int_list_length_for_size(int elsize, @Ptr long list, long term);
    /**
     * Open a file using a UTF-8 filename.<br>
     * The API of this function matches POSIX fopen(), errors are returned through<br>
     * errno.<br>
     * Original signature : <code>FILE* av_fopen_utf8(const char*, const char*)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/avutil.h:22</i>
     */
    public Pointer av_fopen_utf8(Pointer<Byte > path, Pointer<Byte > mode) {
        return Pointer.pointerToAddress(av_fopen_utf8(Pointer.getPeer(path), Pointer.getPeer(mode)));
    }
    @Ptr
    protected native long av_fopen_utf8(@Ptr long path, @Ptr long mode);
    /**
     * Return the fractional representation of the internal time base.<br>
     * Original signature : <code>AVRational av_get_time_base_q()</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/avutil.h:27</i>
     */
    public native AVRational av_get_time_base_q();
    /**
     * Return the name of sample_fmt, or NULL if sample_fmt is not<br>
     * recognized.<br>
     * Original signature : <code>char* av_get_sample_fmt_name(AVSampleFormat)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/samplefmt.h:46</i>
     */
    public Pointer<Byte > av_get_sample_fmt_name(IntValuedEnum<AvutilLibrary.AVSampleFormat > sample_fmt) {
        return (Pointer)Pointer.pointerToAddress(av_get_sample_fmt_name((int)sample_fmt.value()), Byte.class);
    }
    @Ptr
    protected native long av_get_sample_fmt_name(int sample_fmt);
    /**
     * Return a sample format corresponding to name, or AV_SAMPLE_FMT_NONE<br>
     * on error.<br>
     * Original signature : <code>AVSampleFormat av_get_sample_fmt(const char*)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/samplefmt.h:52</i>
     */
    public IntValuedEnum<AvutilLibrary.AVSampleFormat > av_get_sample_fmt(Pointer<Byte > name) {
        return FlagSet.fromValue(av_get_sample_fmt(Pointer.getPeer(name)), AvutilLibrary.AVSampleFormat.class);
    }
    protected native int av_get_sample_fmt(@Ptr long name);
    /**
     * Return the planar<->packed alternative form of the given sample format, or<br>
     * AV_SAMPLE_FMT_NONE on error. If the passed sample_fmt is already in the<br>
     * requested planar/packed format, the format returned is the same as the<br>
     * input.<br>
     * Original signature : <code>AVSampleFormat av_get_alt_sample_fmt(AVSampleFormat, int)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/samplefmt.h:60</i>
     */
    public IntValuedEnum<AvutilLibrary.AVSampleFormat > av_get_alt_sample_fmt(IntValuedEnum<AvutilLibrary.AVSampleFormat > sample_fmt, int planar) {
        return FlagSet.fromValue(av_get_alt_sample_fmt((int)sample_fmt.value(), planar), AvutilLibrary.AVSampleFormat.class);
    }
    protected native int av_get_alt_sample_fmt(int sample_fmt, int planar);
    /**
     * Get the packed alternative form of the given sample format.<br>
     * If the passed sample_fmt is already in packed format, the format returned is<br>
     * the same as the input.<br>
     * @return  the packed alternative form of the given sample format or<br>
     * AV_SAMPLE_FMT_NONE on error.<br>
     * Original signature : <code>AVSampleFormat av_get_packed_sample_fmt(AVSampleFormat)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/samplefmt.h:69</i>
     */
    public IntValuedEnum<AvutilLibrary.AVSampleFormat > av_get_packed_sample_fmt(IntValuedEnum<AvutilLibrary.AVSampleFormat > sample_fmt) {
        return FlagSet.fromValue(av_get_packed_sample_fmt((int)sample_fmt.value()), AvutilLibrary.AVSampleFormat.class);
    }
    protected native int av_get_packed_sample_fmt(int sample_fmt);
    /**
     * Get the planar alternative form of the given sample format.<br>
     * If the passed sample_fmt is already in planar format, the format returned is<br>
     * the same as the input.<br>
     * @return  the planar alternative form of the given sample format or<br>
     * AV_SAMPLE_FMT_NONE on error.<br>
     * Original signature : <code>AVSampleFormat av_get_planar_sample_fmt(AVSampleFormat)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/samplefmt.h:78</i>
     */
    public IntValuedEnum<AvutilLibrary.AVSampleFormat > av_get_planar_sample_fmt(IntValuedEnum<AvutilLibrary.AVSampleFormat > sample_fmt) {
        return FlagSet.fromValue(av_get_planar_sample_fmt((int)sample_fmt.value()), AvutilLibrary.AVSampleFormat.class);
    }
    protected native int av_get_planar_sample_fmt(int sample_fmt);
    /**
     * Generate a string corresponding to the sample format with<br>
     * sample_fmt, or a header if sample_fmt is negative.<br>
     * @param buf the buffer where to write the string<br>
     * @param buf_size the size of buf<br>
     * @param sample_fmt the number of the sample format to print the<br>
     * corresponding info string, or a negative value to print the<br>
     * corresponding header.<br>
     * @return the pointer to the filled buffer or NULL if sample_fmt is<br>
     * unknown or in case of other errors<br>
     * Original signature : <code>char* av_get_sample_fmt_string(char*, int, AVSampleFormat)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/samplefmt.h:91</i>
     */
    public Pointer<Byte > av_get_sample_fmt_string(Pointer<Byte > buf, int buf_size, IntValuedEnum<AvutilLibrary.AVSampleFormat > sample_fmt) {
        return (Pointer)Pointer.pointerToAddress(av_get_sample_fmt_string(Pointer.getPeer(buf), buf_size, (int)sample_fmt.value()), Byte.class);
    }
    @Ptr
    protected native long av_get_sample_fmt_string(@Ptr long buf, int buf_size, int sample_fmt);
    /**
     * Return number of bytes per sample.<br>
     * @param sample_fmt the sample format<br>
     * @return number of bytes per sample or zero if unknown for the given<br>
     * sample format<br>
     * Original signature : <code>int av_get_bytes_per_sample(AVSampleFormat)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/samplefmt.h:99</i>
     */
    public int av_get_bytes_per_sample(IntValuedEnum<AvutilLibrary.AVSampleFormat > sample_fmt) {
        return av_get_bytes_per_sample((int)sample_fmt.value());
    }
    protected native int av_get_bytes_per_sample(int sample_fmt);
    /**
     * Check if the sample format is planar.<br>
     * @param sample_fmt the sample format to inspect<br>
     * @return 1 if the sample format is planar, 0 if it is interleaved<br>
     * Original signature : <code>int av_sample_fmt_is_planar(AVSampleFormat)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/samplefmt.h:106</i>
     */
    public int av_sample_fmt_is_planar(IntValuedEnum<AvutilLibrary.AVSampleFormat > sample_fmt) {
        return av_sample_fmt_is_planar((int)sample_fmt.value());
    }
    protected native int av_sample_fmt_is_planar(int sample_fmt);
    /**
     * Get the required buffer size for the given audio parameters.<br>
     * @param[out] linesize calculated linesize, may be NULL<br>
     * @param nb_channels   the number of channels<br>
     * @param nb_samples    the number of samples in a single channel<br>
     * @param sample_fmt    the sample format<br>
     * @param align         buffer size alignment (0 = default, 1 = no alignment)<br>
     * @return              required buffer size, or negative error code on failure<br>
     * Original signature : <code>int av_samples_get_buffer_size(int*, int, int, AVSampleFormat, int)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/samplefmt.h:117</i>
     */
    public int av_samples_get_buffer_size(Pointer<Integer > linesize, int nb_channels, int nb_samples, IntValuedEnum<AvutilLibrary.AVSampleFormat > sample_fmt, int align) {
        return av_samples_get_buffer_size(Pointer.getPeer(linesize), nb_channels, nb_samples, (int)sample_fmt.value(), align);
    }
    protected native int av_samples_get_buffer_size(@Ptr long linesize, int nb_channels, int nb_samples, int sample_fmt, int align);
    /**
     * Fill plane data pointers and linesize for samples with sample<br>
     * format sample_fmt.<br>
     * The audio_data array is filled with the pointers to the samples data planes:<br>
     * for planar, set the start point of each channel's data within the buffer,<br>
     * for packed, set the start point of the entire buffer only.<br>
     * The value pointed to by linesize is set to the aligned size of each<br>
     * channel's data buffer for planar layout, or to the aligned size of the<br>
     * buffer for all channels for packed layout.<br>
     * The buffer in buf must be big enough to contain all the samples<br>
     * (use av_samples_get_buffer_size() to compute its minimum size),<br>
     * otherwise the audio_data pointers will point to invalid data.<br>
     * @see enum AVSampleFormat<br>
     * The documentation for AVSampleFormat describes the data layout.<br>
     * @param[out] audio_data  array to be filled with the pointer for each channel<br>
     * @param[out] linesize    calculated linesize, may be NULL<br>
     * @param buf              the pointer to a buffer containing the samples<br>
     * @param nb_channels      the number of channels<br>
     * @param nb_samples       the number of samples in a single channel<br>
     * @param sample_fmt       the sample format<br>
     * @param align            buffer size alignment (0 = default, 1 = no alignment)<br>
     * @return                 >=0 on success or a negative error code on failure<br>
     * @todo return minimum size in bytes required for the buffer in case<br>
     * of success at the next bump<br>
     * Original signature : <code>int av_samples_fill_arrays(uint8_t**, int*, const uint8_t*, int, int, AVSampleFormat, int)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/samplefmt.h:144</i>
     */
    public int av_samples_fill_arrays(Pointer<Pointer<Byte > > audio_data, Pointer<Integer > linesize, Pointer<Byte > buf, int nb_channels, int nb_samples, IntValuedEnum<AvutilLibrary.AVSampleFormat > sample_fmt, int align) {
        return av_samples_fill_arrays(Pointer.getPeer(audio_data), Pointer.getPeer(linesize), Pointer.getPeer(buf), nb_channels, nb_samples, (int)sample_fmt.value(), align);
    }
    protected native int av_samples_fill_arrays(@Ptr long audio_data, @Ptr long linesize, @Ptr long buf, int nb_channels, int nb_samples, int sample_fmt, int align);
    /**
     * Allocate a samples buffer for nb_samples samples, and fill data pointers and<br>
     * linesize accordingly.<br>
     * The allocated samples buffer can be freed by using av_freep(&audio_data[0])<br>
     * Allocated data will be initialized to silence.<br>
     * @see enum AVSampleFormat<br>
     * The documentation for AVSampleFormat describes the data layout.<br>
     * @param[out] audio_data  array to be filled with the pointer for each channel<br>
     * @param[out] linesize    aligned size for audio buffer(s), may be NULL<br>
     * @param nb_channels      number of audio channels<br>
     * @param nb_samples       number of samples per channel<br>
     * @param align            buffer size alignment (0 = default, 1 = no alignment)<br>
     * @return                 >=0 on success or a negative error code on failure<br>
     * @todo return the size of the allocated buffer in case of success at the next bump<br>
     * @see av_samples_fill_arrays()<br>
     * @see av_samples_alloc_array_and_samples()<br>
     * Original signature : <code>int av_samples_alloc(uint8_t**, int*, int, int, AVSampleFormat, int)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/samplefmt.h:163</i>
     */
    public int av_samples_alloc(Pointer<Pointer<Byte > > audio_data, Pointer<Integer > linesize, int nb_channels, int nb_samples, IntValuedEnum<AvutilLibrary.AVSampleFormat > sample_fmt, int align) {
        return av_samples_alloc(Pointer.getPeer(audio_data), Pointer.getPeer(linesize), nb_channels, nb_samples, (int)sample_fmt.value(), align);
    }
    protected native int av_samples_alloc(@Ptr long audio_data, @Ptr long linesize, int nb_channels, int nb_samples, int sample_fmt, int align);
    /**
     * Allocate a data pointers array, samples buffer for nb_samples<br>
     * samples, and fill data pointers and linesize accordingly.<br>
     * This is the same as av_samples_alloc(), but also allocates the data<br>
     * pointers array.<br>
     * @see av_samples_alloc()<br>
     * Original signature : <code>int av_samples_alloc_array_and_samples(uint8_t***, int*, int, int, AVSampleFormat, int)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/samplefmt.h:172</i>
     */
    public int av_samples_alloc_array_and_samples(Pointer<Pointer<Pointer<Byte > > > audio_data, Pointer<Integer > linesize, int nb_channels, int nb_samples, IntValuedEnum<AvutilLibrary.AVSampleFormat > sample_fmt, int align) {
        return av_samples_alloc_array_and_samples(Pointer.getPeer(audio_data), Pointer.getPeer(linesize), nb_channels, nb_samples, (int)sample_fmt.value(), align);
    }
    protected native int av_samples_alloc_array_and_samples(@Ptr long audio_data, @Ptr long linesize, int nb_channels, int nb_samples, int sample_fmt, int align);
    /**
     * Copy samples from src to dst.<br>
     * @param dst destination array of pointers to data planes<br>
     * @param src source array of pointers to data planes<br>
     * @param dst_offset offset in samples at which the data will be written to dst<br>
     * @param src_offset offset in samples at which the data will be read from src<br>
     * @param nb_samples number of samples to be copied<br>
     * @param nb_channels number of audio channels<br>
     * @param sample_fmt audio sample format<br>
     * Original signature : <code>int av_samples_copy(uint8_t**, const uint8_t**, int, int, int, int, AVSampleFormat)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/samplefmt.h:184</i>
     */
    public int av_samples_copy(Pointer<Pointer<Byte > > dst, Pointer<Pointer<Byte > > src, int dst_offset, int src_offset, int nb_samples, int nb_channels, IntValuedEnum<AvutilLibrary.AVSampleFormat > sample_fmt) {
        return av_samples_copy(Pointer.getPeer(dst), Pointer.getPeer(src), dst_offset, src_offset, nb_samples, nb_channels, (int)sample_fmt.value());
    }
    protected native int av_samples_copy(@Ptr long dst, @Ptr long src, int dst_offset, int src_offset, int nb_samples, int nb_channels, int sample_fmt);
    /**
     * Fill an audio buffer with silence.<br>
     * @param audio_data  array of pointers to data planes<br>
     * @param offset      offset in samples at which to start filling<br>
     * @param nb_samples  number of samples to fill<br>
     * @param nb_channels number of audio channels<br>
     * @param sample_fmt  audio sample format<br>
     * Original signature : <code>int av_samples_set_silence(uint8_t**, int, int, int, AVSampleFormat)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/samplefmt.h:194</i>
     */
    public int av_samples_set_silence(Pointer<Pointer<Byte > > audio_data, int offset, int nb_samples, int nb_channels, IntValuedEnum<AvutilLibrary.AVSampleFormat > sample_fmt) {
        return av_samples_set_silence(Pointer.getPeer(audio_data), offset, nb_samples, nb_channels, (int)sample_fmt.value());
    }
    protected native int av_samples_set_silence(@Ptr long audio_data, int offset, int nb_samples, int nb_channels, int sample_fmt);
    /**
     * Allocate an AVBuffer of the given size using av_malloc().<br>
     * @return an AVBufferRef of given size or NULL when out of memory<br>
     * Original signature : <code>AVBufferRef* av_buffer_alloc(int)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/buffer.h:20</i>
     */
    public Pointer<AVBufferRef > av_buffer_alloc(int size) {
        return (Pointer)Pointer.pointerToAddress(av_buffer_alloc$2(size), AVBufferRef.class);
    }
    @Ptr
    @Name("av_buffer_alloc")
    protected native long av_buffer_alloc$2(int size);
    /**
     * Same as av_buffer_alloc(), except the returned buffer will be initialized<br>
     * to zero.<br>
     * Original signature : <code>AVBufferRef* av_buffer_allocz(int)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/buffer.h:26</i>
     */
    public Pointer<AVBufferRef > av_buffer_allocz(int size) {
        return (Pointer)Pointer.pointerToAddress(av_buffer_allocz$2(size), AVBufferRef.class);
    }
    @Ptr
    @Name("av_buffer_allocz")
    protected native long av_buffer_allocz$2(int size);
    /**
     * Create an AVBuffer from an existing array.<br>
     * If this function is successful, data is owned by the AVBuffer. The caller may<br>
     * only access data through the returned AVBufferRef and references derived from<br>
     * it.<br>
     * If this function fails, data is left untouched.<br>
     * @param data   data array<br>
     * @param size   size of data in bytes<br>
     * @param free   a callback for freeing this buffer's data<br>
     * @param opaque parameter to be got for processing or passed to free<br>
     * @param flags  a combination of AV_BUFFER_FLAG_*<br>
     * @return an AVBufferRef referring to data on success, NULL on failure.<br>
     * Original signature : <code>AVBufferRef* av_buffer_create(uint8_t*, int, av_buffer_create_free_callback*, void*, int)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/buffer.h:41</i>
     */
    public Pointer<AVBufferRef > av_buffer_create(Pointer<Byte > data, int size, Pointer<AvutilLibrary.av_buffer_create_free_callback > free, Pointer<? > opaque, int flags) {
        return (Pointer)Pointer.pointerToAddress(av_buffer_create(Pointer.getPeer(data), size, Pointer.getPeer(free), Pointer.getPeer(opaque), flags), AVBufferRef.class);
    }
    @Ptr
    protected native long av_buffer_create(@Ptr long data, int size, @Ptr long free, @Ptr long opaque, int flags);
    /**
     * Default free callback, which calls av_free() on the buffer data.<br>
     * This function is meant to be passed to av_buffer_create(), not called<br>
     * directly.<br>
     * Original signature : <code>void av_buffer_default_free(void*, uint8_t*)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/buffer.h:48</i>
     */
    public void av_buffer_default_free(Pointer<? > opaque, Pointer<Byte > data) {
        av_buffer_default_free(Pointer.getPeer(opaque), Pointer.getPeer(data));
    }
    protected native void av_buffer_default_free(@Ptr long opaque, @Ptr long data);
    /**
     * Create a new reference to an AVBuffer.<br>
     * @return a new AVBufferRef referring to the same AVBuffer as buf or NULL on<br>
     * failure.<br>
     * Original signature : <code>AVBufferRef* av_buffer_ref(AVBufferRef*)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/buffer.h:55</i>
     */
    public Pointer<AVBufferRef > av_buffer_ref(Pointer<AVBufferRef > buf) {
        return (Pointer)Pointer.pointerToAddress(av_buffer_ref(Pointer.getPeer(buf)), AVBufferRef.class);
    }
    @Ptr
    protected native long av_buffer_ref(@Ptr long buf);
    /**
     * Free a given reference and automatically free the buffer if there are no more<br>
     * references to it.<br>
     * @param buf the reference to be freed. The pointer is set to NULL on return.<br>
     * Original signature : <code>void av_buffer_unref(AVBufferRef**)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/buffer.h:62</i>
     */
    public void av_buffer_unref(Pointer<Pointer<AVBufferRef > > buf) {
        av_buffer_unref(Pointer.getPeer(buf));
    }
    protected native void av_buffer_unref(@Ptr long buf);
    /**
     * @return 1 if the caller may write to the data referred to by buf (which is<br>
     * true if and only if buf is the only reference to the underlying AVBuffer).<br>
     * Return 0 otherwise.<br>
     * A positive answer is valid until av_buffer_ref() is called on buf.<br>
     * Original signature : <code>int av_buffer_is_writable(const AVBufferRef*)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/buffer.h:70</i>
     */
    public int av_buffer_is_writable(Pointer<AVBufferRef > buf) {
        return av_buffer_is_writable(Pointer.getPeer(buf));
    }
    protected native int av_buffer_is_writable(@Ptr long buf);
    /**
     * @return the opaque parameter set by av_buffer_create.<br>
     * Original signature : <code>void* av_buffer_get_opaque(const AVBufferRef*)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/buffer.h:75</i>
     */
    public Pointer<? > av_buffer_get_opaque(Pointer<AVBufferRef > buf) {
        return Pointer.pointerToAddress(av_buffer_get_opaque(Pointer.getPeer(buf)));
    }
    @Ptr
    protected native long av_buffer_get_opaque(@Ptr long buf);
    /**
     * Original signature : <code>int av_buffer_get_ref_count(const AVBufferRef*)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/buffer.h:77</i>
     */
    public int av_buffer_get_ref_count(Pointer<AVBufferRef > buf) {
        return av_buffer_get_ref_count(Pointer.getPeer(buf));
    }
    protected native int av_buffer_get_ref_count(@Ptr long buf);
    /**
     * Create a writable reference from a given buffer reference, avoiding data copy<br>
     * if possible.<br>
     * @param buf buffer reference to make writable. On success, buf is either left<br>
     *            untouched, or it is unreferenced and a new writable AVBufferRef is<br>
     *            written in its place. On failure, buf is left untouched.<br>
     * @return 0 on success, a negative AVERROR on failure.<br>
     * Original signature : <code>int av_buffer_make_writable(AVBufferRef**)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/buffer.h:87</i>
     */
    public int av_buffer_make_writable(Pointer<Pointer<AVBufferRef > > buf) {
        return av_buffer_make_writable(Pointer.getPeer(buf));
    }
    protected native int av_buffer_make_writable(@Ptr long buf);
    /**
     * Reallocate a given buffer.<br>
     * @param buf  a buffer reference to reallocate. On success, buf will be<br>
     *             unreferenced and a new reference with the required size will be<br>
     *             written in its place. On failure buf will be left untouched. *buf<br>
     *             may be NULL, then a new buffer is allocated.<br>
     * @param size required new buffer size.<br>
     * @return 0 on success, a negative AVERROR on failure.<br>
     * @note the buffer is actually reallocated with av_realloc() only if it was<br>
     * initially allocated through av_buffer_realloc(NULL) and there is only one<br>
     * reference to it (i.e. the one passed to this function). In all other cases<br>
     * a new buffer is allocated and the data is copied.<br>
     * Original signature : <code>int av_buffer_realloc(AVBufferRef**, int)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/buffer.h:102</i>
     */
    public int av_buffer_realloc(Pointer<Pointer<AVBufferRef > > buf, int size) {
        return av_buffer_realloc(Pointer.getPeer(buf), size);
    }
    protected native int av_buffer_realloc(@Ptr long buf, int size);
    /**
     * Allocate and initialize a buffer pool.<br>
     * @param size size of each buffer in this pool<br>
     * @param alloc a function that will be used to allocate new buffers when the<br>
     * pool is empty. May be NULL, then the default allocator will be used<br>
     * (av_buffer_alloc()).<br>
     * @return newly created buffer pool on success, NULL on error.<br>
     * Original signature : <code>AVBufferPool* av_buffer_pool_init(int, av_buffer_pool_init_alloc_callback*)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/buffer.h:118</i>
     */
    public Pointer<AvutilLibrary.AVBufferPool > av_buffer_pool_init(int size, Pointer<AvutilLibrary.av_buffer_pool_init_alloc_callback > alloc) {
        return (Pointer)Pointer.pointerToAddress(av_buffer_pool_init(size, Pointer.getPeer(alloc)), AvutilLibrary.AVBufferPool.class);
    }
    @Ptr
    protected native long av_buffer_pool_init(int size, @Ptr long alloc);
    /**
     * Mark the pool as being available for freeing. It will actually be freed only<br>
     * once all the allocated buffers associated with the pool are released. Thus it<br>
     * is safe to call this function while some of the allocated buffers are still<br>
     * in use.<br>
     * @param pool pointer to the pool to be freed. It will be set to NULL.<br>
     * @see av_buffer_pool_can_uninit()<br>
     * Original signature : <code>void av_buffer_pool_uninit(AVBufferPool**)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/buffer.h:128</i>
     */
    public void av_buffer_pool_uninit(Pointer<Pointer<AvutilLibrary.AVBufferPool > > pool) {
        av_buffer_pool_uninit(Pointer.getPeer(pool));
    }
    protected native void av_buffer_pool_uninit(@Ptr long pool);
    /**
     * Allocate a new AVBuffer, reusing an old buffer from the pool when available.<br>
     * This function may be called simultaneously from multiple threads.<br>
     * @return a reference to the new buffer on success, NULL on error.<br>
     * Original signature : <code>AVBufferRef* av_buffer_pool_get(AVBufferPool*)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/buffer.h:135</i>
     */
    public Pointer<AVBufferRef > av_buffer_pool_get(Pointer<AvutilLibrary.AVBufferPool > pool) {
        return (Pointer)Pointer.pointerToAddress(av_buffer_pool_get(Pointer.getPeer(pool)), AVBufferRef.class);
    }
    @Ptr
    protected native long av_buffer_pool_get(@Ptr long pool);
    /**
     * Return the flags which specify extensions supported by the CPU.<br>
     * The returned value is affected by av_force_cpu_flags() if that was used<br>
     * before. So av_get_cpu_flags() can easily be used in a application to<br>
     * detect the enabled cpu flags.<br>
     * Original signature : <code>int av_get_cpu_flags()</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/cpu.h:7</i>
     */
    public native int av_get_cpu_flags();
    /**
     * Disables cpu detection and forces the specified flags.<br>
     * -1 is a special case that disables forcing of specific flags.<br>
     * Original signature : <code>void av_force_cpu_flags(int)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/cpu.h:13</i>
     */
    public native void av_force_cpu_flags(int flags);
    /**
     * Set a mask on flags returned by av_get_cpu_flags().<br>
     * This function is mainly useful for testing.<br>
     * Please use av_force_cpu_flags() and av_get_cpu_flags() instead which are more flexible<br>
     * @warning this function is not thread safe.<br>
     * Original signature : <code>void av_set_cpu_flags_mask(int)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/cpu.h:21</i>
     */
    public native void av_set_cpu_flags_mask(int mask);
    /**
     * Parse CPU flags from a string.<br>
     * The returned flags contain the specified flags as well as related unspecified flags.<br>
     * This function exists only for compatibility with libav.<br>
     * Please use av_parse_cpu_caps() when possible.<br>
     * @return a combination of AV_CPU_* flags, negative on error.<br>
     * Original signature : <code>int av_parse_cpu_flags(const char*)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/cpu.h:30</i>
     */
    public int av_parse_cpu_flags(Pointer<Byte > s) {
        return av_parse_cpu_flags(Pointer.getPeer(s));
    }
    protected native int av_parse_cpu_flags(@Ptr long s);
    /**
     * Parse CPU caps from a string and update the given AV_CPU_* flags based on that.<br>
     * @return negative on error.<br>
     * Original signature : <code>int av_parse_cpu_caps(unsigned*, const char*)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/cpu.h:36</i>
     */
    public int av_parse_cpu_caps(Pointer<Integer > flags, Pointer<Byte > s) {
        return av_parse_cpu_caps(Pointer.getPeer(flags), Pointer.getPeer(s));
    }
    protected native int av_parse_cpu_caps(@Ptr long flags, @Ptr long s);
    /**
     * @return the number of logical CPU cores present.<br>
     * Original signature : <code>int av_cpu_count()</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/cpu.h:41</i>
     */
    public native int av_cpu_count();
    /**
     * Return a channel layout id that matches name, or 0 if no match is found.<br>
     * name can be one or several of the following notations,<br>
     * separated by '+' or '|':<br>
     * - the name of an usual channel layout (mono, stereo, 4.0, quad, 5.0,<br>
     *   5.0(side), 5.1, 5.1(side), 7.1, 7.1(wide), downmix);<br>
     * - the name of a single channel (FL, FR, FC, LFE, BL, BR, FLC, FRC, BC,<br>
     *   SL, SR, TC, TFL, TFC, TFR, TBL, TBC, TBR, DL, DR);<br>
     * - a number of channels, in decimal, optionally followed by 'c', yielding<br>
     *   the default channel layout for that number of channels (@see<br>
     *   av_get_default_channel_layout);<br>
     * - a channel layout mask, in hexadecimal starting with "0x" (see the<br>
     *   AV_CH_* macros).<br>
     * @warning Starting from the next major bump the trailing character<br>
     * 'c' to specify a number of channels will be required, while a<br>
     * channel layout mask could also be specified as a decimal number<br>
     * (if and only if not followed by "c").<br>
     * Example: "stereo+FC" = "2c+FC" = "2c+1c" = "0x7"<br>
     * Original signature : <code>uint64_t av_get_channel_layout(const char*)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/channel_layout.h:35</i>
     */
    public long av_get_channel_layout(Pointer<Byte > name) {
        return av_get_channel_layout(Pointer.getPeer(name));
    }
    protected native long av_get_channel_layout(@Ptr long name);
    /**
     * Return a description of a channel layout.<br>
     * If nb_channels is <= 0, it is guessed from the channel_layout.<br>
     * @param buf put here the string containing the channel layout<br>
     * @param buf_size size in bytes of the buffer<br>
     * Original signature : <code>void av_get_channel_layout_string(char*, int, int, uint64_t)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/channel_layout.h:43</i>
     */
    public void av_get_channel_layout_string(Pointer<Byte > buf, int buf_size, int nb_channels, long channel_layout) {
        av_get_channel_layout_string(Pointer.getPeer(buf), buf_size, nb_channels, channel_layout);
    }
    protected native void av_get_channel_layout_string(@Ptr long buf, int buf_size, int nb_channels, long channel_layout);
    /**
     * Append a description of a channel layout to a bprint buffer.<br>
     * Original signature : <code>void av_bprint_channel_layout(AVBPrint*, int, uint64_t)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/channel_layout.h:49</i>
     */
    public void av_bprint_channel_layout(Pointer<AVBPrint > bp, int nb_channels, long channel_layout) {
        av_bprint_channel_layout(Pointer.getPeer(bp), nb_channels, channel_layout);
    }
    protected native void av_bprint_channel_layout(@Ptr long bp, int nb_channels, long channel_layout);
    /**
     * Return the number of channels in the channel layout.<br>
     * Original signature : <code>int av_get_channel_layout_nb_channels(uint64_t)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/channel_layout.h:54</i>
     */
    public native int av_get_channel_layout_nb_channels(long channel_layout);
    /**
     * Return default channel layout for a given number of channels.<br>
     * Original signature : <code>int64_t av_get_default_channel_layout(int)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/channel_layout.h:59</i>
     */
    public native long av_get_default_channel_layout(int nb_channels);
    /**
     * Get the index of a channel in channel_layout.<br>
     * @param channel a channel layout describing exactly one channel which must be<br>
     *                present in channel_layout.<br>
     * @return index of channel in channel_layout on success, a negative AVERROR<br>
     *         on error.<br>
     * Original signature : <code>int av_get_channel_layout_channel_index(uint64_t, uint64_t)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/channel_layout.h:68</i>
     */
    public native int av_get_channel_layout_channel_index(long channel_layout, long channel);
    /**
     * Get the channel with the given index in channel_layout.<br>
     * Original signature : <code>uint64_t av_channel_layout_extract_channel(uint64_t, int)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/channel_layout.h:73</i>
     */
    public native long av_channel_layout_extract_channel(long channel_layout, int index);
    /**
     * Get the name of a given channel.<br>
     * @return channel name on success, NULL on error.<br>
     * Original signature : <code>char* av_get_channel_name(uint64_t)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/channel_layout.h:79</i>
     */
    public Pointer<Byte > av_get_channel_name(long channel) {
        return (Pointer)Pointer.pointerToAddress(av_get_channel_name$2(channel), Byte.class);
    }
    @Ptr
    @Name("av_get_channel_name")
    protected native long av_get_channel_name$2(long channel);
    /**
     * Get the description of a given channel.<br>
     * @param channel  a channel layout with a single channel<br>
     * @return  channel description on success, NULL on error<br>
     * Original signature : <code>char* av_get_channel_description(uint64_t)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/channel_layout.h:86</i>
     */
    public Pointer<Byte > av_get_channel_description(long channel) {
        return (Pointer)Pointer.pointerToAddress(av_get_channel_description$2(channel), Byte.class);
    }
    @Ptr
    @Name("av_get_channel_description")
    protected native long av_get_channel_description$2(long channel);
    /**
     * Get the value and name of a standard channel layout.<br>
     * @param[in]  index   index in an internal list, starting at 0<br>
     * @param[out] layout  channel layout mask<br>
     * @param[out] name    name of the layout<br>
     * @return  0  if the layout exists,<br>
     *          <0 if index is beyond the limits<br>
     * Original signature : <code>int av_get_standard_channel_layout(unsigned, uint64_t*, const char**)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/channel_layout.h:96</i>
     */
    public int av_get_standard_channel_layout(int index, Pointer<Long > layout, Pointer<Pointer<Byte > > name) {
        return av_get_standard_channel_layout(index, Pointer.getPeer(layout), Pointer.getPeer(name));
    }
    protected native int av_get_standard_channel_layout(int index, @Ptr long layout, @Ptr long name);
    /**
     * Get a dictionary entry with matching key.<br>
     * The returned entry key or value must not be changed, or it will<br>
     * cause undefined behavior.<br>
     * To iterate through all the dictionary entries, you can set the matching key<br>
     * to the null string "" and set the AV_DICT_IGNORE_SUFFIX flag.<br>
     * @param prev Set to the previous matching element to find the next.<br>
     *             If set to NULL the first matching element is returned.<br>
     * @param key matching key<br>
     * @param flags a collection of AV_DICT_* flags controlling how the entry is retrieved<br>
     * @return found entry or NULL in case no matching entry was found in the dictionary<br>
     * Original signature : <code>AVDictionaryEntry* av_dict_get(const AVDictionary*, const char*, const AVDictionaryEntry*, int)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/dict.h:43</i>
     */
    public Pointer<AVDictionaryEntry > av_dict_get(Pointer<AVDictionary > m, Pointer<Byte > key, Pointer<AVDictionaryEntry > prev, int flags) {
        return (Pointer)Pointer.pointerToAddress(av_dict_get(Pointer.getPeer(m), Pointer.getPeer(key), Pointer.getPeer(prev), flags), AVDictionaryEntry.class);
    }
    @Ptr
    protected native long av_dict_get(@Ptr long m, @Ptr long key, @Ptr long prev, int flags);
    /**
     * Get number of entries in dictionary.<br>
     * @param m dictionary<br>
     * @return  number of entries in dictionary<br>
     * Original signature : <code>int av_dict_count(const AVDictionary*)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/dict.h:50</i>
     */
    public int av_dict_count(Pointer<AVDictionary > m) {
        return av_dict_count(Pointer.getPeer(m));
    }
    protected native int av_dict_count(@Ptr long m);
    /**
     * Set the given entry in *pm, overwriting an existing entry.<br>
     * Note: If AV_DICT_DONT_STRDUP_KEY or AV_DICT_DONT_STRDUP_VAL is set,<br>
     * these arguments will be freed on error.<br>
     * @param pm pointer to a pointer to a dictionary struct. If *pm is NULL<br>
     * a dictionary struct is allocated and put in *pm.<br>
     * @param key entry key to add to *pm (will be av_strduped depending on flags)<br>
     * @param value entry value to add to *pm (will be av_strduped depending on flags).<br>
     *        Passing a NULL value will cause an existing entry to be deleted.<br>
     * @return >= 0 on success otherwise an error code <0<br>
     * Original signature : <code>int av_dict_set(AVDictionary**, const char*, const char*, int)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/dict.h:63</i>
     */
    public int av_dict_set(Pointer<Pointer<AVDictionary > > pm, Pointer<Byte > key, Pointer<Byte > value, int flags) {
        return av_dict_set(Pointer.getPeer(pm), Pointer.getPeer(key), Pointer.getPeer(value), flags);
    }
    protected native int av_dict_set(@Ptr long pm, @Ptr long key, @Ptr long value, int flags);
    /**
     * Convenience wrapper for av_dict_set that converts the value to a string<br>
     * and stores it.<br>
     * Note: If AV_DICT_DONT_STRDUP_KEY is set, key will be freed on error.<br>
     * Original signature : <code>int av_dict_set_int(AVDictionary**, const char*, int64_t, int)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/dict.h:70</i>
     */
    public int av_dict_set_int(Pointer<Pointer<AVDictionary > > pm, Pointer<Byte > key, long value, int flags) {
        return av_dict_set_int(Pointer.getPeer(pm), Pointer.getPeer(key), value, flags);
    }
    protected native int av_dict_set_int(@Ptr long pm, @Ptr long key, long value, int flags);
    /**
     * Parse the key/value pairs list and add the parsed entries to a dictionary.<br>
     * In case of failure, all the successfully set entries are stored in<br>
     * *pm. You may need to manually free the created dictionary.<br>
     * @param key_val_sep  a 0-terminated list of characters used to separate<br>
     *                     key from value<br>
     * @param pairs_sep    a 0-terminated list of characters used to separate<br>
     *                     two pairs from each other<br>
     * @param flags        flags to use when adding to dictionary.<br>
     *                     AV_DICT_DONT_STRDUP_KEY and AV_DICT_DONT_STRDUP_VAL<br>
     *                     are ignored since the key/value tokens will always<br>
     *                     be duplicated.<br>
     * @return             0 on success, negative AVERROR code on failure<br>
     * Original signature : <code>int av_dict_parse_string(AVDictionary**, const char*, const char*, const char*, int)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/dict.h:86</i>
     */
    public int av_dict_parse_string(Pointer<Pointer<AVDictionary > > pm, Pointer<Byte > str, Pointer<Byte > key_val_sep, Pointer<Byte > pairs_sep, int flags) {
        return av_dict_parse_string(Pointer.getPeer(pm), Pointer.getPeer(str), Pointer.getPeer(key_val_sep), Pointer.getPeer(pairs_sep), flags);
    }
    protected native int av_dict_parse_string(@Ptr long pm, @Ptr long str, @Ptr long key_val_sep, @Ptr long pairs_sep, int flags);
    /**
     * Copy entries from one AVDictionary struct into another.<br>
     * @param dst pointer to a pointer to a AVDictionary struct. If *dst is NULL,<br>
     *            this function will allocate a struct for you and put it in *dst<br>
     * @param src pointer to source AVDictionary struct<br>
     * @param flags flags to use when setting entries in *dst<br>
     * @note metadata is read using the AV_DICT_IGNORE_SUFFIX flag<br>
     * @return 0 on success, negative AVERROR code on failure. If dst was allocated<br>
     *           by this function, callers should free the associated memory.<br>
     * Original signature : <code>int av_dict_copy(AVDictionary**, const AVDictionary*, int)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/dict.h:98</i>
     */
    public int av_dict_copy(Pointer<Pointer<AVDictionary > > dst, Pointer<AVDictionary > src, int flags) {
        return av_dict_copy(Pointer.getPeer(dst), Pointer.getPeer(src), flags);
    }
    protected native int av_dict_copy(@Ptr long dst, @Ptr long src, int flags);
    /**
     * Free all the memory allocated for an AVDictionary struct<br>
     * and all keys and values.<br>
     * Original signature : <code>void av_dict_free(AVDictionary**)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/dict.h:104</i>
     */
    public void av_dict_free(Pointer<Pointer<AVDictionary > > m) {
        av_dict_free(Pointer.getPeer(m));
    }
    protected native void av_dict_free(@Ptr long m);
    /**
     * Get dictionary entries as a string.<br>
     * Create a string containing dictionary's entries.<br>
     * Such string may be passed back to av_dict_parse_string().<br>
     * @note String is escaped with backslashes ('\').<br>
     * @param[in]  m             dictionary<br>
     * @param[out] buffer        Pointer to buffer that will be allocated with string containg entries.<br>
     *                           Buffer must be freed by the caller when is no longer needed.<br>
     * @param[in]  key_val_sep   character used to separate key from value<br>
     * @param[in]  pairs_sep     character used to separate two pairs from each other<br>
     * @return                   >= 0 on success, negative on error<br>
     * @warning Separators cannot be neither '\\' nor '\0'. They also cannot be the same.<br>
     * Original signature : <code>int av_dict_get_string(const AVDictionary*, char**, const char, const char)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/dict.h:119</i>
     */
    public int av_dict_get_string(Pointer<AVDictionary > m, Pointer<Pointer<Byte > > buffer, byte key_val_sep, byte pairs_sep) {
        return av_dict_get_string(Pointer.getPeer(m), Pointer.getPeer(buffer), key_val_sep, pairs_sep);
    }
    protected native int av_dict_get_string(@Ptr long m, @Ptr long buffer, byte key_val_sep, byte pairs_sep);
    /**
     * Accessors for some AVFrame fields.<br>
     * The position of these field in the structure is not part of the ABI,<br>
     * they should not be accessed directly outside libavutil.<br>
     * Original signature : <code>int64_t av_frame_get_best_effort_timestamp(const AVFrame*)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/frame.h:134</i>
     */
    public long av_frame_get_best_effort_timestamp(Pointer<AVFrame > frame) {
        return av_frame_get_best_effort_timestamp(Pointer.getPeer(frame));
    }
    protected native long av_frame_get_best_effort_timestamp(@Ptr long frame);
    /**
     * Original signature : <code>void av_frame_set_best_effort_timestamp(AVFrame*, int64_t)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/frame.h:136</i>
     */
    public void av_frame_set_best_effort_timestamp(Pointer<AVFrame > frame, long val) {
        av_frame_set_best_effort_timestamp(Pointer.getPeer(frame), val);
    }
    protected native void av_frame_set_best_effort_timestamp(@Ptr long frame, long val);
    /**
     * Original signature : <code>int64_t av_frame_get_pkt_duration(const AVFrame*)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/frame.h:138</i>
     */
    public long av_frame_get_pkt_duration(Pointer<AVFrame > frame) {
        return av_frame_get_pkt_duration(Pointer.getPeer(frame));
    }
    protected native long av_frame_get_pkt_duration(@Ptr long frame);
    /**
     * Original signature : <code>void av_frame_set_pkt_duration(AVFrame*, int64_t)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/frame.h:140</i>
     */
    public void av_frame_set_pkt_duration(Pointer<AVFrame > frame, long val) {
        av_frame_set_pkt_duration(Pointer.getPeer(frame), val);
    }
    protected native void av_frame_set_pkt_duration(@Ptr long frame, long val);
    /**
     * Original signature : <code>int64_t av_frame_get_pkt_pos(const AVFrame*)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/frame.h:142</i>
     */
    public long av_frame_get_pkt_pos(Pointer<AVFrame > frame) {
        return av_frame_get_pkt_pos(Pointer.getPeer(frame));
    }
    protected native long av_frame_get_pkt_pos(@Ptr long frame);
    /**
     * Original signature : <code>void av_frame_set_pkt_pos(AVFrame*, int64_t)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/frame.h:144</i>
     */
    public void av_frame_set_pkt_pos(Pointer<AVFrame > frame, long val) {
        av_frame_set_pkt_pos(Pointer.getPeer(frame), val);
    }
    protected native void av_frame_set_pkt_pos(@Ptr long frame, long val);
    /**
     * Original signature : <code>int64_t av_frame_get_channel_layout(const AVFrame*)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/frame.h:146</i>
     */
    public long av_frame_get_channel_layout(Pointer<AVFrame > frame) {
        return av_frame_get_channel_layout(Pointer.getPeer(frame));
    }
    protected native long av_frame_get_channel_layout(@Ptr long frame);
    /**
     * Original signature : <code>void av_frame_set_channel_layout(AVFrame*, int64_t)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/frame.h:148</i>
     */
    public void av_frame_set_channel_layout(Pointer<AVFrame > frame, long val) {
        av_frame_set_channel_layout(Pointer.getPeer(frame), val);
    }
    protected native void av_frame_set_channel_layout(@Ptr long frame, long val);
    /**
     * Original signature : <code>int av_frame_get_channels(const AVFrame*)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/frame.h:150</i>
     */
    public int av_frame_get_channels(Pointer<AVFrame > frame) {
        return av_frame_get_channels(Pointer.getPeer(frame));
    }
    protected native int av_frame_get_channels(@Ptr long frame);
    /**
     * Original signature : <code>void av_frame_set_channels(AVFrame*, int)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/frame.h:152</i>
     */
    public void av_frame_set_channels(Pointer<AVFrame > frame, int val) {
        av_frame_set_channels(Pointer.getPeer(frame), val);
    }
    protected native void av_frame_set_channels(@Ptr long frame, int val);
    /**
     * Original signature : <code>int av_frame_get_sample_rate(const AVFrame*)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/frame.h:154</i>
     */
    public int av_frame_get_sample_rate(Pointer<AVFrame > frame) {
        return av_frame_get_sample_rate(Pointer.getPeer(frame));
    }
    protected native int av_frame_get_sample_rate(@Ptr long frame);
    /**
     * Original signature : <code>void av_frame_set_sample_rate(AVFrame*, int)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/frame.h:156</i>
     */
    public void av_frame_set_sample_rate(Pointer<AVFrame > frame, int val) {
        av_frame_set_sample_rate(Pointer.getPeer(frame), val);
    }
    protected native void av_frame_set_sample_rate(@Ptr long frame, int val);
    /**
     * Original signature : <code>AVDictionary* av_frame_get_metadata(const AVFrame*)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/frame.h:158</i>
     */
    public Pointer<AVDictionary > av_frame_get_metadata(Pointer<AVFrame > frame) {
        return (Pointer)Pointer.pointerToAddress(av_frame_get_metadata(Pointer.getPeer(frame)), AVDictionary.class);
    }
    @Ptr
    protected native long av_frame_get_metadata(@Ptr long frame);
    /**
     * Original signature : <code>void av_frame_set_metadata(AVFrame*, AVDictionary*)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/frame.h:160</i>
     */
    public void av_frame_set_metadata(Pointer<AVFrame > frame, Pointer<AVDictionary > val) {
        av_frame_set_metadata(Pointer.getPeer(frame), Pointer.getPeer(val));
    }
    protected native void av_frame_set_metadata(@Ptr long frame, @Ptr long val);
    /**
     * Original signature : <code>int av_frame_get_decode_error_flags(const AVFrame*)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/frame.h:162</i>
     */
    public int av_frame_get_decode_error_flags(Pointer<AVFrame > frame) {
        return av_frame_get_decode_error_flags(Pointer.getPeer(frame));
    }
    protected native int av_frame_get_decode_error_flags(@Ptr long frame);
    /**
     * Original signature : <code>void av_frame_set_decode_error_flags(AVFrame*, int)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/frame.h:164</i>
     */
    public void av_frame_set_decode_error_flags(Pointer<AVFrame > frame, int val) {
        av_frame_set_decode_error_flags(Pointer.getPeer(frame), val);
    }
    protected native void av_frame_set_decode_error_flags(@Ptr long frame, int val);
    /**
     * Original signature : <code>int av_frame_get_pkt_size(const AVFrame*)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/frame.h:166</i>
     */
    public int av_frame_get_pkt_size(Pointer<AVFrame > frame) {
        return av_frame_get_pkt_size(Pointer.getPeer(frame));
    }
    protected native int av_frame_get_pkt_size(@Ptr long frame);
    /**
     * Original signature : <code>void av_frame_set_pkt_size(AVFrame*, int)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/frame.h:168</i>
     */
    public void av_frame_set_pkt_size(Pointer<AVFrame > frame, int val) {
        av_frame_set_pkt_size(Pointer.getPeer(frame), val);
    }
    protected native void av_frame_set_pkt_size(@Ptr long frame, int val);
    /**
     * Original signature : <code>AVDictionary** avpriv_frame_get_metadatap(AVFrame*)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/frame.h:170</i>
     */
    public Pointer<Pointer<AVDictionary > > avpriv_frame_get_metadatap(Pointer<AVFrame > frame) {
        return (Pointer)Pointer.pointerToAddress(avpriv_frame_get_metadatap(Pointer.getPeer(frame)), DefaultParameterizedType.paramType(Pointer.class, AVDictionary.class));
    }
    @Ptr
    protected native long avpriv_frame_get_metadatap(@Ptr long frame);
    /**
     * Original signature : <code>int8_t* av_frame_get_qp_table(AVFrame*, int*, int*)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/frame.h:172</i>
     */
    public Pointer<Byte > av_frame_get_qp_table(Pointer<AVFrame > f, Pointer<Integer > stride, Pointer<Integer > type) {
        return (Pointer)Pointer.pointerToAddress(av_frame_get_qp_table(Pointer.getPeer(f), Pointer.getPeer(stride), Pointer.getPeer(type)), Byte.class);
    }
    @Ptr
    protected native long av_frame_get_qp_table(@Ptr long f, @Ptr long stride, @Ptr long type);
    /**
     * Original signature : <code>int av_frame_set_qp_table(AVFrame*, AVBufferRef*, int, int)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/frame.h:174</i>
     */
    public int av_frame_set_qp_table(Pointer<AVFrame > f, Pointer<AVBufferRef > buf, int stride, int type) {
        return av_frame_set_qp_table(Pointer.getPeer(f), Pointer.getPeer(buf), stride, type);
    }
    protected native int av_frame_set_qp_table(@Ptr long f, @Ptr long buf, int stride, int type);
    /**
     * Original signature : <code>AVColorSpace av_frame_get_colorspace(const AVFrame*)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/frame.h:176</i>
     */
    public IntValuedEnum<AvutilLibrary.AVColorSpace > av_frame_get_colorspace(Pointer<AVFrame > frame) {
        return FlagSet.fromValue(av_frame_get_colorspace(Pointer.getPeer(frame)), AvutilLibrary.AVColorSpace.class);
    }
    protected native int av_frame_get_colorspace(@Ptr long frame);
    /**
     * Original signature : <code>void av_frame_set_colorspace(AVFrame*, AVColorSpace)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/frame.h:178</i>
     */
    public void av_frame_set_colorspace(Pointer<AVFrame > frame, IntValuedEnum<AvutilLibrary.AVColorSpace > val) {
        av_frame_set_colorspace(Pointer.getPeer(frame), (int)val.value());
    }
    protected native void av_frame_set_colorspace(@Ptr long frame, int val);
    /**
     * Original signature : <code>AVColorRange av_frame_get_color_range(const AVFrame*)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/frame.h:180</i>
     */
    public IntValuedEnum<AvutilLibrary.AVColorRange > av_frame_get_color_range(Pointer<AVFrame > frame) {
        return FlagSet.fromValue(av_frame_get_color_range(Pointer.getPeer(frame)), AvutilLibrary.AVColorRange.class);
    }
    protected native int av_frame_get_color_range(@Ptr long frame);
    /**
     * Original signature : <code>void av_frame_set_color_range(AVFrame*, AVColorRange)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/frame.h:182</i>
     */
    public void av_frame_set_color_range(Pointer<AVFrame > frame, IntValuedEnum<AvutilLibrary.AVColorRange > val) {
        av_frame_set_color_range(Pointer.getPeer(frame), (int)val.value());
    }
    protected native void av_frame_set_color_range(@Ptr long frame, int val);
    /**
     * Get the name of a colorspace.<br>
     * @return a static string identifying the colorspace; can be NULL.<br>
     * Original signature : <code>char* av_get_colorspace_name(AVColorSpace)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/frame.h:188</i>
     */
    public Pointer<Byte > av_get_colorspace_name(IntValuedEnum<AvutilLibrary.AVColorSpace > val) {
        return (Pointer)Pointer.pointerToAddress(av_get_colorspace_name((int)val.value()), Byte.class);
    }
    @Ptr
    protected native long av_get_colorspace_name(int val);
    /**
     * Allocate an AVFrame and set its fields to default values.  The resulting<br>
     * struct must be freed using av_frame_free().<br>
     * @return An AVFrame filled with default values or NULL on failure.<br>
     * @note this only allocates the AVFrame itself, not the data buffers. Those<br>
     * must be allocated through other means, e.g. with av_frame_get_buffer() or<br>
     * manually.<br>
     * Original signature : <code>AVFrame* av_frame_alloc()</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/frame.h:198</i>
     */
    public Pointer<AVFrame > av_frame_alloc() {
        return (Pointer)Pointer.pointerToAddress(av_frame_alloc$2(), AVFrame.class);
    }
    @Ptr
    @Name("av_frame_alloc")
    protected native long av_frame_alloc$2();
    /**
     * Free the frame and any dynamically allocated objects in it,<br>
     * e.g. extended_data. If the frame is reference counted, it will be<br>
     * unreferenced first.<br>
     * @param frame frame to be freed. The pointer will be set to NULL.<br>
     * Original signature : <code>void av_frame_free(AVFrame**)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/frame.h:206</i>
     */
    public void av_frame_free(Pointer<Pointer<AVFrame > > frame) {
        av_frame_free(Pointer.getPeer(frame));
    }
    protected native void av_frame_free(@Ptr long frame);
    /**
     * Set up a new reference to the data described by the source frame.<br>
     * Copy frame properties from src to dst and create a new reference for each<br>
     * AVBufferRef from src.<br>
     * If src is not reference counted, new buffers are allocated and the data is<br>
     * copied.<br>
     * @return 0 on success, a negative AVERROR on error<br>
     * Original signature : <code>int av_frame_ref(AVFrame*, const AVFrame*)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/frame.h:216</i>
     */
    public int av_frame_ref(Pointer<AVFrame > dst, Pointer<AVFrame > src) {
        return av_frame_ref(Pointer.getPeer(dst), Pointer.getPeer(src));
    }
    protected native int av_frame_ref(@Ptr long dst, @Ptr long src);
    /**
     * Create a new frame that references the same data as src.<br>
     * This is a shortcut for av_frame_alloc()+av_frame_ref().<br>
     * @return newly created AVFrame on success, NULL on error.<br>
     * Original signature : <code>AVFrame* av_frame_clone(const AVFrame*)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/frame.h:223</i>
     */
    public Pointer<AVFrame > av_frame_clone(Pointer<AVFrame > src) {
        return (Pointer)Pointer.pointerToAddress(av_frame_clone(Pointer.getPeer(src)), AVFrame.class);
    }
    @Ptr
    protected native long av_frame_clone(@Ptr long src);
    /**
     * Unreference all the buffers referenced by frame and reset the frame fields.<br>
     * Original signature : <code>void av_frame_unref(AVFrame*)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/frame.h:228</i>
     */
    public void av_frame_unref(Pointer<AVFrame > frame) {
        av_frame_unref(Pointer.getPeer(frame));
    }
    protected native void av_frame_unref(@Ptr long frame);
    /**
     * Move everything contained in src to dst and reset src.<br>
     * Original signature : <code>void av_frame_move_ref(AVFrame*, AVFrame*)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/frame.h:233</i>
     */
    public void av_frame_move_ref(Pointer<AVFrame > dst, Pointer<AVFrame > src) {
        av_frame_move_ref(Pointer.getPeer(dst), Pointer.getPeer(src));
    }
    protected native void av_frame_move_ref(@Ptr long dst, @Ptr long src);
    /**
     * Allocate new buffer(s) for audio or video data.<br>
     * The following fields must be set on frame before calling this function:<br>
     * - format (pixel format for video, sample format for audio)<br>
     * - width and height for video<br>
     * - nb_samples and channel_layout for audio<br>
     * This function will fill AVFrame.data and AVFrame.buf arrays and, if<br>
     * necessary, allocate and fill AVFrame.extended_data and AVFrame.extended_buf.<br>
     * For planar formats, one buffer will be allocated for each plane.<br>
     * @param frame frame in which to store the new buffers.<br>
     * @param align required buffer size alignment<br>
     * @return 0 on success, a negative AVERROR on error.<br>
     * Original signature : <code>int av_frame_get_buffer(AVFrame*, int)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/frame.h:248</i>
     */
    public int av_frame_get_buffer(Pointer<AVFrame > frame, int align) {
        return av_frame_get_buffer(Pointer.getPeer(frame), align);
    }
    protected native int av_frame_get_buffer(@Ptr long frame, int align);
    /**
     * Check if the frame data is writable.<br>
     * @return A positive value if the frame data is writable (which is true if and<br>
     * only if each of the underlying buffers has only one reference, namely the one<br>
     * stored in this frame). Return 0 otherwise.<br>
     * If 1 is returned the answer is valid until av_buffer_ref() is called on any<br>
     * of the underlying AVBufferRefs (e.g. through av_frame_ref() or directly).<br>
     * @see av_frame_make_writable(), av_buffer_is_writable()<br>
     * Original signature : <code>int av_frame_is_writable(AVFrame*)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/frame.h:259</i>
     */
    public int av_frame_is_writable(Pointer<AVFrame > frame) {
        return av_frame_is_writable(Pointer.getPeer(frame));
    }
    protected native int av_frame_is_writable(@Ptr long frame);
    /**
     * Ensure that the frame data is writable, avoiding data copy if possible.<br>
     * Do nothing if the frame is writable, allocate new buffers and copy the data<br>
     * if it is not.<br>
     * @return 0 on success, a negative AVERROR on error.<br>
     * @see av_frame_is_writable(), av_buffer_is_writable(),<br>
     * av_buffer_make_writable()<br>
     * Original signature : <code>int av_frame_make_writable(AVFrame*)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/frame.h:269</i>
     */
    public int av_frame_make_writable(Pointer<AVFrame > frame) {
        return av_frame_make_writable(Pointer.getPeer(frame));
    }
    protected native int av_frame_make_writable(@Ptr long frame);
    /**
     * Copy the frame data from src to dst.<br>
     * This function does not allocate anything, dst must be already initialized and<br>
     * allocated with the same parameters as src.<br>
     * This function only copies the frame data (i.e. the contents of the data /<br>
     * extended data arrays), not any other properties.<br>
     * @return >= 0 on success, a negative AVERROR on error.<br>
     * Original signature : <code>int av_frame_copy(AVFrame*, const AVFrame*)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/frame.h:279</i>
     */
    public int av_frame_copy(Pointer<AVFrame > dst, Pointer<AVFrame > src) {
        return av_frame_copy(Pointer.getPeer(dst), Pointer.getPeer(src));
    }
    protected native int av_frame_copy(@Ptr long dst, @Ptr long src);
    /**
     * Copy only "metadata" fields from src to dst.<br>
     * Metadata for the purpose of this function are those fields that do not affect<br>
     * the data layout in the buffers.  E.g. pts, sample rate (for audio) or sample<br>
     * aspect ratio (for video), but not width/height or channel layout.<br>
     * Side data is also copied.<br>
     * Original signature : <code>int av_frame_copy_props(AVFrame*, const AVFrame*)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/frame.h:288</i>
     */
    public int av_frame_copy_props(Pointer<AVFrame > dst, Pointer<AVFrame > src) {
        return av_frame_copy_props(Pointer.getPeer(dst), Pointer.getPeer(src));
    }
    protected native int av_frame_copy_props(@Ptr long dst, @Ptr long src);
    /**
     * Get the buffer reference a given data plane is stored in.<br>
     * @param plane index of the data plane of interest in frame->extended_data.<br>
     * @return the buffer reference that contains the plane or NULL if the input<br>
     * frame is not valid.<br>
     * Original signature : <code>AVBufferRef* av_frame_get_plane_buffer(AVFrame*, int)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/frame.h:296</i>
     */
    public Pointer<AVBufferRef > av_frame_get_plane_buffer(Pointer<AVFrame > frame, int plane) {
        return (Pointer)Pointer.pointerToAddress(av_frame_get_plane_buffer(Pointer.getPeer(frame), plane), AVBufferRef.class);
    }
    @Ptr
    protected native long av_frame_get_plane_buffer(@Ptr long frame, int plane);
    /**
     * Add a new side data to a frame.<br>
     * @param frame a frame to which the side data should be added<br>
     * @param type type of the added side data<br>
     * @param size size of the side data<br>
     * @return newly added side data on success, NULL on error<br>
     * Original signature : <code>AVFrameSideData* av_frame_new_side_data(AVFrame*, AVFrameSideDataType, int)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/frame.h:305</i>
     */
    public Pointer<AVFrameSideData > av_frame_new_side_data(Pointer<AVFrame > frame, IntValuedEnum<AvutilLibrary.AVFrameSideDataType > type, int size) {
        return (Pointer)Pointer.pointerToAddress(av_frame_new_side_data(Pointer.getPeer(frame), (int)type.value(), size), AVFrameSideData.class);
    }
    @Ptr
    protected native long av_frame_new_side_data(@Ptr long frame, int type, int size);
    /**
     * @return a pointer to the side data of a given type on success, NULL if there<br>
     * is no side data with such type in this frame.<br>
     * Original signature : <code>AVFrameSideData* av_frame_get_side_data(const AVFrame*, AVFrameSideDataType)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/frame.h:311</i>
     */
    public Pointer<AVFrameSideData > av_frame_get_side_data(Pointer<AVFrame > frame, IntValuedEnum<AvutilLibrary.AVFrameSideDataType > type) {
        return (Pointer)Pointer.pointerToAddress(av_frame_get_side_data(Pointer.getPeer(frame), (int)type.value()), AVFrameSideData.class);
    }
    @Ptr
    protected native long av_frame_get_side_data(@Ptr long frame, int type);
    /**
     * If side data of the supplied type exists in the frame, free it and remove it<br>
     * from the frame.<br>
     * Original signature : <code>void av_frame_remove_side_data(AVFrame*, AVFrameSideDataType)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/frame.h:317</i>
     */
    public void av_frame_remove_side_data(Pointer<AVFrame > frame, IntValuedEnum<AvutilLibrary.AVFrameSideDataType > type) {
        av_frame_remove_side_data(Pointer.getPeer(frame), (int)type.value());
    }
    protected native void av_frame_remove_side_data(@Ptr long frame, int type);
    /**
     * @return a string identifying the side data type<br>
     * Original signature : <code>char* av_frame_side_data_name(AVFrameSideDataType)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/frame.h:322</i>
     */
    public Pointer<Byte > av_frame_side_data_name(IntValuedEnum<AvutilLibrary.AVFrameSideDataType > type) {
        return (Pointer)Pointer.pointerToAddress(av_frame_side_data_name((int)type.value()), Byte.class);
    }
    @Ptr
    protected native long av_frame_side_data_name(int type);
    /**
     * Show the obj options.<br>
     * @param req_flags requested flags for the options to show. Show only the<br>
     * options for which it is opt->flags & req_flags.<br>
     * @param rej_flags rejected flags for the options to show. Show only the<br>
     * options for which it is !(opt->flags & req_flags).<br>
     * @param av_log_obj log context to use for showing the options<br>
     * Original signature : <code>int av_opt_show2(void*, void*, int, int)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/opt.h:230</i>
     */
    public int av_opt_show2(Pointer<? > obj, Pointer<? > av_log_obj, int req_flags, int rej_flags) {
        return av_opt_show2(Pointer.getPeer(obj), Pointer.getPeer(av_log_obj), req_flags, rej_flags);
    }
    protected native int av_opt_show2(@Ptr long obj, @Ptr long av_log_obj, int req_flags, int rej_flags);
    /**
     * Set the values of all AVOption fields to their default values.<br>
     * @param s an AVOption-enabled struct (its first member must be a pointer to AVClass)<br>
     * Original signature : <code>void av_opt_set_defaults(void*)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/opt.h:236</i>
     */
    public void av_opt_set_defaults(Pointer<? > s) {
        av_opt_set_defaults(Pointer.getPeer(s));
    }
    protected native void av_opt_set_defaults(@Ptr long s);
    /**
     * Set the values of all AVOption fields to their default values. Only these<br>
     * AVOption fields for which (opt->flags & mask) == flags will have their<br>
     * default applied to s.<br>
     * @param s an AVOption-enabled struct (its first member must be a pointer to AVClass)<br>
     * @param mask combination of AV_OPT_FLAG_*<br>
     * @param flags combination of AV_OPT_FLAG_*<br>
     * Original signature : <code>void av_opt_set_defaults2(void*, int, int)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/opt.h:246</i>
     */
    public void av_opt_set_defaults2(Pointer<? > s, int mask, int flags) {
        av_opt_set_defaults2(Pointer.getPeer(s), mask, flags);
    }
    protected native void av_opt_set_defaults2(@Ptr long s, int mask, int flags);
    /**
     * Parse the key/value pairs list in opts. For each key/value pair<br>
     * found, stores the value in the field in ctx that is named like the<br>
     * key. ctx must be an AVClass context, storing is done using<br>
     * AVOptions.<br>
     * @param opts options string to parse, may be NULL<br>
     * @param key_val_sep a 0-terminated list of characters used to<br>
     * separate key from value<br>
     * @param pairs_sep a 0-terminated list of characters used to separate<br>
     * two pairs from each other<br>
     * @return the number of successfully set key/value pairs, or a negative<br>
     * value corresponding to an AVERROR code in case of error:<br>
     * AVERROR(EINVAL) if opts cannot be parsed,<br>
     * the error code issued by av_opt_set() if a key/value pair<br>
     * cannot be set<br>
     * Original signature : <code>int av_set_options_string(void*, const char*, const char*, const char*)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/opt.h:264</i>
     */
    public int av_set_options_string(Pointer<? > ctx, Pointer<Byte > opts, Pointer<Byte > key_val_sep, Pointer<Byte > pairs_sep) {
        return av_set_options_string(Pointer.getPeer(ctx), Pointer.getPeer(opts), Pointer.getPeer(key_val_sep), Pointer.getPeer(pairs_sep));
    }
    protected native int av_set_options_string(@Ptr long ctx, @Ptr long opts, @Ptr long key_val_sep, @Ptr long pairs_sep);
    /**
     * Parse the key-value pairs list in opts. For each key=value pair found,<br>
     * set the value of the corresponding option in ctx.<br>
     * @param ctx          the AVClass object to set options on<br>
     * @param opts         the options string, key-value pairs separated by a<br>
     *                     delimiter<br>
     * @param shorthand    a NULL-terminated array of options names for shorthand<br>
     *                     notation: if the first field in opts has no key part,<br>
     *                     the key is taken from the first element of shorthand;<br>
     *                     then again for the second, etc., until either opts is<br>
     *                     finished, shorthand is finished or a named option is<br>
     *                     found; after that, all options must be named<br>
     * @param key_val_sep  a 0-terminated list of characters used to separate<br>
     *                     key from value, for example '='<br>
     * @param pairs_sep    a 0-terminated list of characters used to separate<br>
     *                     two pairs from each other, for example ':' or ','<br>
     * @return  the number of successfully set key=value pairs, or a negative<br>
     *          value corresponding to an AVERROR code in case of error:<br>
     *          AVERROR(EINVAL) if opts cannot be parsed,<br>
     *          the error code issued by av_set_string3() if a key/value pair<br>
     *          cannot be set<br>
     * Options names must use only the following characters: a-z A-Z 0-9 - . / _<br>
     * Separators must use characters distinct from option names and from each<br>
     * other.<br>
     * Original signature : <code>int av_opt_set_from_string(void*, const char*, const const char**, const char*, const char*)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/opt.h:291</i>
     */
    public int av_opt_set_from_string(Pointer<? > ctx, Pointer<Byte > opts, Pointer<Pointer<Byte > > shorthand, Pointer<Byte > key_val_sep, Pointer<Byte > pairs_sep) {
        return av_opt_set_from_string(Pointer.getPeer(ctx), Pointer.getPeer(opts), Pointer.getPeer(shorthand), Pointer.getPeer(key_val_sep), Pointer.getPeer(pairs_sep));
    }
    protected native int av_opt_set_from_string(@Ptr long ctx, @Ptr long opts, @Ptr long shorthand, @Ptr long key_val_sep, @Ptr long pairs_sep);
    /**
     * Free all allocated objects in obj.<br>
     * Original signature : <code>void av_opt_free(void*)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/opt.h:296</i>
     */
    public void av_opt_free(Pointer<? > obj) {
        av_opt_free(Pointer.getPeer(obj));
    }
    protected native void av_opt_free(@Ptr long obj);
    /**
     * Check whether a particular flag is set in a flags field.<br>
     * @param field_name the name of the flag field option<br>
     * @param flag_name the name of the flag to check<br>
     * @return non-zero if the flag is set, zero if the flag isn't set,<br>
     *         isn't of the right type, or the flags field doesn't exist.<br>
     * Original signature : <code>int av_opt_flag_is_set(void*, const char*, const char*)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/opt.h:305</i>
     */
    public int av_opt_flag_is_set(Pointer<? > obj, Pointer<Byte > field_name, Pointer<Byte > flag_name) {
        return av_opt_flag_is_set(Pointer.getPeer(obj), Pointer.getPeer(field_name), Pointer.getPeer(flag_name));
    }
    protected native int av_opt_flag_is_set(@Ptr long obj, @Ptr long field_name, @Ptr long flag_name);
    /**
     * Set all the options from a given dictionary on an object.<br>
     * @param obj a struct whose first element is a pointer to AVClass<br>
     * @param options options to process. This dictionary will be freed and replaced<br>
     *                by a new one containing all options not found in obj.<br>
     *                Of course this new dictionary needs to be freed by caller<br>
     *                with av_dict_free().<br>
     * @return 0 on success, a negative AVERROR if some option was found in obj,<br>
     *         but could not be set.<br>
     * @see av_dict_copy()<br>
     * Original signature : <code>int av_opt_set_dict(void*, AVDictionary**)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/opt.h:318</i>
     */
    public int av_opt_set_dict(Pointer<? > obj, Pointer<Pointer<AVDictionary > > options) {
        return av_opt_set_dict(Pointer.getPeer(obj), Pointer.getPeer(options));
    }
    protected native int av_opt_set_dict(@Ptr long obj, @Ptr long options);
    /**
     * Set all the options from a given dictionary on an object.<br>
     * @param obj a struct whose first element is a pointer to AVClass<br>
     * @param options options to process. This dictionary will be freed and replaced<br>
     *                by a new one containing all options not found in obj.<br>
     *                Of course this new dictionary needs to be freed by caller<br>
     *                with av_dict_free().<br>
     * @param search_flags A combination of AV_OPT_SEARCH_*.<br>
     * @return 0 on success, a negative AVERROR if some option was found in obj,<br>
     *         but could not be set.<br>
     * @see av_dict_copy()<br>
     * Original signature : <code>int av_opt_set_dict2(void*, AVDictionary**, int)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/opt.h:332</i>
     */
    public int av_opt_set_dict2(Pointer<? > obj, Pointer<Pointer<AVDictionary > > options, int search_flags) {
        return av_opt_set_dict2(Pointer.getPeer(obj), Pointer.getPeer(options), search_flags);
    }
    protected native int av_opt_set_dict2(@Ptr long obj, @Ptr long options, int search_flags);
    /**
     * Extract a key-value pair from the beginning of a string.<br>
     * @param ropts        pointer to the options string, will be updated to<br>
     *                     point to the rest of the string (one of the pairs_sep<br>
     *                     or the final NUL)<br>
     * @param key_val_sep  a 0-terminated list of characters used to separate<br>
     *                     key from value, for example '='<br>
     * @param pairs_sep    a 0-terminated list of characters used to separate<br>
     *                     two pairs from each other, for example ':' or ','<br>
     * @param flags        flags; see the AV_OPT_FLAG_* values below<br>
     * @param rkey         parsed key; must be freed using av_free()<br>
     * @param rval         parsed value; must be freed using av_free()<br>
     * @return  >=0 for success, or a negative value corresponding to an<br>
     *          AVERROR code in case of error; in particular:<br>
     *          AVERROR(EINVAL) if no key is present<br>
     * Original signature : <code>int av_opt_get_key_value(const char**, const char*, const char*, unsigned, char**, char**)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/opt.h:350</i>
     */
    public int av_opt_get_key_value(Pointer<Pointer<Byte > > ropts, Pointer<Byte > key_val_sep, Pointer<Byte > pairs_sep, int flags, Pointer<Pointer<Byte > > rkey, Pointer<Pointer<Byte > > rval) {
        return av_opt_get_key_value(Pointer.getPeer(ropts), Pointer.getPeer(key_val_sep), Pointer.getPeer(pairs_sep), flags, Pointer.getPeer(rkey), Pointer.getPeer(rval));
    }
    protected native int av_opt_get_key_value(@Ptr long ropts, @Ptr long key_val_sep, @Ptr long pairs_sep, int flags, @Ptr long rkey, @Ptr long rval);
    /**
     * @defgroup opt_eval_funcs Evaluating option strings<br>
     * @{<br>
     * This group of functions can be used to evaluate option strings<br>
     * and get numbers out of them. They do the same thing as av_opt_set(),<br>
     * except the result is written into the caller-supplied pointer.<br>
     * @param obj a struct whose first element is a pointer to AVClass.<br>
     * @param o an option for which the string is to be evaluated.<br>
     * @param val string to be evaluated.<br>
     * @param *_out value of the string will be written here.<br>
     * @return 0 on success, a negative number on failure.<br>
     * Original signature : <code>int av_opt_eval_flags(void*, const AVOption*, const char*, int*)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/opt.h:367</i>
     */
    public int av_opt_eval_flags(Pointer<? > obj, Pointer<AVOption > o, Pointer<Byte > val, Pointer<Integer > flags_out) {
        return av_opt_eval_flags(Pointer.getPeer(obj), Pointer.getPeer(o), Pointer.getPeer(val), Pointer.getPeer(flags_out));
    }
    protected native int av_opt_eval_flags(@Ptr long obj, @Ptr long o, @Ptr long val, @Ptr long flags_out);
    /**
     * Original signature : <code>int av_opt_eval_int(void*, const AVOption*, const char*, int*)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/opt.h:369</i>
     */
    public int av_opt_eval_int(Pointer<? > obj, Pointer<AVOption > o, Pointer<Byte > val, Pointer<Integer > int_out) {
        return av_opt_eval_int(Pointer.getPeer(obj), Pointer.getPeer(o), Pointer.getPeer(val), Pointer.getPeer(int_out));
    }
    protected native int av_opt_eval_int(@Ptr long obj, @Ptr long o, @Ptr long val, @Ptr long int_out);
    /**
     * Original signature : <code>int av_opt_eval_int64(void*, const AVOption*, const char*, int64_t*)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/opt.h:371</i>
     */
    public int av_opt_eval_int64(Pointer<? > obj, Pointer<AVOption > o, Pointer<Byte > val, Pointer<Long > int64_out) {
        return av_opt_eval_int64(Pointer.getPeer(obj), Pointer.getPeer(o), Pointer.getPeer(val), Pointer.getPeer(int64_out));
    }
    protected native int av_opt_eval_int64(@Ptr long obj, @Ptr long o, @Ptr long val, @Ptr long int64_out);
    /**
     * Original signature : <code>int av_opt_eval_float(void*, const AVOption*, const char*, float*)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/opt.h:373</i>
     */
    public int av_opt_eval_float(Pointer<? > obj, Pointer<AVOption > o, Pointer<Byte > val, Pointer<Float > float_out) {
        return av_opt_eval_float(Pointer.getPeer(obj), Pointer.getPeer(o), Pointer.getPeer(val), Pointer.getPeer(float_out));
    }
    protected native int av_opt_eval_float(@Ptr long obj, @Ptr long o, @Ptr long val, @Ptr long float_out);
    /**
     * Original signature : <code>int av_opt_eval_double(void*, const AVOption*, const char*, double*)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/opt.h:375</i>
     */
    public int av_opt_eval_double(Pointer<? > obj, Pointer<AVOption > o, Pointer<Byte > val, Pointer<Double > double_out) {
        return av_opt_eval_double(Pointer.getPeer(obj), Pointer.getPeer(o), Pointer.getPeer(val), Pointer.getPeer(double_out));
    }
    protected native int av_opt_eval_double(@Ptr long obj, @Ptr long o, @Ptr long val, @Ptr long double_out);
    /**
     * Original signature : <code>int av_opt_eval_q(void*, const AVOption*, const char*, AVRational*)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/opt.h:377</i>
     */
    public int av_opt_eval_q(Pointer<? > obj, Pointer<AVOption > o, Pointer<Byte > val, Pointer<AVRational > q_out) {
        return av_opt_eval_q(Pointer.getPeer(obj), Pointer.getPeer(o), Pointer.getPeer(val), Pointer.getPeer(q_out));
    }
    protected native int av_opt_eval_q(@Ptr long obj, @Ptr long o, @Ptr long val, @Ptr long q_out);
    /**
     * Look for an option in an object. Consider only options which<br>
     * have all the specified flags set.<br>
     * @param[in] obj A pointer to a struct whose first element is a<br>
     *                pointer to an AVClass.<br>
     *                Alternatively a double pointer to an AVClass, if<br>
     *                AV_OPT_SEARCH_FAKE_OBJ search flag is set.<br>
     * @param[in] name The name of the option to look for.<br>
     * @param[in] unit When searching for named constants, name of the unit<br>
     *                 it belongs to.<br>
     * @param opt_flags Find only options with all the specified flags set (AV_OPT_FLAG).<br>
     * @param search_flags A combination of AV_OPT_SEARCH_*.<br>
     * @return A pointer to the option found, or NULL if no option<br>
     *         was found.<br>
     * @note Options found with AV_OPT_SEARCH_CHILDREN flag may not be settable<br>
     * directly with av_opt_set(). Use special calls which take an options<br>
     * AVDictionary (e.g. avformat_open_input()) to set options found with this<br>
     * flag.<br>
     * Original signature : <code>AVOption* av_opt_find(void*, const char*, const char*, int, int)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/opt.h:398</i>
     */
    public Pointer<AVOption > av_opt_find(Pointer<? > obj, Pointer<Byte > name, Pointer<Byte > unit, int opt_flags, int search_flags) {
        return (Pointer)Pointer.pointerToAddress(av_opt_find(Pointer.getPeer(obj), Pointer.getPeer(name), Pointer.getPeer(unit), opt_flags, search_flags), AVOption.class);
    }
    @Ptr
    protected native long av_opt_find(@Ptr long obj, @Ptr long name, @Ptr long unit, int opt_flags, int search_flags);
    /**
     * Look for an option in an object. Consider only options which<br>
     * have all the specified flags set.<br>
     * @param[in] obj A pointer to a struct whose first element is a<br>
     *                pointer to an AVClass.<br>
     *                Alternatively a double pointer to an AVClass, if<br>
     *                AV_OPT_SEARCH_FAKE_OBJ search flag is set.<br>
     * @param[in] name The name of the option to look for.<br>
     * @param[in] unit When searching for named constants, name of the unit<br>
     *                 it belongs to.<br>
     * @param opt_flags Find only options with all the specified flags set (AV_OPT_FLAG).<br>
     * @param search_flags A combination of AV_OPT_SEARCH_*.<br>
     * @param[out] target_obj if non-NULL, an object to which the option belongs will be<br>
     * written here. It may be different from obj if AV_OPT_SEARCH_CHILDREN is present<br>
     * in search_flags. This parameter is ignored if search_flags contain<br>
     * AV_OPT_SEARCH_FAKE_OBJ.<br>
     * @return A pointer to the option found, or NULL if no option<br>
     *         was found.<br>
     * Original signature : <code>AVOption* av_opt_find2(void*, const char*, const char*, int, int, void**)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/opt.h:419</i>
     */
    public Pointer<AVOption > av_opt_find2(Pointer<? > obj, Pointer<Byte > name, Pointer<Byte > unit, int opt_flags, int search_flags, Pointer<Pointer<? > > target_obj) {
        return (Pointer)Pointer.pointerToAddress(av_opt_find2(Pointer.getPeer(obj), Pointer.getPeer(name), Pointer.getPeer(unit), opt_flags, search_flags, Pointer.getPeer(target_obj)), AVOption.class);
    }
    @Ptr
    protected native long av_opt_find2(@Ptr long obj, @Ptr long name, @Ptr long unit, int opt_flags, int search_flags, @Ptr long target_obj);
    /**
     * Iterate over all AVOptions belonging to obj.<br>
     * @param obj an AVOptions-enabled struct or a double pointer to an<br>
     *            AVClass describing it.<br>
     * @param prev result of the previous call to av_opt_next() on this object<br>
     *             or NULL<br>
     * @return next AVOption or NULL<br>
     * Original signature : <code>AVOption* av_opt_next(const void*, const AVOption*)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/opt.h:429</i>
     */
    public Pointer<AVOption > av_opt_next(Pointer<? > obj, Pointer<AVOption > prev) {
        return (Pointer)Pointer.pointerToAddress(av_opt_next(Pointer.getPeer(obj), Pointer.getPeer(prev)), AVOption.class);
    }
    @Ptr
    protected native long av_opt_next(@Ptr long obj, @Ptr long prev);
    /**
     * Iterate over AVOptions-enabled children of obj.<br>
     * @param prev result of a previous call to this function or NULL<br>
     * @return next AVOptions-enabled child or NULL<br>
     * Original signature : <code>void* av_opt_child_next(void*, void*)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/opt.h:436</i>
     */
    public Pointer<? > av_opt_child_next(Pointer<? > obj, Pointer<? > prev) {
        return Pointer.pointerToAddress(av_opt_child_next(Pointer.getPeer(obj), Pointer.getPeer(prev)));
    }
    @Ptr
    protected native long av_opt_child_next(@Ptr long obj, @Ptr long prev);
    /**
     * Iterate over potential AVOptions-enabled children of parent.<br>
     * @param prev result of a previous call to this function or NULL<br>
     * @return AVClass corresponding to next potential child or NULL<br>
     * Original signature : <code>AVClass* av_opt_child_class_next(const AVClass*, const AVClass*)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/opt.h:443</i>
     */
    public Pointer<AVClass > av_opt_child_class_next(Pointer<AVClass > parent, Pointer<AVClass > prev) {
        return (Pointer)Pointer.pointerToAddress(av_opt_child_class_next(Pointer.getPeer(parent), Pointer.getPeer(prev)), AVClass.class);
    }
    @Ptr
    protected native long av_opt_child_class_next(@Ptr long parent, @Ptr long prev);
    /**
     * @defgroup opt_set_funcs Option setting functions<br>
     * @{<br>
     * Those functions set the field of obj with the given name to value.<br>
     * @param[in] obj A struct whose first element is a pointer to an AVClass.<br>
     * @param[in] name the name of the field to set<br>
     * @param[in] val The value to set. In case of av_opt_set() if the field is not<br>
     * of a string type, then the given string is parsed.<br>
     * SI postfixes and some named scalars are supported.<br>
     * If the field is of a numeric type, it has to be a numeric or named<br>
     * scalar. Behavior with more than one scalar and +- infix operators<br>
     * is undefined.<br>
     * If the field is of a flags type, it has to be a sequence of numeric<br>
     * scalars or named flags separated by '+' or '-'. Prefixing a flag<br>
     * with '+' causes it to be set without affecting the other flags;<br>
     * similarly, '-' unsets a flag.<br>
     * @param search_flags flags passed to av_opt_find2. I.e. if AV_OPT_SEARCH_CHILDREN<br>
     * is passed here, then the option may be set on a child of obj.<br>
     * @return 0 if the value has been set, or an AVERROR code in case of<br>
     * error:<br>
     * AVERROR_OPTION_NOT_FOUND if no matching option exists<br>
     * AVERROR(ERANGE) if the value is out of range<br>
     * AVERROR(EINVAL) if the value is not valid<br>
     * Original signature : <code>int av_opt_set(void*, const char*, const char*, int)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/opt.h:469</i>
     */
    public int av_opt_set(Pointer<? > obj, Pointer<Byte > name, Pointer<Byte > val, int search_flags) {
        return av_opt_set(Pointer.getPeer(obj), Pointer.getPeer(name), Pointer.getPeer(val), search_flags);
    }
    protected native int av_opt_set(@Ptr long obj, @Ptr long name, @Ptr long val, int search_flags);
    /**
     * Original signature : <code>int av_opt_set_int(void*, const char*, int64_t, int)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/opt.h:471</i>
     */
    public int av_opt_set_int(Pointer<? > obj, Pointer<Byte > name, long val, int search_flags) {
        return av_opt_set_int(Pointer.getPeer(obj), Pointer.getPeer(name), val, search_flags);
    }
    protected native int av_opt_set_int(@Ptr long obj, @Ptr long name, long val, int search_flags);
    /**
     * Original signature : <code>int av_opt_set_double(void*, const char*, double, int)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/opt.h:473</i>
     */
    public int av_opt_set_double(Pointer<? > obj, Pointer<Byte > name, double val, int search_flags) {
        return av_opt_set_double(Pointer.getPeer(obj), Pointer.getPeer(name), val, search_flags);
    }
    protected native int av_opt_set_double(@Ptr long obj, @Ptr long name, double val, int search_flags);
    /**
     * Original signature : <code>int av_opt_set_q(void*, const char*, AVRational, int)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/opt.h:475</i>
     */
    public int av_opt_set_q(Pointer<? > obj, Pointer<Byte > name, AVRational val, int search_flags) {
        return av_opt_set_q(Pointer.getPeer(obj), Pointer.getPeer(name), val, search_flags);
    }
    protected native int av_opt_set_q(@Ptr long obj, @Ptr long name, AVRational val, int search_flags);
    /**
     * Original signature : <code>int av_opt_set_bin(void*, const char*, const uint8_t*, int, int)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/opt.h:477</i>
     */
    public int av_opt_set_bin(Pointer<? > obj, Pointer<Byte > name, Pointer<Byte > val, int size, int search_flags) {
        return av_opt_set_bin(Pointer.getPeer(obj), Pointer.getPeer(name), Pointer.getPeer(val), size, search_flags);
    }
    protected native int av_opt_set_bin(@Ptr long obj, @Ptr long name, @Ptr long val, int size, int search_flags);
    /**
     * Original signature : <code>int av_opt_set_image_size(void*, const char*, int, int, int)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/opt.h:479</i>
     */
    public int av_opt_set_image_size(Pointer<? > obj, Pointer<Byte > name, int w, int h, int search_flags) {
        return av_opt_set_image_size(Pointer.getPeer(obj), Pointer.getPeer(name), w, h, search_flags);
    }
    protected native int av_opt_set_image_size(@Ptr long obj, @Ptr long name, int w, int h, int search_flags);
    /**
     * Original signature : <code>int av_opt_set_pixel_fmt(void*, const char*, AVPixelFormat, int)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/opt.h:481</i>
     */
    public int av_opt_set_pixel_fmt(Pointer<? > obj, Pointer<Byte > name, IntValuedEnum<AvutilLibrary.AVPixelFormat > fmt, int search_flags) {
        return av_opt_set_pixel_fmt(Pointer.getPeer(obj), Pointer.getPeer(name), (int)fmt.value(), search_flags);
    }
    protected native int av_opt_set_pixel_fmt(@Ptr long obj, @Ptr long name, int fmt, int search_flags);
    /**
     * Original signature : <code>int av_opt_set_sample_fmt(void*, const char*, AVSampleFormat, int)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/opt.h:483</i>
     */
    public int av_opt_set_sample_fmt(Pointer<? > obj, Pointer<Byte > name, IntValuedEnum<AvutilLibrary.AVSampleFormat > fmt, int search_flags) {
        return av_opt_set_sample_fmt(Pointer.getPeer(obj), Pointer.getPeer(name), (int)fmt.value(), search_flags);
    }
    protected native int av_opt_set_sample_fmt(@Ptr long obj, @Ptr long name, int fmt, int search_flags);
    /**
     * Original signature : <code>int av_opt_set_video_rate(void*, const char*, AVRational, int)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/opt.h:485</i>
     */
    public int av_opt_set_video_rate(Pointer<? > obj, Pointer<Byte > name, AVRational val, int search_flags) {
        return av_opt_set_video_rate(Pointer.getPeer(obj), Pointer.getPeer(name), val, search_flags);
    }
    protected native int av_opt_set_video_rate(@Ptr long obj, @Ptr long name, AVRational val, int search_flags);
    /**
     * Original signature : <code>int av_opt_set_channel_layout(void*, const char*, int64_t, int)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/opt.h:487</i>
     */
    public int av_opt_set_channel_layout(Pointer<? > obj, Pointer<Byte > name, long ch_layout, int search_flags) {
        return av_opt_set_channel_layout(Pointer.getPeer(obj), Pointer.getPeer(name), ch_layout, search_flags);
    }
    protected native int av_opt_set_channel_layout(@Ptr long obj, @Ptr long name, long ch_layout, int search_flags);
    /**
     * @note Any old dictionary present is discarded and replaced with a copy of the new one. The<br>
     * caller still owns val is and responsible for freeing it.<br>
     * Original signature : <code>int av_opt_set_dict_val(void*, const char*, const AVDictionary*, int)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/opt.h:493</i>
     */
    public int av_opt_set_dict_val(Pointer<? > obj, Pointer<Byte > name, Pointer<AVDictionary > val, int search_flags) {
        return av_opt_set_dict_val(Pointer.getPeer(obj), Pointer.getPeer(name), Pointer.getPeer(val), search_flags);
    }
    protected native int av_opt_set_dict_val(@Ptr long obj, @Ptr long name, @Ptr long val, int search_flags);
    /**
     * @note the returned string will be av_malloc()ed and must be av_free()ed by the caller<br>
     * @note if AV_OPT_ALLOW_NULL is set in search_flags in av_opt_get, and the option has<br>
     * AV_OPT_TYPE_STRING or AV_OPT_TYPE_BINARY and is set to NULL, *out_val will be set<br>
     * to NULL instead of an allocated empty string.<br>
     * Original signature : <code>int av_opt_get(void*, const char*, int, uint8_t**)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/opt.h:501</i>
     */
    public int av_opt_get(Pointer<? > obj, Pointer<Byte > name, int search_flags, Pointer<Pointer<Byte > > out_val) {
        return av_opt_get(Pointer.getPeer(obj), Pointer.getPeer(name), search_flags, Pointer.getPeer(out_val));
    }
    protected native int av_opt_get(@Ptr long obj, @Ptr long name, int search_flags, @Ptr long out_val);
    /**
     * Original signature : <code>int av_opt_get_int(void*, const char*, int, int64_t*)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/opt.h:503</i>
     */
    public int av_opt_get_int(Pointer<? > obj, Pointer<Byte > name, int search_flags, Pointer<Long > out_val) {
        return av_opt_get_int(Pointer.getPeer(obj), Pointer.getPeer(name), search_flags, Pointer.getPeer(out_val));
    }
    protected native int av_opt_get_int(@Ptr long obj, @Ptr long name, int search_flags, @Ptr long out_val);
    /**
     * Original signature : <code>int av_opt_get_double(void*, const char*, int, double*)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/opt.h:505</i>
     */
    public int av_opt_get_double(Pointer<? > obj, Pointer<Byte > name, int search_flags, Pointer<Double > out_val) {
        return av_opt_get_double(Pointer.getPeer(obj), Pointer.getPeer(name), search_flags, Pointer.getPeer(out_val));
    }
    protected native int av_opt_get_double(@Ptr long obj, @Ptr long name, int search_flags, @Ptr long out_val);
    /**
     * Original signature : <code>int av_opt_get_q(void*, const char*, int, AVRational*)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/opt.h:507</i>
     */
    public int av_opt_get_q(Pointer<? > obj, Pointer<Byte > name, int search_flags, Pointer<AVRational > out_val) {
        return av_opt_get_q(Pointer.getPeer(obj), Pointer.getPeer(name), search_flags, Pointer.getPeer(out_val));
    }
    protected native int av_opt_get_q(@Ptr long obj, @Ptr long name, int search_flags, @Ptr long out_val);
    /**
     * Original signature : <code>int av_opt_get_image_size(void*, const char*, int, int*, int*)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/opt.h:509</i>
     */
    public int av_opt_get_image_size(Pointer<? > obj, Pointer<Byte > name, int search_flags, Pointer<Integer > w_out, Pointer<Integer > h_out) {
        return av_opt_get_image_size(Pointer.getPeer(obj), Pointer.getPeer(name), search_flags, Pointer.getPeer(w_out), Pointer.getPeer(h_out));
    }
    protected native int av_opt_get_image_size(@Ptr long obj, @Ptr long name, int search_flags, @Ptr long w_out, @Ptr long h_out);
    /**
     * Original signature : <code>int av_opt_get_pixel_fmt(void*, const char*, int, AVPixelFormat*)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/opt.h:511</i>
     */
    public int av_opt_get_pixel_fmt(Pointer<? > obj, Pointer<Byte > name, int search_flags, Pointer<IntValuedEnum<AvutilLibrary.AVPixelFormat > > out_fmt) {
        return av_opt_get_pixel_fmt(Pointer.getPeer(obj), Pointer.getPeer(name), search_flags, Pointer.getPeer(out_fmt));
    }
    protected native int av_opt_get_pixel_fmt(@Ptr long obj, @Ptr long name, int search_flags, @Ptr long out_fmt);
    /**
     * Original signature : <code>int av_opt_get_sample_fmt(void*, const char*, int, AVSampleFormat*)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/opt.h:513</i>
     */
    public int av_opt_get_sample_fmt(Pointer<? > obj, Pointer<Byte > name, int search_flags, Pointer<IntValuedEnum<AvutilLibrary.AVSampleFormat > > out_fmt) {
        return av_opt_get_sample_fmt(Pointer.getPeer(obj), Pointer.getPeer(name), search_flags, Pointer.getPeer(out_fmt));
    }
    protected native int av_opt_get_sample_fmt(@Ptr long obj, @Ptr long name, int search_flags, @Ptr long out_fmt);
    /**
     * Original signature : <code>int av_opt_get_video_rate(void*, const char*, int, AVRational*)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/opt.h:515</i>
     */
    public int av_opt_get_video_rate(Pointer<? > obj, Pointer<Byte > name, int search_flags, Pointer<AVRational > out_val) {
        return av_opt_get_video_rate(Pointer.getPeer(obj), Pointer.getPeer(name), search_flags, Pointer.getPeer(out_val));
    }
    protected native int av_opt_get_video_rate(@Ptr long obj, @Ptr long name, int search_flags, @Ptr long out_val);
    /**
     * Original signature : <code>int av_opt_get_channel_layout(void*, const char*, int, int64_t*)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/opt.h:517</i>
     */
    public int av_opt_get_channel_layout(Pointer<? > obj, Pointer<Byte > name, int search_flags, Pointer<Long > ch_layout) {
        return av_opt_get_channel_layout(Pointer.getPeer(obj), Pointer.getPeer(name), search_flags, Pointer.getPeer(ch_layout));
    }
    protected native int av_opt_get_channel_layout(@Ptr long obj, @Ptr long name, int search_flags, @Ptr long ch_layout);
    /**
     * @param[out] out_val The returned dictionary is a copy of the actual value and must<br>
     * be freed with av_dict_free() by the caller<br>
     * Original signature : <code>int av_opt_get_dict_val(void*, const char*, int, AVDictionary**)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/opt.h:523</i>
     */
    public int av_opt_get_dict_val(Pointer<? > obj, Pointer<Byte > name, int search_flags, Pointer<Pointer<AVDictionary > > out_val) {
        return av_opt_get_dict_val(Pointer.getPeer(obj), Pointer.getPeer(name), search_flags, Pointer.getPeer(out_val));
    }
    protected native int av_opt_get_dict_val(@Ptr long obj, @Ptr long name, int search_flags, @Ptr long out_val);
    /**
     * Gets a pointer to the requested field in a struct.<br>
     * This function allows accessing a struct even when its fields are moved or<br>
     * renamed since the application making the access has been compiled,<br>
     * @returns a pointer to the field, it can be cast to the correct type and read<br>
     *          or written to.<br>
     * Original signature : <code>void* av_opt_ptr(const AVClass*, void*, const char*)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/opt.h:532</i>
     */
    public Pointer<? > av_opt_ptr(Pointer<AVClass > avclass, Pointer<? > obj, Pointer<Byte > name) {
        return Pointer.pointerToAddress(av_opt_ptr(Pointer.getPeer(avclass), Pointer.getPeer(obj), Pointer.getPeer(name)));
    }
    @Ptr
    protected native long av_opt_ptr(@Ptr long avclass, @Ptr long obj, @Ptr long name);
    /**
     * Free an AVOptionRanges struct and set it to NULL.<br>
     * Original signature : <code>void av_opt_freep_ranges(AVOptionRanges**)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/opt.h:537</i>
     */
    public void av_opt_freep_ranges(Pointer<Pointer<AVOptionRanges > > ranges) {
        av_opt_freep_ranges(Pointer.getPeer(ranges));
    }
    protected native void av_opt_freep_ranges(@Ptr long ranges);
    /**
     * Get a list of allowed ranges for the given option.<br>
     * The returned list may depend on other fields in obj like for example profile.<br>
     * @param flags is a bitmask of flags, undefined flags should not be set and should be ignored<br>
     *              AV_OPT_SEARCH_FAKE_OBJ indicates that the obj is a double pointer to a AVClass instead of a full instance<br>
     *              AV_OPT_MULTI_COMPONENT_RANGE indicates that function may return more than one component, @see AVOptionRanges<br>
     * The result must be freed with av_opt_freep_ranges.<br>
     * @return number of compontents returned on success, a negative errro code otherwise<br>
     * Original signature : <code>int av_opt_query_ranges(AVOptionRanges**, void*, const char*, int)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/opt.h:548</i>
     */
    public int av_opt_query_ranges(Pointer<Pointer<AVOptionRanges > > AVOptionRangesPtrPtr1, Pointer<? > obj, Pointer<Byte > key, int flags) {
        return av_opt_query_ranges(Pointer.getPeer(AVOptionRangesPtrPtr1), Pointer.getPeer(obj), Pointer.getPeer(key), flags);
    }
    protected native int av_opt_query_ranges(@Ptr long AVOptionRangesPtrPtr1, @Ptr long obj, @Ptr long key, int flags);
    /**
     * Copy options from src object into dest object.<br>
     * Options that require memory allocation (e.g. string or binary) are malloc'ed in dest object.<br>
     * Original memory allocated for such options is freed unless both src and dest options points to the same memory.<br>
     * @param dest Object to copy from<br>
     * @param src  Object to copy into<br>
     * @return 0 on success, negative on error<br>
     * Original signature : <code>int av_opt_copy(void*, const void*)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/opt.h:558</i>
     */
    public int av_opt_copy(Pointer<? > dest, Pointer<? > src) {
        return av_opt_copy(Pointer.getPeer(dest), Pointer.getPeer(src));
    }
    protected native int av_opt_copy(@Ptr long dest, @Ptr long src);
    /**
     * Get a default list of allowed ranges for the given option.<br>
     * This list is constructed without using the AVClass.query_ranges() callback<br>
     * and can be used as fallback from within the callback.<br>
     * @param flags is a bitmask of flags, undefined flags should not be set and should be ignored<br>
     *              AV_OPT_SEARCH_FAKE_OBJ indicates that the obj is a double pointer to a AVClass instead of a full instance<br>
     *              AV_OPT_MULTI_COMPONENT_RANGE indicates that function may return more than one component, @see AVOptionRanges<br>
     * The result must be freed with av_opt_free_ranges.<br>
     * @return number of compontents returned on success, a negative errro code otherwise<br>
     * Original signature : <code>int av_opt_query_ranges_default(AVOptionRanges**, void*, const char*, int)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/opt.h:570</i>
     */
    public int av_opt_query_ranges_default(Pointer<Pointer<AVOptionRanges > > AVOptionRangesPtrPtr1, Pointer<? > obj, Pointer<Byte > key, int flags) {
        return av_opt_query_ranges_default(Pointer.getPeer(AVOptionRangesPtrPtr1), Pointer.getPeer(obj), Pointer.getPeer(key), flags);
    }
    protected native int av_opt_query_ranges_default(@Ptr long AVOptionRangesPtrPtr1, @Ptr long obj, @Ptr long key, int flags);
    /**
     * Check if given option is set to its default value.<br>
     * Options o must belong to the obj. This function must not be called to check child's options state.<br>
     * @see av_opt_is_set_to_default_by_name().<br>
     * @param obj  AVClass object to check option on<br>
     * @param o    option to be checked<br>
     * @return     >0 when option is set to its default,<br>
     *              0 when option is not set its default,<br>
     *             <0 on error<br>
     * Original signature : <code>int av_opt_is_set_to_default(void*, const AVOption*)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/opt.h:582</i>
     */
    public int av_opt_is_set_to_default(Pointer<? > obj, Pointer<AVOption > o) {
        return av_opt_is_set_to_default(Pointer.getPeer(obj), Pointer.getPeer(o));
    }
    protected native int av_opt_is_set_to_default(@Ptr long obj, @Ptr long o);
    /**
     * Check if given option is set to its default value.<br>
     * @param obj          AVClass object to check option on<br>
     * @param name         option name<br>
     * @param search_flags combination of AV_OPT_SEARCH_*<br>
     * @return             >0 when option is set to its default,<br>
     *                     0 when option is not set its default,<br>
     *                     <0 on error<br>
     * Original signature : <code>int av_opt_is_set_to_default_by_name(void*, const char*, int)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/opt.h:593</i>
     */
    public int av_opt_is_set_to_default_by_name(Pointer<? > obj, Pointer<Byte > name, int search_flags) {
        return av_opt_is_set_to_default_by_name(Pointer.getPeer(obj), Pointer.getPeer(name), search_flags);
    }
    protected native int av_opt_is_set_to_default_by_name(@Ptr long obj, @Ptr long name, int search_flags);
    /**
     * Serialize object's options.<br>
     * Create a string containing object's serialized options.<br>
     * Such string may be passed back to av_opt_set_from_string() in order to restore option values.<br>
     * A key/value or pairs separator occurring in the serialized value or<br>
     * name string are escaped through the av_escape() function.<br>
     * @param[in]  obj           AVClass object to serialize<br>
     * @param[in]  opt_flags     serialize options with all the specified flags set (AV_OPT_FLAG)<br>
     * @param[in]  flags         combination of AV_OPT_SERIALIZE_* flags<br>
     * @param[out] buffer        Pointer to buffer that will be allocated with string containg serialized options.<br>
     *                           Buffer must be freed by the caller when is no longer needed.<br>
     * @param[in]  key_val_sep   character used to separate key from value<br>
     * @param[in]  pairs_sep     character used to separate two pairs from each other<br>
     * @return                   >= 0 on success, negative on error<br>
     * @warning Separators cannot be neither '\\' nor '\0'. They also cannot be the same.<br>
     * Original signature : <code>int av_opt_serialize(void*, int, int, char**, const char, const char)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/opt.h:611</i>
     */
    public int av_opt_serialize(Pointer<? > obj, int opt_flags, int flags, Pointer<Pointer<Byte > > buffer, byte key_val_sep, byte pairs_sep) {
        return av_opt_serialize(Pointer.getPeer(obj), opt_flags, flags, Pointer.getPeer(buffer), key_val_sep, pairs_sep);
    }
    protected native int av_opt_serialize(@Ptr long obj, int opt_flags, int flags, @Ptr long buffer, byte key_val_sep, byte pairs_sep);
    /**
     * Allocate an AVTEA context<br>
     * To free the struct: av_free(ptr)<br>
     * Original signature : <code>AVTEA* av_tea_alloc()</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/tea.h:14</i>
     */
    public Pointer<AvutilLibrary.AVTEA > av_tea_alloc() {
        return (Pointer)Pointer.pointerToAddress(av_tea_alloc$2(), AvutilLibrary.AVTEA.class);
    }
    @Ptr
    @Name("av_tea_alloc")
    protected native long av_tea_alloc$2();
    /**
     * Initialize an AVTEA context.<br>
     * @param ctx an AVTEA context<br>
     * @param key a key of 16 bytes used for encryption/decryption<br>
     * @param rounds the number of rounds in TEA (64 is the "standard")<br>
     * Original signature : <code>void av_tea_init(AVTEA*, const uint8_t[16], int)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/tea.h:22</i>
     */
    public void av_tea_init(Pointer<AvutilLibrary.AVTEA > ctx, Pointer<Byte > key, int rounds) {
        av_tea_init(Pointer.getPeer(ctx), Pointer.getPeer(key), rounds);
    }
    protected native void av_tea_init(@Ptr long ctx, @Ptr long key, int rounds);
    /**
     * Encrypt or decrypt a buffer using a previously initialized context.<br>
     * @param ctx an AVTEA context<br>
     * @param dst destination array, can be equal to src<br>
     * @param src source array, can be equal to dst<br>
     * @param count number of 8 byte blocks<br>
     * @param iv initialization vector for CBC mode, if NULL then ECB will be used<br>
     * @param decrypt 0 for encryption, 1 for decryption<br>
     * Original signature : <code>void av_tea_crypt(AVTEA*, uint8_t*, const uint8_t*, int, uint8_t*, int)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/tea.h:33</i>
     */
    public void av_tea_crypt(Pointer<AvutilLibrary.AVTEA > ctx, Pointer<Byte > dst, Pointer<Byte > src, int count, Pointer<Byte > iv, int decrypt) {
        av_tea_crypt(Pointer.getPeer(ctx), Pointer.getPeer(dst), Pointer.getPeer(src), count, Pointer.getPeer(iv), decrypt);
    }
    protected native void av_tea_crypt(@Ptr long ctx, @Ptr long dst, @Ptr long src, int count, @Ptr long iv, int decrypt);
    /**
     * Parse and evaluate an expression.<br>
     * Note, this is significantly slower than av_expr_eval().<br>
     * @param res a pointer to a double where is put the result value of<br>
     * the expression, or NAN in case of error<br>
     * @param s expression as a zero terminated string, for example "1+2^3+5*5+sin(2/3)"<br>
     * @param const_names NULL terminated array of zero terminated strings of constant identifiers, for example {"PI", "E", 0}<br>
     * @param const_values a zero terminated array of values for the identifiers from const_names<br>
     * @param func1_names NULL terminated array of zero terminated strings of funcs1 identifiers<br>
     * @param funcs1 NULL terminated array of function pointers for functions which take 1 argument<br>
     * @param func2_names NULL terminated array of zero terminated strings of funcs2 identifiers<br>
     * @param funcs2 NULL terminated array of function pointers for functions which take 2 arguments<br>
     * @param opaque a pointer which will be passed to all functions from funcs1 and funcs2<br>
     * @param log_ctx parent logging context<br>
     * @return >= 0 in case of success, a negative value corresponding to an<br>
     * AVERROR code otherwise<br>
     * Original signature : <code>int av_expr_parse_and_eval(double*, const char*, const const char**, const double*, const const char**, av_expr_parse_and_eval_funcs1_callback**, const const char**, av_expr_parse_and_eval_funcs2_callback**, void*, int, void*)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/eval.h:19</i>
     */
    public int av_expr_parse_and_eval(Pointer<Double > res, Pointer<Byte > s, Pointer<Pointer<Byte > > const_names, Pointer<Double > const_values, Pointer<Pointer<Byte > > func1_names, Pointer<Pointer<AvutilLibrary.av_expr_parse_and_eval_funcs1_callback > > funcs1, Pointer<Pointer<Byte > > func2_names, Pointer<Pointer<AvutilLibrary.av_expr_parse_and_eval_funcs2_callback > > funcs2, Pointer<? > opaque, int log_offset, Pointer<? > log_ctx) {
        return av_expr_parse_and_eval(Pointer.getPeer(res), Pointer.getPeer(s), Pointer.getPeer(const_names), Pointer.getPeer(const_values), Pointer.getPeer(func1_names), Pointer.getPeer(funcs1), Pointer.getPeer(func2_names), Pointer.getPeer(funcs2), Pointer.getPeer(opaque), log_offset, Pointer.getPeer(log_ctx));
    }
    protected native int av_expr_parse_and_eval(@Ptr long res, @Ptr long s, @Ptr long const_names, @Ptr long const_values, @Ptr long func1_names, @Ptr long funcs1, @Ptr long func2_names, @Ptr long funcs2, @Ptr long opaque, int log_offset, @Ptr long log_ctx);
    /**
     * Parse an expression.<br>
     * @param expr a pointer where is put an AVExpr containing the parsed<br>
     * value in case of successful parsing, or NULL otherwise.<br>
     * The pointed to AVExpr must be freed with av_expr_free() by the user<br>
     * when it is not needed anymore.<br>
     * @param s expression as a zero terminated string, for example "1+2^3+5*5+sin(2/3)"<br>
     * @param const_names NULL terminated array of zero terminated strings of constant identifiers, for example {"PI", "E", 0}<br>
     * @param func1_names NULL terminated array of zero terminated strings of funcs1 identifiers<br>
     * @param funcs1 NULL terminated array of function pointers for functions which take 1 argument<br>
     * @param func2_names NULL terminated array of zero terminated strings of funcs2 identifiers<br>
     * @param funcs2 NULL terminated array of function pointers for functions which take 2 arguments<br>
     * @param log_ctx parent logging context<br>
     * @return >= 0 in case of success, a negative value corresponding to an<br>
     * AVERROR code otherwise<br>
     * Original signature : <code>int av_expr_parse(AVExpr**, const char*, const const char**, const const char**, av_expr_parse_funcs1_callback**, const const char**, av_expr_parse_funcs2_callback**, int, void*)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/eval.h:37</i>
     */
    public int av_expr_parse(Pointer<Pointer<AvutilLibrary.AVExpr > > expr, Pointer<Byte > s, Pointer<Pointer<Byte > > const_names, Pointer<Pointer<Byte > > func1_names, Pointer<Pointer<AvutilLibrary.av_expr_parse_funcs1_callback > > funcs1, Pointer<Pointer<Byte > > func2_names, Pointer<Pointer<AvutilLibrary.av_expr_parse_funcs2_callback > > funcs2, int log_offset, Pointer<? > log_ctx) {
        return av_expr_parse(Pointer.getPeer(expr), Pointer.getPeer(s), Pointer.getPeer(const_names), Pointer.getPeer(func1_names), Pointer.getPeer(funcs1), Pointer.getPeer(func2_names), Pointer.getPeer(funcs2), log_offset, Pointer.getPeer(log_ctx));
    }
    protected native int av_expr_parse(@Ptr long expr, @Ptr long s, @Ptr long const_names, @Ptr long func1_names, @Ptr long funcs1, @Ptr long func2_names, @Ptr long funcs2, int log_offset, @Ptr long log_ctx);
    /**
     * Evaluate a previously parsed expression.<br>
     * @param const_values a zero terminated array of values for the identifiers from av_expr_parse() const_names<br>
     * @param opaque a pointer which will be passed to all functions from funcs1 and funcs2<br>
     * @return the value of the expression<br>
     * Original signature : <code>double av_expr_eval(AVExpr*, const double*, void*)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/eval.h:45</i>
     */
    public double av_expr_eval(Pointer<AvutilLibrary.AVExpr > e, Pointer<Double > const_values, Pointer<? > opaque) {
        return av_expr_eval(Pointer.getPeer(e), Pointer.getPeer(const_values), Pointer.getPeer(opaque));
    }
    protected native double av_expr_eval(@Ptr long e, @Ptr long const_values, @Ptr long opaque);
    /**
     * Free a parsed expression previously created with av_expr_parse().<br>
     * Original signature : <code>void av_expr_free(AVExpr*)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/eval.h:50</i>
     */
    public void av_expr_free(Pointer<AvutilLibrary.AVExpr > e) {
        av_expr_free(Pointer.getPeer(e));
    }
    protected native void av_expr_free(@Ptr long e);
    /**
     * Parse the string in numstr and return its value as a double. If<br>
     * the string is empty, contains only whitespaces, or does not contain<br>
     * an initial substring that has the expected syntax for a<br>
     * floating-point number, no conversion is performed. In this case,<br>
     * returns a value of zero and the value returned in tail is the value<br>
     * of numstr.<br>
     * @param numstr a string representing a number, may contain one of<br>
     * the International System number postfixes, for example 'K', 'M',<br>
     * 'G'. If 'i' is appended after the postfix, powers of 2 are used<br>
     * instead of powers of 10. The 'B' postfix multiplies the value for<br>
     * 8, and can be appended after another postfix or used alone. This<br>
     * allows using for example 'KB', 'MiB', 'G' and 'B' as postfix.<br>
     * @param tail if non-NULL puts here the pointer to the char next<br>
     * after the last parsed character<br>
     * Original signature : <code>double av_strtod(const char*, char**)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/eval.h:68</i>
     */
    public double av_strtod(Pointer<Byte > numstr, Pointer<Pointer<Byte > > tail) {
        return av_strtod(Pointer.getPeer(numstr), Pointer.getPeer(tail));
    }
    protected native double av_strtod(@Ptr long numstr, @Ptr long tail);
    /**
     * Get the current time in microseconds.<br>
     * Original signature : <code>int64_t av_gettime()</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/time.h:4</i>
     */
    public native long av_gettime();
    /**
     * Get the current time in microseconds since some unspecified starting point.<br>
     * On platforms that support it, the time comes from a monotonic clock<br>
     * This property makes this time source ideal for measuring relative time.<br>
     * The returned values may not be monotonic on platforms where a monotonic<br>
     * clock is not available.<br>
     * Original signature : <code>int64_t av_gettime_relative()</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/time.h:13</i>
     */
    public native long av_gettime_relative();
    /**
     * Indicates with a boolean result if the av_gettime_relative() time source<br>
     * is monotonic.<br>
     * Original signature : <code>int av_gettime_relative_is_monotonic()</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/time.h:19</i>
     */
    public native int av_gettime_relative_is_monotonic();
    /**
     * Sleep for a period of time.  Although the duration is expressed in<br>
     * microseconds, the actual delay may be rounded to the precision of the<br>
     * system timer.<br>
     * @param  usec Number of microseconds to sleep.<br>
     * @return zero on success or (negative) error code.<br>
     * Original signature : <code>int av_usleep(unsigned)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/time.h:28</i>
     */
    public native int av_usleep(int usec);
    /**
     * Get a frame's AV_FRAME_DATA_DOWNMIX_INFO side data for editing.<br>
     * If the side data is absent, it is created and added to the frame.<br>
     * @param frame the frame for which the side data is to be obtained or created<br>
     * @return the AVDownmixInfo structure to be edited by the caller, or NULL if<br>
     *         the structure cannot be allocated.<br>
     * Original signature : <code>AVDownmixInfo* av_downmix_info_update_side_data(AVFrame*)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/downmix_info.h:31</i>
     */
    public Pointer<AVDownmixInfo > av_downmix_info_update_side_data(Pointer<AVFrame > frame) {
        return (Pointer)Pointer.pointerToAddress(av_downmix_info_update_side_data(Pointer.getPeer(frame)), AVDownmixInfo.class);
    }
    @Ptr
    protected native long av_downmix_info_update_side_data(@Ptr long frame);
    /**
     * Calculate the Adler32 checksum of a buffer.<br>
     * Passing the return value to a subsequent av_adler32_update() call<br>
     * allows the checksum of multiple buffers to be calculated as though<br>
     * they were concatenated.<br>
     * @param adler initial checksum value<br>
     * @param buf   pointer to input buffer<br>
     * @param len   size of input buffer<br>
     * @return      updated checksum<br>
     * Original signature : <code>long av_adler32_update(unsigned long, const uint8_t*, unsigned int)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/adler32.h:11</i>
     */
    @CLong
    public long av_adler32_update(@CLong long adler, Pointer<Byte > buf, int len) {
        return av_adler32_update(adler, Pointer.getPeer(buf), len);
    }
    @CLong
    protected native long av_adler32_update(@CLong long adler, @Ptr long buf, int len);
    /**
     * Allocate an AVStereo3D structure and set its fields to default values.<br>
     * The resulting struct can be freed using av_freep().<br>
     * @return An AVStereo3D filled with default values or NULL on failure.<br>
     * Original signature : <code>AVStereo3D* av_stereo3d_alloc()</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/stereo3d.h:29</i>
     */
    public Pointer<AVStereo3D > av_stereo3d_alloc() {
        return (Pointer)Pointer.pointerToAddress(av_stereo3d_alloc$2(), AVStereo3D.class);
    }
    @Ptr
    @Name("av_stereo3d_alloc")
    protected native long av_stereo3d_alloc$2();
    /**
     * Allocate a complete AVFrameSideData and add it to the frame.<br>
     * @param frame The frame which side data is added to.<br>
     * @return The AVStereo3D structure to be filled by caller.<br>
     * Original signature : <code>AVStereo3D* av_stereo3d_create_side_data(AVFrame*)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/stereo3d.h:36</i>
     */
    public Pointer<AVStereo3D > av_stereo3d_create_side_data(Pointer<AVFrame > frame) {
        return (Pointer)Pointer.pointerToAddress(av_stereo3d_create_side_data(Pointer.getPeer(frame)), AVStereo3D.class);
    }
    @Ptr
    protected native long av_stereo3d_create_side_data(@Ptr long frame);
    /**
     * Original signature : <code>AVMurMur3* av_murmur3_alloc()</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/murmur3.h:1</i>
     */
    public Pointer<AvutilLibrary.AVMurMur3 > av_murmur3_alloc() {
        return (Pointer)Pointer.pointerToAddress(av_murmur3_alloc$2(), AvutilLibrary.AVMurMur3.class);
    }
    @Ptr
    @Name("av_murmur3_alloc")
    protected native long av_murmur3_alloc$2();
    /**
     * Original signature : <code>void av_murmur3_init_seeded(AVMurMur3*, uint64_t)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/murmur3.h:3</i>
     */
    public void av_murmur3_init_seeded(Pointer<AvutilLibrary.AVMurMur3 > c, long seed) {
        av_murmur3_init_seeded(Pointer.getPeer(c), seed);
    }
    protected native void av_murmur3_init_seeded(@Ptr long c, long seed);
    /**
     * Original signature : <code>void av_murmur3_init(AVMurMur3*)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/murmur3.h:5</i>
     */
    public void av_murmur3_init(Pointer<AvutilLibrary.AVMurMur3 > c) {
        av_murmur3_init(Pointer.getPeer(c));
    }
    protected native void av_murmur3_init(@Ptr long c);
    /**
     * Original signature : <code>void av_murmur3_update(AVMurMur3*, const uint8_t*, int)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/murmur3.h:7</i>
     */
    public void av_murmur3_update(Pointer<AvutilLibrary.AVMurMur3 > c, Pointer<Byte > src, int len) {
        av_murmur3_update(Pointer.getPeer(c), Pointer.getPeer(src), len);
    }
    protected native void av_murmur3_update(@Ptr long c, @Ptr long src, int len);
    /**
     * Original signature : <code>void av_murmur3_final(AVMurMur3*, uint8_t[16])</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/murmur3.h:9</i>
     */
    public void av_murmur3_final(Pointer<AvutilLibrary.AVMurMur3 > c, Pointer<Byte > dst) {
        av_murmur3_final(Pointer.getPeer(c), Pointer.getPeer(dst));
    }
    protected native void av_murmur3_final(@Ptr long c, @Ptr long dst);
    /**
     * Extract the rotation component of the transformation matrix.<br>
     * @param matrix the transformation matrix<br>
     * @return the angle (in degrees) by which the transformation rotates the frame<br>
     *         counterclockwise. The angle will be in range [-180.0, 180.0],<br>
     *         or NaN if the matrix is singular.<br>
     * @note floating point numbers are inherently inexact, so callers are<br>
     *       recommended to round the return value to nearest integer before use.<br>
     * Original signature : <code>double av_display_rotation_get(const int32_t[9])</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/display.h:10</i>
     */
    public double av_display_rotation_get(Pointer<Integer > matrix) {
        return av_display_rotation_get(Pointer.getPeer(matrix));
    }
    protected native double av_display_rotation_get(@Ptr long matrix);
    /**
     * Initialize a transformation matrix describing a pure counterclockwise<br>
     * rotation by the specified angle (in degrees).<br>
     * @param matrix an allocated transformation matrix (will be fully overwritten<br>
     *               by this function)<br>
     * @param angle rotation angle in degrees.<br>
     * Original signature : <code>void av_display_rotation_set(int32_t[9], double)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/display.h:19</i>
     */
    public void av_display_rotation_set(Pointer<Integer > matrix, double angle) {
        av_display_rotation_set(Pointer.getPeer(matrix), angle);
    }
    protected native void av_display_rotation_set(@Ptr long matrix, double angle);
    /**
     * Flip the input matrix horizontally and/or vertically.<br>
     * @param matrix an allocated transformation matrix<br>
     * @param hflip whether the matrix should be flipped horizontally<br>
     * @param vflip whether the matrix should be flipped vertically<br>
     * Original signature : <code>void av_display_matrix_flip(int32_t[9], int, int)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/display.h:27</i>
     */
    public void av_display_matrix_flip(Pointer<Integer > matrix, int hflip, int vflip) {
        av_display_matrix_flip(Pointer.getPeer(matrix), hflip, vflip);
    }
    protected native void av_display_matrix_flip(@Ptr long matrix, int hflip, int vflip);
    /**
     * Allocate a hash context for the algorithm specified by name.<br>
     * @return  >= 0 for success, a negative error code for failure<br>
     * @note  The context is not initialized, you must call av_hash_init().<br>
     * Original signature : <code>int av_hash_alloc(AVHashContext**, const char*)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/hash.h:7</i>
     */
    public int av_hash_alloc(Pointer<Pointer<AvutilLibrary.AVHashContext > > ctx, Pointer<Byte > name) {
        return av_hash_alloc(Pointer.getPeer(ctx), Pointer.getPeer(name));
    }
    protected native int av_hash_alloc(@Ptr long ctx, @Ptr long name);
    /**
     * Get the names of available hash algorithms.<br>
     * This function can be used to enumerate the algorithms.<br>
     * @param i  index of the hash algorithm, starting from 0<br>
     * @return   a pointer to a static string or NULL if i is out of range<br>
     * Original signature : <code>char* av_hash_names(int)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/hash.h:15</i>
     */
    public Pointer<Byte > av_hash_names(int i) {
        return (Pointer)Pointer.pointerToAddress(av_hash_names$2(i), Byte.class);
    }
    @Ptr
    @Name("av_hash_names")
    protected native long av_hash_names$2(int i);
    /**
     * Get the name of the algorithm corresponding to the given hash context.<br>
     * Original signature : <code>char* av_hash_get_name(AVHashContext*)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/hash.h:20</i>
     */
    public Pointer<Byte > av_hash_get_name(Pointer<AvutilLibrary.AVHashContext > ctx) {
        return (Pointer)Pointer.pointerToAddress(av_hash_get_name(Pointer.getPeer(ctx)), Byte.class);
    }
    @Ptr
    protected native long av_hash_get_name(@Ptr long ctx);
    /**
     * Get the size of the resulting hash value in bytes.<br>
     * The pointer passed to av_hash_final have space for at least this many bytes.<br>
     * Original signature : <code>int av_hash_get_size(AVHashContext*)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/hash.h:26</i>
     */
    public int av_hash_get_size(Pointer<AvutilLibrary.AVHashContext > ctx) {
        return av_hash_get_size(Pointer.getPeer(ctx));
    }
    protected native int av_hash_get_size(@Ptr long ctx);
    /**
     * Initialize or reset a hash context.<br>
     * Original signature : <code>void av_hash_init(AVHashContext*)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/hash.h:31</i>
     */
    public void av_hash_init(Pointer<AvutilLibrary.AVHashContext > ctx) {
        av_hash_init(Pointer.getPeer(ctx));
    }
    protected native void av_hash_init(@Ptr long ctx);
    /**
     * Update a hash context with additional data.<br>
     * Original signature : <code>void av_hash_update(AVHashContext*, const uint8_t*, int)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/hash.h:36</i>
     */
    public void av_hash_update(Pointer<AvutilLibrary.AVHashContext > ctx, Pointer<Byte > src, int len) {
        av_hash_update(Pointer.getPeer(ctx), Pointer.getPeer(src), len);
    }
    protected native void av_hash_update(@Ptr long ctx, @Ptr long src, int len);
    /**
     * Finalize a hash context and compute the actual hash value.<br>
     * Original signature : <code>void av_hash_final(AVHashContext*, uint8_t*)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/hash.h:41</i>
     */
    public void av_hash_final(Pointer<AvutilLibrary.AVHashContext > ctx, Pointer<Byte > dst) {
        av_hash_final(Pointer.getPeer(ctx), Pointer.getPeer(dst));
    }
    protected native void av_hash_final(@Ptr long ctx, @Ptr long dst);
    /**
     * Finalize a hash context and compute the actual hash value.<br>
     * If size is smaller than the hash size, the hash is truncated;<br>
     * if size is larger, the buffer is padded with 0.<br>
     * Original signature : <code>void av_hash_final_bin(AVHashContext*, uint8_t*, int)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/hash.h:48</i>
     */
    public void av_hash_final_bin(Pointer<AvutilLibrary.AVHashContext > ctx, Pointer<Byte > dst, int size) {
        av_hash_final_bin(Pointer.getPeer(ctx), Pointer.getPeer(dst), size);
    }
    protected native void av_hash_final_bin(@Ptr long ctx, @Ptr long dst, int size);
    /**
     * Finalize a hash context and compute the actual hash value as a hex string.<br>
     * The string is always 0-terminated.<br>
     * If size is smaller than 2 * hash_size + 1, the hex string is truncated.<br>
     * Original signature : <code>void av_hash_final_hex(AVHashContext*, uint8_t*, int)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/hash.h:55</i>
     */
    public void av_hash_final_hex(Pointer<AvutilLibrary.AVHashContext > ctx, Pointer<Byte > dst, int size) {
        av_hash_final_hex(Pointer.getPeer(ctx), Pointer.getPeer(dst), size);
    }
    protected native void av_hash_final_hex(@Ptr long ctx, @Ptr long dst, int size);
    /**
     * Finalize a hash context and compute the actual hash value as a base64 string.<br>
     * The string is always 0-terminated.<br>
     * If size is smaller than AV_BASE64_SIZE(hash_size), the base64 string is<br>
     * truncated.<br>
     * Original signature : <code>void av_hash_final_b64(AVHashContext*, uint8_t*, int)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/hash.h:63</i>
     */
    public void av_hash_final_b64(Pointer<AvutilLibrary.AVHashContext > ctx, Pointer<Byte > dst, int size) {
        av_hash_final_b64(Pointer.getPeer(ctx), Pointer.getPeer(dst), size);
    }
    protected native void av_hash_final_b64(@Ptr long ctx, @Ptr long dst, int size);
    /**
     * Free hash context.<br>
     * Original signature : <code>void av_hash_freep(AVHashContext**)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/hash.h:68</i>
     */
    public void av_hash_freep(Pointer<Pointer<AvutilLibrary.AVHashContext > > ctx) {
        av_hash_freep(Pointer.getPeer(ctx));
    }
    protected native void av_hash_freep(@Ptr long ctx);
    /**
     * Allocate an AVBlowfish context.<br>
     * Original signature : <code>AVBlowfish* av_blowfish_alloc()</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/blowfish.h:13</i>
     */
    public Pointer<AVBlowfish > av_blowfish_alloc() {
        return (Pointer)Pointer.pointerToAddress(av_blowfish_alloc$2(), AVBlowfish.class);
    }
    @Ptr
    @Name("av_blowfish_alloc")
    protected native long av_blowfish_alloc$2();
    /**
     * Initialize an AVBlowfish context.<br>
     * @param ctx an AVBlowfish context<br>
     * @param key a key<br>
     * @param key_len length of the key<br>
     * Original signature : <code>void av_blowfish_init(AVBlowfish*, const uint8_t*, int)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/blowfish.h:21</i>
     */
    public void av_blowfish_init(Pointer<AVBlowfish > ctx, Pointer<Byte > key, int key_len) {
        av_blowfish_init(Pointer.getPeer(ctx), Pointer.getPeer(key), key_len);
    }
    protected native void av_blowfish_init(@Ptr long ctx, @Ptr long key, int key_len);
    /**
     * Encrypt or decrypt a buffer using a previously initialized context.<br>
     * @param ctx an AVBlowfish context<br>
     * @param xl left four bytes halves of input to be encrypted<br>
     * @param xr right four bytes halves of input to be encrypted<br>
     * @param decrypt 0 for encryption, 1 for decryption<br>
     * Original signature : <code>void av_blowfish_crypt_ecb(AVBlowfish*, uint32_t*, uint32_t*, int)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/blowfish.h:30</i>
     */
    public void av_blowfish_crypt_ecb(Pointer<AVBlowfish > ctx, Pointer<Integer > xl, Pointer<Integer > xr, int decrypt) {
        av_blowfish_crypt_ecb(Pointer.getPeer(ctx), Pointer.getPeer(xl), Pointer.getPeer(xr), decrypt);
    }
    protected native void av_blowfish_crypt_ecb(@Ptr long ctx, @Ptr long xl, @Ptr long xr, int decrypt);
    /**
     * Encrypt or decrypt a buffer using a previously initialized context.<br>
     * @param ctx an AVBlowfish context<br>
     * @param dst destination array, can be equal to src<br>
     * @param src source array, can be equal to dst<br>
     * @param count number of 8 byte blocks<br>
     * @param iv initialization vector for CBC mode, if NULL ECB will be used<br>
     * @param decrypt 0 for encryption, 1 for decryption<br>
     * Original signature : <code>void av_blowfish_crypt(AVBlowfish*, uint8_t*, const uint8_t*, int, uint8_t*, int)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/blowfish.h:41</i>
     */
    public void av_blowfish_crypt(Pointer<AVBlowfish > ctx, Pointer<Byte > dst, Pointer<Byte > src, int count, Pointer<Byte > iv, int decrypt) {
        av_blowfish_crypt(Pointer.getPeer(ctx), Pointer.getPeer(dst), Pointer.getPeer(src), count, Pointer.getPeer(iv), decrypt);
    }
    protected native void av_blowfish_crypt(@Ptr long ctx, @Ptr long dst, @Ptr long src, int count, @Ptr long iv, int decrypt);
    /**
     * Allocate an AVCAST5 context<br>
     * To free the struct: av_free(ptr)<br>
     * Original signature : <code>AVCAST5* av_cast5_alloc()</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/cast5.h:14</i>
     */
    public Pointer<AvutilLibrary.AVCAST5 > av_cast5_alloc() {
        return (Pointer)Pointer.pointerToAddress(av_cast5_alloc$2(), AvutilLibrary.AVCAST5.class);
    }
    @Ptr
    @Name("av_cast5_alloc")
    protected native long av_cast5_alloc$2();
    /**
     * Initialize an AVCAST5 context.<br>
     * @param ctx an AVCAST5 context<br>
     * @param key a key of 5,6,...16 bytes used for encryption/decryption<br>
     * @param key_bits number of keybits: possible are 40,48,...,128<br>
     * @return 0 on success, less than 0 on failure<br>
     * Original signature : <code>int av_cast5_init(AVCAST5*, const uint8_t*, int)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/cast5.h:23</i>
     */
    public int av_cast5_init(Pointer<AvutilLibrary.AVCAST5 > ctx, Pointer<Byte > key, int key_bits) {
        return av_cast5_init(Pointer.getPeer(ctx), Pointer.getPeer(key), key_bits);
    }
    protected native int av_cast5_init(@Ptr long ctx, @Ptr long key, int key_bits);
    /**
     * Encrypt or decrypt a buffer using a previously initialized context, ECB mode only<br>
     * @param ctx an AVCAST5 context<br>
     * @param dst destination array, can be equal to src<br>
     * @param src source array, can be equal to dst<br>
     * @param count number of 8 byte blocks<br>
     * @param decrypt 0 for encryption, 1 for decryption<br>
     * Original signature : <code>void av_cast5_crypt(AVCAST5*, uint8_t*, const uint8_t*, int, int)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/cast5.h:33</i>
     */
    public void av_cast5_crypt(Pointer<AvutilLibrary.AVCAST5 > ctx, Pointer<Byte > dst, Pointer<Byte > src, int count, int decrypt) {
        av_cast5_crypt(Pointer.getPeer(ctx), Pointer.getPeer(dst), Pointer.getPeer(src), count, decrypt);
    }
    protected native void av_cast5_crypt(@Ptr long ctx, @Ptr long dst, @Ptr long src, int count, int decrypt);
    /**
     * Encrypt or decrypt a buffer using a previously initialized context<br>
     * @param ctx an AVCAST5 context<br>
     * @param dst destination array, can be equal to src<br>
     * @param src source array, can be equal to dst<br>
     * @param count number of 8 byte blocks<br>
     * @param iv initialization vector for CBC mode, NULL for ECB mode<br>
     * @param decrypt 0 for encryption, 1 for decryption<br>
     * Original signature : <code>void av_cast5_crypt2(AVCAST5*, uint8_t*, const uint8_t*, int, uint8_t*, int)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/cast5.h:44</i>
     */
    public void av_cast5_crypt2(Pointer<AvutilLibrary.AVCAST5 > ctx, Pointer<Byte > dst, Pointer<Byte > src, int count, Pointer<Byte > iv, int decrypt) {
        av_cast5_crypt2(Pointer.getPeer(ctx), Pointer.getPeer(dst), Pointer.getPeer(src), count, Pointer.getPeer(iv), decrypt);
    }
    protected native void av_cast5_crypt2(@Ptr long ctx, @Ptr long dst, @Ptr long src, int count, @Ptr long iv, int decrypt);
    /**
     * Allocate an AVHMAC context.<br>
     * @param type The hash function used for the HMAC.<br>
     * Original signature : <code>AVHMAC* av_hmac_alloc(AVHMACType)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/hmac.h:19</i>
     */
    public Pointer<AvutilLibrary.AVHMAC > av_hmac_alloc(IntValuedEnum<AvutilLibrary.AVHMACType > type) {
        return (Pointer)Pointer.pointerToAddress(av_hmac_alloc((int)type.value()), AvutilLibrary.AVHMAC.class);
    }
    @Ptr
    protected native long av_hmac_alloc(int type);
    /**
     * Free an AVHMAC context.<br>
     * @param ctx The context to free, may be NULL<br>
     * Original signature : <code>void av_hmac_free(AVHMAC*)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/hmac.h:25</i>
     */
    public void av_hmac_free(Pointer<AvutilLibrary.AVHMAC > ctx) {
        av_hmac_free(Pointer.getPeer(ctx));
    }
    protected native void av_hmac_free(@Ptr long ctx);
    /**
     * Initialize an AVHMAC context with an authentication key.<br>
     * @param ctx    The HMAC context<br>
     * @param key    The authentication key<br>
     * @param keylen The length of the key, in bytes<br>
     * Original signature : <code>void av_hmac_init(AVHMAC*, const uint8_t*, unsigned int)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/hmac.h:33</i>
     */
    public void av_hmac_init(Pointer<AvutilLibrary.AVHMAC > ctx, Pointer<Byte > key, int keylen) {
        av_hmac_init(Pointer.getPeer(ctx), Pointer.getPeer(key), keylen);
    }
    protected native void av_hmac_init(@Ptr long ctx, @Ptr long key, int keylen);
    /**
     * Hash data with the HMAC.<br>
     * @param ctx  The HMAC context<br>
     * @param data The data to hash<br>
     * @param len  The length of the data, in bytes<br>
     * Original signature : <code>void av_hmac_update(AVHMAC*, const uint8_t*, unsigned int)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/hmac.h:41</i>
     */
    public void av_hmac_update(Pointer<AvutilLibrary.AVHMAC > ctx, Pointer<Byte > data, int len) {
        av_hmac_update(Pointer.getPeer(ctx), Pointer.getPeer(data), len);
    }
    protected native void av_hmac_update(@Ptr long ctx, @Ptr long data, int len);
    /**
     * Finish hashing and output the HMAC digest.<br>
     * @param ctx    The HMAC context<br>
     * @param out    The output buffer to write the digest into<br>
     * @param outlen The length of the out buffer, in bytes<br>
     * @return       The number of bytes written to out, or a negative error code.<br>
     * Original signature : <code>int av_hmac_final(AVHMAC*, uint8_t*, unsigned int)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/hmac.h:50</i>
     */
    public int av_hmac_final(Pointer<AvutilLibrary.AVHMAC > ctx, Pointer<Byte > out, int outlen) {
        return av_hmac_final(Pointer.getPeer(ctx), Pointer.getPeer(out), outlen);
    }
    protected native int av_hmac_final(@Ptr long ctx, @Ptr long out, int outlen);
    /**
     * Hash an array of data with a key.<br>
     * @param ctx    The HMAC context<br>
     * @param data   The data to hash<br>
     * @param len    The length of the data, in bytes<br>
     * @param key    The authentication key<br>
     * @param keylen The length of the key, in bytes<br>
     * @param out    The output buffer to write the digest into<br>
     * @param outlen The length of the out buffer, in bytes<br>
     * @return       The number of bytes written to out, or a negative error code.<br>
     * Original signature : <code>int av_hmac_calc(AVHMAC*, const uint8_t*, unsigned int, const uint8_t*, unsigned int, uint8_t*, unsigned int)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/hmac.h:63</i>
     */
    public int av_hmac_calc(Pointer<AvutilLibrary.AVHMAC > ctx, Pointer<Byte > data, int len, Pointer<Byte > key, int keylen, Pointer<Byte > out, int outlen) {
        return av_hmac_calc(Pointer.getPeer(ctx), Pointer.getPeer(data), len, Pointer.getPeer(key), keylen, Pointer.getPeer(out), outlen);
    }
    protected native int av_hmac_calc(@Ptr long ctx, @Ptr long data, int len, @Ptr long key, int keylen, @Ptr long out, int outlen);
    /**
     * Return non-zero if pfx is a prefix of str. If it is, *ptr is set to<br>
     * the address of the first character in str after the prefix.<br>
     * @param str input string<br>
     * @param pfx prefix to test<br>
     * @param ptr updated if the prefix is matched inside str<br>
     * @return non-zero if the prefix matches, zero otherwise<br>
     * Original signature : <code>int av_strstart(const char*, const char*, const char**)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/avstring.h:9</i>
     */
    public int av_strstart(Pointer<Byte > str, Pointer<Byte > pfx, Pointer<Pointer<Byte > > ptr) {
        return av_strstart(Pointer.getPeer(str), Pointer.getPeer(pfx), Pointer.getPeer(ptr));
    }
    protected native int av_strstart(@Ptr long str, @Ptr long pfx, @Ptr long ptr);
    /**
     * Return non-zero if pfx is a prefix of str independent of case. If<br>
     * it is, *ptr is set to the address of the first character in str<br>
     * after the prefix.<br>
     * @param str input string<br>
     * @param pfx prefix to test<br>
     * @param ptr updated if the prefix is matched inside str<br>
     * @return non-zero if the prefix matches, zero otherwise<br>
     * Original signature : <code>int av_stristart(const char*, const char*, const char**)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/avstring.h:20</i>
     */
    public int av_stristart(Pointer<Byte > str, Pointer<Byte > pfx, Pointer<Pointer<Byte > > ptr) {
        return av_stristart(Pointer.getPeer(str), Pointer.getPeer(pfx), Pointer.getPeer(ptr));
    }
    protected native int av_stristart(@Ptr long str, @Ptr long pfx, @Ptr long ptr);
    /**
     * Locate the first case-independent occurrence in the string haystack<br>
     * of the string needle.  A zero-length string needle is considered to<br>
     * match at the start of haystack.<br>
     * This function is a case-insensitive version of the standard strstr().<br>
     * @param haystack string to search in<br>
     * @param needle   string to search for<br>
     * @return         pointer to the located match within haystack<br>
     *                 or a null pointer if no match<br>
     * Original signature : <code>char* av_stristr(const char*, const char*)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/avstring.h:32</i>
     */
    public Pointer<Byte > av_stristr(Pointer<Byte > haystack, Pointer<Byte > needle) {
        return (Pointer)Pointer.pointerToAddress(av_stristr(Pointer.getPeer(haystack), Pointer.getPeer(needle)), Byte.class);
    }
    @Ptr
    protected native long av_stristr(@Ptr long haystack, @Ptr long needle);
    /**
     * Locate the first occurrence of the string needle in the string haystack<br>
     * where not more than hay_length characters are searched. A zero-length<br>
     * string needle is considered to match at the start of haystack.<br>
     * This function is a length-limited version of the standard strstr().<br>
     * @param haystack   string to search in<br>
     * @param needle     string to search for<br>
     * @param hay_length length of string to search in<br>
     * @return           pointer to the located match within haystack<br>
     *                   or a null pointer if no match<br>
     * Original signature : <code>char* av_strnstr(const char*, const char*, size_t)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/avstring.h:45</i>
     */
    public Pointer<Byte > av_strnstr(Pointer<Byte > haystack, Pointer<Byte > needle, @Ptr long hay_length) {
        return (Pointer)Pointer.pointerToAddress(av_strnstr(Pointer.getPeer(haystack), Pointer.getPeer(needle), hay_length), Byte.class);
    }
    @Ptr
    protected native long av_strnstr(@Ptr long haystack, @Ptr long needle, @Ptr long hay_length);
    /**
     * Copy the string src to dst, but no more than size - 1 bytes, and<br>
     * null-terminate dst.<br>
     * This function is the same as BSD strlcpy().<br>
     * @param dst destination buffer<br>
     * @param src source string<br>
     * @param size size of destination buffer<br>
     * @return the length of src<br>
     * @warning since the return value is the length of src, src absolutely<br>
     * _must_ be a properly 0-terminated string, otherwise this will read beyond<br>
     * the end of the buffer and possibly crash.<br>
     * Original signature : <code>size_t av_strlcpy(char*, const char*, size_t)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/avstring.h:59</i>
     */
    @Ptr
    public long av_strlcpy(Pointer<Byte > dst, Pointer<Byte > src, @Ptr long size) {
        return av_strlcpy(Pointer.getPeer(dst), Pointer.getPeer(src), size);
    }
    @Ptr
    protected native long av_strlcpy(@Ptr long dst, @Ptr long src, @Ptr long size);
    /**
     * Append the string src to the string dst, but to a total length of<br>
     * no more than size - 1 bytes, and null-terminate dst.<br>
     * This function is similar to BSD strlcat(), but differs when<br>
     * size <= strlen(dst).<br>
     * @param dst destination buffer<br>
     * @param src source string<br>
     * @param size size of destination buffer<br>
     * @return the total length of src and dst<br>
     * @warning since the return value use the length of src and dst, these<br>
     * absolutely _must_ be a properly 0-terminated strings, otherwise this<br>
     * will read beyond the end of the buffer and possibly crash.<br>
     * Original signature : <code>size_t av_strlcat(char*, const char*, size_t)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/avstring.h:74</i>
     */
    @Ptr
    public long av_strlcat(Pointer<Byte > dst, Pointer<Byte > src, @Ptr long size) {
        return av_strlcat(Pointer.getPeer(dst), Pointer.getPeer(src), size);
    }
    @Ptr
    protected native long av_strlcat(@Ptr long dst, @Ptr long src, @Ptr long size);
    /**
     * Append output to a string, according to a format. Never write out of<br>
     * the destination buffer, and always put a terminating 0 within<br>
     * the buffer.<br>
     * @param dst destination buffer (string to which the output is<br>
     *  appended)<br>
     * @param size total size of the destination buffer<br>
     * @param fmt printf-compatible format string, specifying how the<br>
     *  following parameters are used<br>
     * @return the length of the string that would have been generated<br>
     *  if enough space had been available<br>
     * Original signature : <code>size_t av_strlcatf(char*, size_t, const char*, null)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/avstring.h:88</i>
     */
    @Ptr
    public long av_strlcatf(Pointer<Byte > dst, @Ptr long size, Pointer<Byte > fmt, Object... varArgs1) {
        return av_strlcatf(Pointer.getPeer(dst), size, Pointer.getPeer(fmt), varArgs1);
    }
    @Ptr
    protected native long av_strlcatf(@Ptr long dst, @Ptr long size, @Ptr long fmt, Object... varArgs1);
    /**
     * Print arguments following specified format into a large enough auto<br>
     * allocated buffer. It is similar to GNU asprintf().<br>
     * @param fmt printf-compatible format string, specifying how the<br>
     *            following parameters are used.<br>
     * @return the allocated string<br>
     * @note You have to free the string yourself with av_free().<br>
     * Original signature : <code>char* av_asprintf(const char*, null)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/avstring.h:108</i>
     */
    public Pointer<Byte > av_asprintf(Pointer<Byte > fmt, Object... varArgs1) {
        return (Pointer)Pointer.pointerToAddress(av_asprintf(Pointer.getPeer(fmt), varArgs1), Byte.class);
    }
    @Ptr
    protected native long av_asprintf(@Ptr long fmt, Object... varArgs1);
    /**
     * Convert a number to a av_malloced string.<br>
     * Original signature : <code>char* av_d2str(double)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/avstring.h:113</i>
     */
    public Pointer<Byte > av_d2str(double d) {
        return (Pointer)Pointer.pointerToAddress(av_d2str$2(d), Byte.class);
    }
    @Ptr
    @Name("av_d2str")
    protected native long av_d2str$2(double d);
    /**
     * Unescape the given string until a non escaped terminating char,<br>
     * and return the token corresponding to the unescaped string.<br>
     * The normal \ and ' escaping is supported. Leading and trailing<br>
     * whitespaces are removed, unless they are escaped with '\' or are<br>
     * enclosed between ''.<br>
     * @param buf the buffer to parse, buf will be updated to point to the<br>
     * terminating char<br>
     * @param term a 0-terminated list of terminating chars<br>
     * @return the malloced unescaped string, which must be av_freed by<br>
     * the user, NULL in case of allocation failure<br>
     * Original signature : <code>char* av_get_token(const char**, const char*)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/avstring.h:127</i>
     */
    public Pointer<Byte > av_get_token(Pointer<Pointer<Byte > > buf, Pointer<Byte > term) {
        return (Pointer)Pointer.pointerToAddress(av_get_token(Pointer.getPeer(buf), Pointer.getPeer(term)), Byte.class);
    }
    @Ptr
    protected native long av_get_token(@Ptr long buf, @Ptr long term);
    /**
     * Split the string into several tokens which can be accessed by<br>
     * successive calls to av_strtok().<br>
     * A token is defined as a sequence of characters not belonging to the<br>
     * set specified in delim.<br>
     * On the first call to av_strtok(), s should point to the string to<br>
     * parse, and the value of saveptr is ignored. In subsequent calls, s<br>
     * should be NULL, and saveptr should be unchanged since the previous<br>
     * call.<br>
     * This function is similar to strtok_r() defined in POSIX.1.<br>
     * @param s the string to parse, may be NULL<br>
     * @param delim 0-terminated list of token delimiters, must be non-NULL<br>
     * @param saveptr user-provided pointer which points to stored<br>
     * information necessary for av_strtok() to continue scanning the same<br>
     * string. saveptr is updated to point to the next character after the<br>
     * first delimiter found, or to NULL if the string was terminated<br>
     * @return the found token, or NULL when no token is found<br>
     * Original signature : <code>char* av_strtok(char*, const char*, char**)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/avstring.h:147</i>
     */
    public Pointer<Byte > av_strtok(Pointer<Byte > s, Pointer<Byte > delim, Pointer<Pointer<Byte > > saveptr) {
        return (Pointer)Pointer.pointerToAddress(av_strtok(Pointer.getPeer(s), Pointer.getPeer(delim), Pointer.getPeer(saveptr)), Byte.class);
    }
    @Ptr
    protected native long av_strtok(@Ptr long s, @Ptr long delim, @Ptr long saveptr);
    /**
     * Init a print buffer.<br>
     * @param buf        buffer to init<br>
     * @param size_init  initial size (including the final 0)<br>
     * @param size_max   maximum size;<br>
     *                   0 means do not write anything, just count the length;<br>
     *                   1 is replaced by the maximum value for automatic storage;<br>
     *                   any large value means that the internal buffer will be<br>
     *                   reallocated as needed up to that limit; -1 is converted to<br>
     *                   UINT_MAX, the largest limit possible.<br>
     *                   Check also AV_BPRINT_SIZE_* macros.<br>
     * Original signature : <code>void av_bprint_init(AVBPrint*, unsigned, unsigned)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/bprint.h:59</i>
     */
    public void av_bprint_init(Pointer<AVBPrint > buf, int size_init, int size_max) {
        av_bprint_init(Pointer.getPeer(buf), size_init, size_max);
    }
    protected native void av_bprint_init(@Ptr long buf, int size_init, int size_max);
    /**
     * Init a print buffer using a pre-existing buffer.<br>
     * The buffer will not be reallocated.<br>
     * @param buf     buffer structure to init<br>
     * @param buffer  byte buffer to use for the string data<br>
     * @param size    size of buffer<br>
     * Original signature : <code>void av_bprint_init_for_buffer(AVBPrint*, char*, unsigned)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/bprint.h:68</i>
     */
    public void av_bprint_init_for_buffer(Pointer<AVBPrint > buf, Pointer<Byte > buffer, int size) {
        av_bprint_init_for_buffer(Pointer.getPeer(buf), Pointer.getPeer(buffer), size);
    }
    protected native void av_bprint_init_for_buffer(@Ptr long buf, @Ptr long buffer, int size);
    /**
     * Append a formatted string to a print buffer.<br>
     * Original signature : <code>void av_bprintf(AVBPrint*, const char*, null)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/bprint.h:73</i>
     */
    public void av_bprintf(Pointer<AVBPrint > buf, Pointer<Byte > fmt, Object... varArgs1) {
        av_bprintf(Pointer.getPeer(buf), Pointer.getPeer(fmt), varArgs1);
    }
    protected native void av_bprintf(@Ptr long buf, @Ptr long fmt, Object... varArgs1);
    /**
     * Append a formatted string to a print buffer.<br>
     * Original signature : <code>void av_vbprintf(AVBPrint*, const char*, va_list)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/bprint.h:78</i>
     */
    public void av_vbprintf(Pointer<AVBPrint > buf, Pointer<Byte > fmt, Object... vl_arg) {
        av_vbprintf(Pointer.getPeer(buf), Pointer.getPeer(fmt), vl_arg);
    }
    protected native void av_vbprintf(@Ptr long buf, @Ptr long fmt, Object... vl_arg);
    /**
     * Append char c n times to a print buffer.<br>
     * Original signature : <code>void av_bprint_chars(AVBPrint*, char, unsigned)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/bprint.h:83</i>
     */
    public void av_bprint_chars(Pointer<AVBPrint > buf, byte c, int n) {
        av_bprint_chars(Pointer.getPeer(buf), c, n);
    }
    protected native void av_bprint_chars(@Ptr long buf, byte c, int n);
    /**
     * Append data to a print buffer.<br>
     * param buf  bprint buffer to use<br>
     * param data pointer to data<br>
     * param size size of data<br>
     * Original signature : <code>void av_bprint_append_data(AVBPrint*, const char*, unsigned)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/bprint.h:91</i>
     */
    public void av_bprint_append_data(Pointer<AVBPrint > buf, Pointer<Byte > data, int size) {
        av_bprint_append_data(Pointer.getPeer(buf), Pointer.getPeer(data), size);
    }
    protected native void av_bprint_append_data(@Ptr long buf, @Ptr long data, int size);
    /**
     * Append a formatted date and time to a print buffer.<br>
     * param buf  bprint buffer to use<br>
     * param fmt  date and time format string, see strftime()<br>
     * param tm   broken-down time structure to translate<br>
     * @note due to poor design of the standard strftime function, it may<br>
     * produce poor results if the format string expands to a very long text and<br>
     * the bprint buffer is near the limit stated by the size_max option.<br>
     * Original signature : <code>void av_bprint_strftime(AVBPrint*, const char*, tm*)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/bprint.h:103</i>
     */
    public void av_bprint_strftime(Pointer<AVBPrint > buf, Pointer<Byte > fmt, Pointer<AvutilLibrary.tm > tm) {
        av_bprint_strftime(Pointer.getPeer(buf), Pointer.getPeer(fmt), Pointer.getPeer(tm));
    }
    protected native void av_bprint_strftime(@Ptr long buf, @Ptr long fmt, @Ptr long tm);
    /**
     * Allocate bytes in the buffer for external use.<br>
     * @param[in]  buf          buffer structure<br>
     * @param[in]  size         required size<br>
     * @param[out] mem          pointer to the memory area<br>
     * @param[out] actual_size  size of the memory area after allocation;<br>
     *                          can be larger or smaller than size<br>
     * Original signature : <code>void av_bprint_get_buffer(AVBPrint*, unsigned, unsigned char**, unsigned*)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/bprint.h:113</i>
     */
    public void av_bprint_get_buffer(Pointer<AVBPrint > buf, int size, Pointer<Pointer<Byte > > mem, Pointer<Integer > actual_size) {
        av_bprint_get_buffer(Pointer.getPeer(buf), size, Pointer.getPeer(mem), Pointer.getPeer(actual_size));
    }
    protected native void av_bprint_get_buffer(@Ptr long buf, int size, @Ptr long mem, @Ptr long actual_size);
    /**
     * Reset the string to "" but keep internal allocated data.<br>
     * Original signature : <code>void av_bprint_clear(AVBPrint*)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/bprint.h:118</i>
     */
    public void av_bprint_clear(Pointer<AVBPrint > buf) {
        av_bprint_clear(Pointer.getPeer(buf));
    }
    protected native void av_bprint_clear(@Ptr long buf);
    /**
     * Finalize a print buffer.<br>
     * The print buffer can no longer be used afterwards,<br>
     * but the len and size fields are still valid.<br>
     * @arg[out] ret_str  if not NULL, used to return a permanent copy of the<br>
     *                    buffer contents, or NULL if memory allocation fails;<br>
     *                    if NULL, the buffer is discarded and freed<br>
     * @return  0 for success or error code (probably AVERROR(ENOMEM))<br>
     * Original signature : <code>int av_bprint_finalize(AVBPrint*, char**)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/bprint.h:138</i>
     */
    public int av_bprint_finalize(Pointer<AVBPrint > buf, Pointer<Pointer<Byte > > ret_str) {
        return av_bprint_finalize(Pointer.getPeer(buf), Pointer.getPeer(ret_str));
    }
    protected native int av_bprint_finalize(@Ptr long buf, @Ptr long ret_str);
    /**
     * Escape the content in src and append it to dstbuf.<br>
     * @param dstbuf        already inited destination bprint buffer<br>
     * @param src           string containing the text to escape<br>
     * @param special_chars string containing the special characters which<br>
     *                      need to be escaped, can be NULL<br>
     * @param mode          escape mode to employ, see AV_ESCAPE_MODE_* macros.<br>
     *                      Any unknown value for mode will be considered equivalent to<br>
     *                      AV_ESCAPE_MODE_BACKSLASH, but this behaviour can change without<br>
     *                      notice.<br>
     * @param flags         flags which control how to escape, see AV_ESCAPE_FLAG_* macros<br>
     * Original signature : <code>void av_bprint_escape(AVBPrint*, const char*, const char*, AVEscapeMode, int)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/bprint.h:152</i>
     */
    /*public void av_bprint_escape(Pointer<AVBPrint > dstbuf, Pointer<Byte > src, Pointer<Byte > special_chars, IntValuedEnum<AvutilLibrary.AVEscapeMode > mode, int flags) {
        av_bprint_escape(Pointer.getPeer(dstbuf), Pointer.getPeer(src), Pointer.getPeer(special_chars), (int)mode.value(), flags);
    }
    protected native void av_bprint_escape(@Ptr long dstbuf, @Ptr long src, @Ptr long special_chars, int mode, int flags);*/
    /**
     * Adjust frame number for NTSC drop frame time code.<br>
     * @param framenum frame number to adjust<br>
     * @param fps      frame per second, 30 or 60<br>
     * @return         adjusted frame number<br>
     * @warning        adjustment is only valid in NTSC 29.97 and 59.94<br>
     * Original signature : <code>int av_timecode_adjust_ntsc_framenum2(int, int)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/timecode.h:26</i>
     */
    public native int av_timecode_adjust_ntsc_framenum2(int framenum, int fps);
    /**
     * Convert frame number to SMPTE 12M binary representation.<br>
     * @param tc       timecode data correctly initialized<br>
     * @param framenum frame number<br>
     * @return         the SMPTE binary representation<br>
     * @note Frame number adjustment is automatically done in case of drop timecode,<br>
     *       you do NOT have to call av_timecode_adjust_ntsc_framenum2().<br>
     * @note The frame number is relative to tc->start.<br>
     * @note Color frame (CF), binary group flags (BGF) and biphase mark polarity<br>
     *       correction (PC) bits are set to zero.<br>
     * Original signature : <code>uint32_t av_timecode_get_smpte_from_framenum(const AVTimecode*, int)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/timecode.h:39</i>
     */
    public int av_timecode_get_smpte_from_framenum(Pointer<AVTimecode > tc, int framenum) {
        return av_timecode_get_smpte_from_framenum(Pointer.getPeer(tc), framenum);
    }
    protected native int av_timecode_get_smpte_from_framenum(@Ptr long tc, int framenum);
    /**
     * Load timecode string in buf.<br>
     * @param buf      destination buffer, must be at least AV_TIMECODE_STR_SIZE long<br>
     * @param tc       timecode data correctly initialized<br>
     * @param framenum frame number<br>
     * @return         the buf parameter<br>
     * @note Timecode representation can be a negative timecode and have more than<br>
     *       24 hours, but will only be honored if the flags are correctly set.<br>
     * @note The frame number is relative to tc->start.<br>
     * Original signature : <code>char* av_timecode_make_string(const AVTimecode*, char*, int)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/timecode.h:51</i>
     */
    public Pointer<Byte > av_timecode_make_string(Pointer<AVTimecode > tc, Pointer<Byte > buf, int framenum) {
        return (Pointer)Pointer.pointerToAddress(av_timecode_make_string(Pointer.getPeer(tc), Pointer.getPeer(buf), framenum), Byte.class);
    }
    @Ptr
    protected native long av_timecode_make_string(@Ptr long tc, @Ptr long buf, int framenum);
    /**
     * Get the timecode string from the SMPTE timecode format.<br>
     * @param buf        destination buffer, must be at least AV_TIMECODE_STR_SIZE long<br>
     * @param tcsmpte    the 32-bit SMPTE timecode<br>
     * @param prevent_df prevent the use of a drop flag when it is known the DF bit<br>
     *                   is arbitrary<br>
     * @return           the buf parameter<br>
     * Original signature : <code>char* av_timecode_make_smpte_tc_string(char*, uint32_t, int)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/timecode.h:61</i>
     */
    public Pointer<Byte > av_timecode_make_smpte_tc_string(Pointer<Byte > buf, int tcsmpte, int prevent_df) {
        return (Pointer)Pointer.pointerToAddress(av_timecode_make_smpte_tc_string(Pointer.getPeer(buf), tcsmpte, prevent_df), Byte.class);
    }
    @Ptr
    protected native long av_timecode_make_smpte_tc_string(@Ptr long buf, int tcsmpte, int prevent_df);
    /**
     * Get the timecode string from the 25-bit timecode format (MPEG GOP format).<br>
     * @param buf     destination buffer, must be at least AV_TIMECODE_STR_SIZE long<br>
     * @param tc25bit the 25-bits timecode<br>
     * @return        the buf parameter<br>
     * Original signature : <code>char* av_timecode_make_mpeg_tc_string(char*, uint32_t)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/timecode.h:69</i>
     */
    public Pointer<Byte > av_timecode_make_mpeg_tc_string(Pointer<Byte > buf, int tc25bit) {
        return (Pointer)Pointer.pointerToAddress(av_timecode_make_mpeg_tc_string(Pointer.getPeer(buf), tc25bit), Byte.class);
    }
    @Ptr
    protected native long av_timecode_make_mpeg_tc_string(@Ptr long buf, int tc25bit);
    /**
     * Init a timecode struct with the passed parameters.<br>
     * @param log_ctx     a pointer to an arbitrary struct of which the first field<br>
     *                    is a pointer to an AVClass struct (used for av_log)<br>
     * @param tc          pointer to an allocated AVTimecode<br>
     * @param rate        frame rate in rational form<br>
     * @param flags       miscellaneous flags such as drop frame, +24 hours, ...<br>
     *                    (see AVTimecodeFlag)<br>
     * @param frame_start the first frame number<br>
     * @return            0 on success, AVERROR otherwise<br>
     * Original signature : <code>int av_timecode_init(AVTimecode*, AVRational, int, int, void*)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/timecode.h:82</i>
     */
    public int av_timecode_init(Pointer<AVTimecode > tc, AVRational rate, int flags, int frame_start, Pointer<? > log_ctx) {
        return av_timecode_init(Pointer.getPeer(tc), rate, flags, frame_start, Pointer.getPeer(log_ctx));
    }
    protected native int av_timecode_init(@Ptr long tc, AVRational rate, int flags, int frame_start, @Ptr long log_ctx);
    /**
     * Parse timecode representation (hh:mm:ss[:;.]ff).<br>
     * @param log_ctx a pointer to an arbitrary struct of which the first field is a<br>
     *                pointer to an AVClass struct (used for av_log).<br>
     * @param tc      pointer to an allocated AVTimecode<br>
     * @param rate    frame rate in rational form<br>
     * @param str     timecode string which will determine the frame start<br>
     * @return        0 on success, AVERROR otherwise<br>
     * Original signature : <code>int av_timecode_init_from_string(AVTimecode*, AVRational, const char*, void*)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/timecode.h:93</i>
     */
    public int av_timecode_init_from_string(Pointer<AVTimecode > tc, AVRational rate, Pointer<Byte > str, Pointer<? > log_ctx) {
        return av_timecode_init_from_string(Pointer.getPeer(tc), rate, Pointer.getPeer(str), Pointer.getPeer(log_ctx));
    }
    protected native int av_timecode_init_from_string(@Ptr long tc, AVRational rate, @Ptr long str, @Ptr long log_ctx);
    /**
     * Check if the timecode feature is available for the given frame rate<br>
     * @return 0 if supported, <0 otherwise<br>
     * Original signature : <code>int av_timecode_check_frame_rate(AVRational)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/timecode.h:99</i>
     */
    public native int av_timecode_check_frame_rate(AVRational rate);
    /**
     * Allocate a new message queue.<br>
     * @param mq      pointer to the message queue<br>
     * @param nelem   maximum number of elements in the queue<br>
     * @param elsize  size of each element in the queue<br>
     * @return  >=0 for success; <0 for error, in particular AVERROR(ENOSYS) if<br>
     *          lavu was built without thread support<br>
     * Original signature : <code>int av_thread_message_queue_alloc(AVThreadMessageQueue**, unsigned, unsigned)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/threadmessage.h:27</i>
     */
    public int av_thread_message_queue_alloc(Pointer<Pointer<AvutilLibrary.AVThreadMessageQueue > > mq, int nelem, int elsize) {
        return av_thread_message_queue_alloc(Pointer.getPeer(mq), nelem, elsize);
    }
    protected native int av_thread_message_queue_alloc(@Ptr long mq, int nelem, int elsize);
    /**
     * Free a message queue.<br>
     * The message queue must no longer be in use by another thread.<br>
     * Original signature : <code>void av_thread_message_queue_free(AVThreadMessageQueue**)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/threadmessage.h:33</i>
     */
    public void av_thread_message_queue_free(Pointer<Pointer<AvutilLibrary.AVThreadMessageQueue > > mq) {
        av_thread_message_queue_free(Pointer.getPeer(mq));
    }
    protected native void av_thread_message_queue_free(@Ptr long mq);
    /**
     * Send a message on the queue.<br>
     * Original signature : <code>int av_thread_message_queue_send(AVThreadMessageQueue*, void*, unsigned)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/threadmessage.h:38</i>
     */
    public int av_thread_message_queue_send(Pointer<AvutilLibrary.AVThreadMessageQueue > mq, Pointer<? > msg, int flags) {
        return av_thread_message_queue_send(Pointer.getPeer(mq), Pointer.getPeer(msg), flags);
    }
    protected native int av_thread_message_queue_send(@Ptr long mq, @Ptr long msg, int flags);
    /**
     * Receive a message from the queue.<br>
     * Original signature : <code>int av_thread_message_queue_recv(AVThreadMessageQueue*, void*, unsigned)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/threadmessage.h:43</i>
     */
    public int av_thread_message_queue_recv(Pointer<AvutilLibrary.AVThreadMessageQueue > mq, Pointer<? > msg, int flags) {
        return av_thread_message_queue_recv(Pointer.getPeer(mq), Pointer.getPeer(msg), flags);
    }
    protected native int av_thread_message_queue_recv(@Ptr long mq, @Ptr long msg, int flags);
    /**
     * Set the sending error code.<br>
     * If the error code is set to non-zero, av_thread_message_queue_recv() will<br>
     * return it immediately when there are no longer available messages.<br>
     * Conventional values, such as AVERROR_EOF or AVERROR(EAGAIN), can be used<br>
     * to cause the receiving thread to stop or suspend its operation.<br>
     * Original signature : <code>void av_thread_message_queue_set_err_send(AVThreadMessageQueue*, int)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/threadmessage.h:52</i>
     */
    public void av_thread_message_queue_set_err_send(Pointer<AvutilLibrary.AVThreadMessageQueue > mq, int err) {
        av_thread_message_queue_set_err_send(Pointer.getPeer(mq), err);
    }
    protected native void av_thread_message_queue_set_err_send(@Ptr long mq, int err);
    /**
     * Set the receiving error code.<br>
     * If the error code is set to non-zero, av_thread_message_queue_send() will<br>
     * return it immediately. Conventional values, such as AVERROR_EOF or<br>
     * AVERROR(EAGAIN), can be used to cause the sending thread to stop or<br>
     * suspend its operation.<br>
     * Original signature : <code>void av_thread_message_queue_set_err_recv(AVThreadMessageQueue*, int)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/threadmessage.h:61</i>
     */
    public void av_thread_message_queue_set_err_recv(Pointer<AvutilLibrary.AVThreadMessageQueue > mq, int err) {
        av_thread_message_queue_set_err_recv(Pointer.getPeer(mq), err);
    }
    protected native void av_thread_message_queue_set_err_recv(@Ptr long mq, int err);
    /**
     * Read a line from an image, and write the values of the<br>
     * pixel format component c to dst.<br>
     * @param data the array containing the pointers to the planes of the image<br>
     * @param linesize the array containing the linesizes of the image<br>
     * @param desc the pixel format descriptor for the image<br>
     * @param x the horizontal coordinate of the first pixel to read<br>
     * @param y the vertical coordinate of the first pixel to read<br>
     * @param w the width of the line to read, that is the number of<br>
     * values to write to dst<br>
     * @param read_pal_component if not zero and the format is a paletted<br>
     * format writes the values corresponding to the palette<br>
     * component c in data[1] to dst, rather than the palette indexes in<br>
     * data[0]. The behavior is undefined if the format is not paletted.<br>
     * Original signature : <code>void av_read_image_line(uint16_t*, const uint8_t*[4], const int[4], const AVPixFmtDescriptor*, int, int, int, int, int)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/pixdesc.h:45</i>
     */
    public void av_read_image_line(Pointer<Short > dst, Pointer<Pointer<Byte > > data, Pointer<Integer > linesize, Pointer<AVPixFmtDescriptor > desc, int x, int y, int c, int w, int read_pal_component) {
        av_read_image_line(Pointer.getPeer(dst), Pointer.getPeer(data), Pointer.getPeer(linesize), Pointer.getPeer(desc), x, y, c, w, read_pal_component);
    }
    protected native void av_read_image_line(@Ptr long dst, @Ptr long data, @Ptr long linesize, @Ptr long desc, int x, int y, int c, int w, int read_pal_component);
    /**
     * Write the values from src to the pixel format component c of an<br>
     * image line.<br>
     * @param src array containing the values to write<br>
     * @param data the array containing the pointers to the planes of the<br>
     * image to write into. It is supposed to be zeroed.<br>
     * @param linesize the array containing the linesizes of the image<br>
     * @param desc the pixel format descriptor for the image<br>
     * @param x the horizontal coordinate of the first pixel to write<br>
     * @param y the vertical coordinate of the first pixel to write<br>
     * @param w the width of the line to write, that is the number of<br>
     * values to write to the image line<br>
     * Original signature : <code>void av_write_image_line(const uint16_t*, uint8_t*[4], const int[4], const AVPixFmtDescriptor*, int, int, int, int)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/pixdesc.h:60</i>
     */
    public void av_write_image_line(Pointer<Short > src, Pointer<Pointer<Byte > > data, Pointer<Integer > linesize, Pointer<AVPixFmtDescriptor > desc, int x, int y, int c, int w) {
        av_write_image_line(Pointer.getPeer(src), Pointer.getPeer(data), Pointer.getPeer(linesize), Pointer.getPeer(desc), x, y, c, w);
    }
    protected native void av_write_image_line(@Ptr long src, @Ptr long data, @Ptr long linesize, @Ptr long desc, int x, int y, int c, int w);
    /**
     * Return the pixel format corresponding to name.<br>
     * If there is no pixel format with name name, then looks for a<br>
     * pixel format with the name corresponding to the native endian<br>
     * format of name.<br>
     * For example in a little-endian system, first looks for "gray16",<br>
     * then for "gray16le".<br>
     * Finally if no pixel format has been found, returns AV_PIX_FMT_NONE.<br>
     * Original signature : <code>AVPixelFormat av_get_pix_fmt(const char*)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/pixdesc.h:71</i>
     */
    public IntValuedEnum<AvutilLibrary.AVPixelFormat > av_get_pix_fmt(Pointer<Byte > name) {
        return FlagSet.fromValue(av_get_pix_fmt(Pointer.getPeer(name)), AvutilLibrary.AVPixelFormat.class);
    }
    protected native int av_get_pix_fmt(@Ptr long name);
    /**
     * Return the short name for a pixel format, NULL in case pix_fmt is<br>
     * unknown.<br>
     * @see av_get_pix_fmt(), av_get_pix_fmt_string()<br>
     * Original signature : <code>char* av_get_pix_fmt_name(AVPixelFormat)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/pixdesc.h:78</i>
     */
    public Pointer<Byte > av_get_pix_fmt_name(IntValuedEnum<AvutilLibrary.AVPixelFormat > pix_fmt) {
        return (Pointer)Pointer.pointerToAddress(av_get_pix_fmt_name((int)pix_fmt.value()), Byte.class);
    }
    @Ptr
    protected native long av_get_pix_fmt_name(int pix_fmt);
    /**
     * Print in buf the string corresponding to the pixel format with<br>
     * number pix_fmt, or a header if pix_fmt is negative.<br>
     * @param buf the buffer where to write the string<br>
     * @param buf_size the size of buf<br>
     * @param pix_fmt the number of the pixel format to print the<br>
     * corresponding info string, or a negative value to print the<br>
     * corresponding header.<br>
     * Original signature : <code>char* av_get_pix_fmt_string(char*, int, AVPixelFormat)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/pixdesc.h:89</i>
     */
    public Pointer<Byte > av_get_pix_fmt_string(Pointer<Byte > buf, int buf_size, IntValuedEnum<AvutilLibrary.AVPixelFormat > pix_fmt) {
        return (Pointer)Pointer.pointerToAddress(av_get_pix_fmt_string(Pointer.getPeer(buf), buf_size, (int)pix_fmt.value()), Byte.class);
    }
    @Ptr
    protected native long av_get_pix_fmt_string(@Ptr long buf, int buf_size, int pix_fmt);
    /**
     * Return the number of bits per pixel used by the pixel format<br>
     * described by pixdesc. Note that this is not the same as the number<br>
     * of bits per sample.<br>
     * The returned number of bits refers to the number of bits actually<br>
     * used for storing the pixel information, that is padding bits are<br>
     * not counted.<br>
     * Original signature : <code>int av_get_bits_per_pixel(const AVPixFmtDescriptor*)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/pixdesc.h:99</i>
     */
    public int av_get_bits_per_pixel(Pointer<AVPixFmtDescriptor > pixdesc) {
        return av_get_bits_per_pixel(Pointer.getPeer(pixdesc));
    }
    protected native int av_get_bits_per_pixel(@Ptr long pixdesc);
    /**
     * Return the number of bits per pixel for the pixel format<br>
     * described by pixdesc, including any padding or unused bits.<br>
     * Original signature : <code>int av_get_padded_bits_per_pixel(const AVPixFmtDescriptor*)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/pixdesc.h:105</i>
     */
    public int av_get_padded_bits_per_pixel(Pointer<AVPixFmtDescriptor > pixdesc) {
        return av_get_padded_bits_per_pixel(Pointer.getPeer(pixdesc));
    }
    protected native int av_get_padded_bits_per_pixel(@Ptr long pixdesc);
    /**
     * @return a pixel format descriptor for provided pixel format or NULL if<br>
     * this pixel format is unknown.<br>
     * Original signature : <code>AVPixFmtDescriptor* av_pix_fmt_desc_get(AVPixelFormat)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/pixdesc.h:111</i>
     */
    public Pointer<AVPixFmtDescriptor > av_pix_fmt_desc_get(IntValuedEnum<AvutilLibrary.AVPixelFormat > pix_fmt) {
        return (Pointer)Pointer.pointerToAddress(av_pix_fmt_desc_get((int)pix_fmt.value()), AVPixFmtDescriptor.class);
    }
    @Ptr
    protected native long av_pix_fmt_desc_get(int pix_fmt);
    /**
     * Iterate over all pixel format descriptors known to libavutil.<br>
     * @param prev previous descriptor. NULL to get the first descriptor.<br>
     * @return next descriptor or NULL after the last descriptor<br>
     * Original signature : <code>AVPixFmtDescriptor* av_pix_fmt_desc_next(const AVPixFmtDescriptor*)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/pixdesc.h:118</i>
     */
    public Pointer<AVPixFmtDescriptor > av_pix_fmt_desc_next(Pointer<AVPixFmtDescriptor > prev) {
        return (Pointer)Pointer.pointerToAddress(av_pix_fmt_desc_next(Pointer.getPeer(prev)), AVPixFmtDescriptor.class);
    }
    @Ptr
    protected native long av_pix_fmt_desc_next(@Ptr long prev);
    /**
     * @return an AVPixelFormat id described by desc, or AV_PIX_FMT_NONE if desc<br>
     * is not a valid pointer to a pixel format descriptor.<br>
     * Original signature : <code>AVPixelFormat av_pix_fmt_desc_get_id(const AVPixFmtDescriptor*)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/pixdesc.h:124</i>
     */
    public IntValuedEnum<AvutilLibrary.AVPixelFormat > av_pix_fmt_desc_get_id(Pointer<AVPixFmtDescriptor > desc) {
        return FlagSet.fromValue(av_pix_fmt_desc_get_id(Pointer.getPeer(desc)), AvutilLibrary.AVPixelFormat.class);
    }
    protected native int av_pix_fmt_desc_get_id(@Ptr long desc);
    /**
     * Utility function to access log2_chroma_w log2_chroma_h from<br>
     * the pixel format AVPixFmtDescriptor.<br>
     * See av_get_chroma_sub_sample() for a function that asserts a<br>
     * valid pixel format instead of returning an error code.<br>
     * Its recommended that you use avcodec_get_chroma_sub_sample unless<br>
     * you do check the return code!<br>
     * @param[in]  pix_fmt the pixel format<br>
     * @param[out] h_shift store log2_chroma_w<br>
     * @param[out] v_shift store log2_chroma_h<br>
     * @return 0 on success, AVERROR(ENOSYS) on invalid or unknown pixel format<br>
     * Original signature : <code>int av_pix_fmt_get_chroma_sub_sample(AVPixelFormat, int*, int*)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/pixdesc.h:138</i>
     */
    public int av_pix_fmt_get_chroma_sub_sample(IntValuedEnum<AvutilLibrary.AVPixelFormat > pix_fmt, Pointer<Integer > h_shift, Pointer<Integer > v_shift) {
        return av_pix_fmt_get_chroma_sub_sample((int)pix_fmt.value(), Pointer.getPeer(h_shift), Pointer.getPeer(v_shift));
    }
    protected native int av_pix_fmt_get_chroma_sub_sample(int pix_fmt, @Ptr long h_shift, @Ptr long v_shift);
    /**
     * @return number of planes in pix_fmt, a negative AVERROR if pix_fmt is not a<br>
     * valid pixel format.<br>
     * Original signature : <code>int av_pix_fmt_count_planes(AVPixelFormat)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/pixdesc.h:144</i>
     */
    public int av_pix_fmt_count_planes(IntValuedEnum<AvutilLibrary.AVPixelFormat > pix_fmt) {
        return av_pix_fmt_count_planes((int)pix_fmt.value());
    }
    protected native int av_pix_fmt_count_planes(int pix_fmt);
    /**
     * Utility function to swap the endianness of a pixel format.<br>
     * @param[in]  pix_fmt the pixel format<br>
     * @return pixel format with swapped endianness if it exists,<br>
     * otherwise AV_PIX_FMT_NONE<br>
     * Original signature : <code>AVPixelFormat av_pix_fmt_swap_endianness(AVPixelFormat)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/pixdesc.h:152</i>
     */
    public IntValuedEnum<AvutilLibrary.AVPixelFormat > av_pix_fmt_swap_endianness(IntValuedEnum<AvutilLibrary.AVPixelFormat > pix_fmt) {
        return FlagSet.fromValue(av_pix_fmt_swap_endianness((int)pix_fmt.value()), AvutilLibrary.AVPixelFormat.class);
    }
    protected native int av_pix_fmt_swap_endianness(int pix_fmt);
    /**
     * Compute what kind of losses will occur when converting from one specific<br>
     * pixel format to another.<br>
     * When converting from one pixel format to another, information loss may occur.<br>
     * For example, when converting from RGB24 to GRAY, the color information will<br>
     * be lost. Similarly, other losses occur when converting from some formats to<br>
     * other formats. These losses can involve loss of chroma, but also loss of<br>
     * resolution, loss of color depth, loss due to the color space conversion, loss<br>
     * of the alpha bits or loss due to color quantization.<br>
     * av_get_fix_fmt_loss() informs you about the various types of losses<br>
     * which will occur when converting from one pixel format to another.<br>
     * @param[in] dst_pix_fmt destination pixel format<br>
     * @param[in] src_pix_fmt source pixel format<br>
     * @param[in] has_alpha Whether the source pixel format alpha channel is used.<br>
     * @return Combination of flags informing you what kind of losses will occur<br>
     * (maximum loss for an invalid dst_pix_fmt).<br>
     * Original signature : <code>int av_get_pix_fmt_loss(AVPixelFormat, AVPixelFormat, int)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/pixdesc.h:171</i>
     */
    public int av_get_pix_fmt_loss(IntValuedEnum<AvutilLibrary.AVPixelFormat > dst_pix_fmt, IntValuedEnum<AvutilLibrary.AVPixelFormat > src_pix_fmt, int has_alpha) {
        return av_get_pix_fmt_loss((int)dst_pix_fmt.value(), (int)src_pix_fmt.value(), has_alpha);
    }
    protected native int av_get_pix_fmt_loss(int dst_pix_fmt, int src_pix_fmt, int has_alpha);
    /**
     * Compute what kind of losses will occur when converting from one specific<br>
     * pixel format to another.<br>
     * When converting from one pixel format to another, information loss may occur.<br>
     * For example, when converting from RGB24 to GRAY, the color information will<br>
     * be lost. Similarly, other losses occur when converting from some formats to<br>
     * other formats. These losses can involve loss of chroma, but also loss of<br>
     * resolution, loss of color depth, loss due to the color space conversion, loss<br>
     * of the alpha bits or loss due to color quantization.<br>
     * av_get_fix_fmt_loss() informs you about the various types of losses<br>
     * which will occur when converting from one pixel format to another.<br>
     * @param[in] dst_pix_fmt destination pixel format<br>
     * @param[in] src_pix_fmt source pixel format<br>
     * @param[in] has_alpha Whether the source pixel format alpha channel is used.<br>
     * @return Combination of flags informing you what kind of losses will occur<br>
     * (maximum loss for an invalid dst_pix_fmt).<br>
     * Original signature : <code>AVPixelFormat av_find_best_pix_fmt_of_2(AVPixelFormat, AVPixelFormat, AVPixelFormat, int, int*)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/pixdesc.h:190</i>
     */
    public IntValuedEnum<AvutilLibrary.AVPixelFormat > av_find_best_pix_fmt_of_2(IntValuedEnum<AvutilLibrary.AVPixelFormat > dst_pix_fmt1, IntValuedEnum<AvutilLibrary.AVPixelFormat > dst_pix_fmt2, IntValuedEnum<AvutilLibrary.AVPixelFormat > src_pix_fmt, int has_alpha, Pointer<Integer > loss_ptr) {
        return FlagSet.fromValue(av_find_best_pix_fmt_of_2((int)dst_pix_fmt1.value(), (int)dst_pix_fmt2.value(), (int)src_pix_fmt.value(), has_alpha, Pointer.getPeer(loss_ptr)), AvutilLibrary.AVPixelFormat.class);
    }
    protected native int av_find_best_pix_fmt_of_2(int dst_pix_fmt1, int dst_pix_fmt2, int src_pix_fmt, int has_alpha, @Ptr long loss_ptr);
    /**
     * @return the name for provided color range or NULL if unknown.<br>
     * Original signature : <code>char* av_color_range_name(AVColorRange)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/pixdesc.h:195</i>
     */
    public Pointer<Byte > av_color_range_name(IntValuedEnum<AvutilLibrary.AVColorRange > range) {
        return (Pointer)Pointer.pointerToAddress(av_color_range_name((int)range.value()), Byte.class);
    }
    @Ptr
    protected native long av_color_range_name(int range);
    /**
     * @return the name for provided color primaries or NULL if unknown.<br>
     * Original signature : <code>char* av_color_primaries_name(AVColorPrimaries)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/pixdesc.h:200</i>
     */
    public Pointer<Byte > av_color_primaries_name(IntValuedEnum<AvutilLibrary.AVColorPrimaries > primaries) {
        return (Pointer)Pointer.pointerToAddress(av_color_primaries_name((int)primaries.value()), Byte.class);
    }
    @Ptr
    protected native long av_color_primaries_name(int primaries);
    /**
     * @return the name for provided color transfer or NULL if unknown.<br>
     * Original signature : <code>char* av_color_transfer_name(AVColorTransferCharacteristic)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/pixdesc.h:205</i>
     */
    public Pointer<Byte > av_color_transfer_name(IntValuedEnum<AvutilLibrary.AVColorTransferCharacteristic > transfer) {
        return (Pointer)Pointer.pointerToAddress(av_color_transfer_name((int)transfer.value()), Byte.class);
    }
    @Ptr
    protected native long av_color_transfer_name(int transfer);
    /**
     * @return the name for provided color space or NULL if unknown.<br>
     * Original signature : <code>char* av_color_space_name(AVColorSpace)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/pixdesc.h:210</i>
     */
    public Pointer<Byte > av_color_space_name(IntValuedEnum<AvutilLibrary.AVColorSpace > space) {
        return (Pointer)Pointer.pointerToAddress(av_color_space_name((int)space.value()), Byte.class);
    }
    @Ptr
    protected native long av_color_space_name(int space);
    /**
     * @return the name for provided chroma location or NULL if unknown.<br>
     * Original signature : <code>char* av_chroma_location_name(AVChromaLocation)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/pixdesc.h:215</i>
     */
    public Pointer<Byte > av_chroma_location_name(IntValuedEnum<AvutilLibrary.AVChromaLocation > location) {
        return (Pointer)Pointer.pointerToAddress(av_chroma_location_name((int)location.value()), Byte.class);
    }
    @Ptr
    protected native long av_chroma_location_name(int location);
    /**
     * Get a potentially optimized pointer to a Sum-of-absolute-differences<br>
     * function (see the av_pixelutils_sad_fn prototype).<br>
     * @param w_bits  1<<w_bits is the requested width of the block size<br>
     * @param h_bits  1<<h_bits is the requested height of the block size<br>
     * @param aligned If set to 2, the returned sad function will assume src1 and<br>
     *                src2 addresses are aligned on the block size.<br>
     *                If set to 1, the returned sad function will assume src1 is<br>
     *                aligned on the block size.<br>
     *                If set to 0, the returned sad function assume no particular<br>
     *                alignment.<br>
     * @param log_ctx context used for logging, can be NULL<br>
     * @return a pointer to the SAD function or NULL in case of error (because of<br>
     *         invalid parameters)<br>
     * Original signature : <code>av_pixelutils_sad_fn av_pixelutils_get_sad_fn(int, int, int, void*)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/pixelutils.h:18</i>
     */
    public Pointer<AvutilLibrary.av_pixelutils_sad_fn > av_pixelutils_get_sad_fn(int w_bits, int h_bits, int aligned, Pointer<? > log_ctx) {
        return (Pointer)Pointer.pointerToAddress(av_pixelutils_get_sad_fn(w_bits, h_bits, aligned, Pointer.getPeer(log_ctx)), AvutilLibrary.av_pixelutils_sad_fn.class);
    }
    @Ptr
    protected native long av_pixelutils_get_sad_fn(int w_bits, int h_bits, int aligned, @Ptr long log_ctx);
    /**
     * Compute the max pixel step for each plane of an image with a<br>
     * format described by pixdesc.<br>
     * The pixel step is the distance in bytes between the first byte of<br>
     * the group of bytes which describe a pixel component and the first<br>
     * byte of the successive group in the same plane for the same<br>
     * component.<br>
     * @param max_pixsteps an array which is filled with the max pixel step<br>
     * for each plane. Since a plane may contain different pixel<br>
     * components, the computed max_pixsteps[plane] is relative to the<br>
     * component in the plane with the max pixel step.<br>
     * @param max_pixstep_comps an array which is filled with the component<br>
     * for each plane which has the max pixel step. May be NULL.<br>
     * Original signature : <code>void av_image_fill_max_pixsteps(int[4], int[4], const AVPixFmtDescriptor*)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/imgutils.h:15</i>
     */
    public void av_image_fill_max_pixsteps(Pointer<Integer > max_pixsteps, Pointer<Integer > max_pixstep_comps, Pointer<AVPixFmtDescriptor > pixdesc) {
        av_image_fill_max_pixsteps(Pointer.getPeer(max_pixsteps), Pointer.getPeer(max_pixstep_comps), Pointer.getPeer(pixdesc));
    }
    protected native void av_image_fill_max_pixsteps(@Ptr long max_pixsteps, @Ptr long max_pixstep_comps, @Ptr long pixdesc);
    /**
     * Compute the size of an image line with format pix_fmt and width<br>
     * width for the plane plane.<br>
     * @return the computed size in bytes<br>
     * Original signature : <code>int av_image_get_linesize(AVPixelFormat, int, int)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/imgutils.h:22</i>
     */
    public int av_image_get_linesize(IntValuedEnum<AvutilLibrary.AVPixelFormat > pix_fmt, int width, int plane) {
        return av_image_get_linesize((int)pix_fmt.value(), width, plane);
    }
    protected native int av_image_get_linesize(int pix_fmt, int width, int plane);
    /**
     * Fill plane linesizes for an image with pixel format pix_fmt and<br>
     * width width.<br>
     * @param linesizes array to be filled with the linesize for each plane<br>
     * @return >= 0 in case of success, a negative error code otherwise<br>
     * Original signature : <code>int av_image_fill_linesizes(int[4], AVPixelFormat, int)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/imgutils.h:30</i>
     */
    public int av_image_fill_linesizes(Pointer<Integer > linesizes, IntValuedEnum<AvutilLibrary.AVPixelFormat > pix_fmt, int width) {
        return av_image_fill_linesizes(Pointer.getPeer(linesizes), (int)pix_fmt.value(), width);
    }
    protected native int av_image_fill_linesizes(@Ptr long linesizes, int pix_fmt, int width);
    /**
     * Fill plane data pointers for an image with pixel format pix_fmt and<br>
     * height height.<br>
     * @param data pointers array to be filled with the pointer for each image plane<br>
     * @param ptr the pointer to a buffer which will contain the image<br>
     * @param linesizes the array containing the linesize for each<br>
     * plane, should be filled by av_image_fill_linesizes()<br>
     * @return the size in bytes required for the image buffer, a negative<br>
     * error code in case of failure<br>
     * Original signature : <code>int av_image_fill_pointers(uint8_t*[4], AVPixelFormat, int, uint8_t*, const int[4])</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/imgutils.h:42</i>
     */
    public int av_image_fill_pointers(Pointer<Pointer<Byte > > data, IntValuedEnum<AvutilLibrary.AVPixelFormat > pix_fmt, int height, Pointer<Byte > ptr, Pointer<Integer > linesizes) {
        return av_image_fill_pointers(Pointer.getPeer(data), (int)pix_fmt.value(), height, Pointer.getPeer(ptr), Pointer.getPeer(linesizes));
    }
    protected native int av_image_fill_pointers(@Ptr long data, int pix_fmt, int height, @Ptr long ptr, @Ptr long linesizes);
    /**
     * Allocate an image with size w and h and pixel format pix_fmt, and<br>
     * fill pointers and linesizes accordingly.<br>
     * The allocated image buffer has to be freed by using<br>
     * av_freep(&pointers[0]).<br>
     * @param align the value to use for buffer size alignment<br>
     * @return the size in bytes required for the image buffer, a negative<br>
     * error code in case of failure<br>
     * Original signature : <code>int av_image_alloc(uint8_t*[4], int[4], int, int, AVPixelFormat, int)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/imgutils.h:53</i>
     */
    public int av_image_alloc(Pointer<Pointer<Byte > > pointers, Pointer<Integer > linesizes, int w, int h, IntValuedEnum<AvutilLibrary.AVPixelFormat > pix_fmt, int align) {
        return av_image_alloc(Pointer.getPeer(pointers), Pointer.getPeer(linesizes), w, h, (int)pix_fmt.value(), align);
    }
    protected native int av_image_alloc(@Ptr long pointers, @Ptr long linesizes, int w, int h, int pix_fmt, int align);
    /**
     * Copy image plane from src to dst.<br>
     * That is, copy "height" number of lines of "bytewidth" bytes each.<br>
     * The first byte of each successive line is separated by *_linesize<br>
     * bytes.<br>
     * bytewidth must be contained by both absolute values of dst_linesize<br>
     * and src_linesize, otherwise the function behavior is undefined.<br>
     * @param dst_linesize linesize for the image plane in dst<br>
     * @param src_linesize linesize for the image plane in src<br>
     * Original signature : <code>void av_image_copy_plane(uint8_t*, int, const uint8_t*, int, int, int)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/imgutils.h:65</i>
     */
    public void av_image_copy_plane(Pointer<Byte > dst, int dst_linesize, Pointer<Byte > src, int src_linesize, int bytewidth, int height) {
        av_image_copy_plane(Pointer.getPeer(dst), dst_linesize, Pointer.getPeer(src), src_linesize, bytewidth, height);
    }
    protected native void av_image_copy_plane(@Ptr long dst, int dst_linesize, @Ptr long src, int src_linesize, int bytewidth, int height);
    /**
     * Copy image in src_data to dst_data.<br>
     * @param dst_linesizes linesizes for the image in dst_data<br>
     * @param src_linesizes linesizes for the image in src_data<br>
     * Original signature : <code>void av_image_copy(uint8_t*[4], int[4], const uint8_t*[4], const int[4], AVPixelFormat, int, int)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/imgutils.h:72</i>
     */
    public void av_image_copy(Pointer<Pointer<Byte > > dst_data, Pointer<Integer > dst_linesizes, Pointer<Pointer<Byte > > src_data, Pointer<Integer > src_linesizes, IntValuedEnum<AvutilLibrary.AVPixelFormat > pix_fmt, int width, int height) {
        av_image_copy(Pointer.getPeer(dst_data), Pointer.getPeer(dst_linesizes), Pointer.getPeer(src_data), Pointer.getPeer(src_linesizes), (int)pix_fmt.value(), width, height);
    }
    protected native void av_image_copy(@Ptr long dst_data, @Ptr long dst_linesizes, @Ptr long src_data, @Ptr long src_linesizes, int pix_fmt, int width, int height);
    /**
     * Setup the data pointers and linesizes based on the specified image<br>
     * parameters and the provided array.<br>
     * The fields of the given image are filled in by using the src<br>
     * address which points to the image data buffer. Depending on the<br>
     * specified pixel format, one or multiple image data pointers and<br>
     * line sizes will be set.  If a planar format is specified, several<br>
     * pointers will be set pointing to the different picture planes and<br>
     * the line sizes of the different planes will be stored in the<br>
     * lines_sizes array. Call with src == NULL to get the required<br>
     * size for the src buffer.<br>
     * To allocate the buffer and fill in the dst_data and dst_linesize in<br>
     * one call, use av_image_alloc().<br>
     * @param dst_data      data pointers to be filled in<br>
     * @param dst_linesizes linesizes for the image in dst_data to be filled in<br>
     * @param src           buffer which will contain or contains the actual image data, can be NULL<br>
     * @param pix_fmt       the pixel format of the image<br>
     * @param width         the width of the image in pixels<br>
     * @param height        the height of the image in pixels<br>
     * @param align         the value used in src for linesize alignment<br>
     * @return the size in bytes required for src, a negative error code<br>
     * in case of failure<br>
     * Original signature : <code>int av_image_fill_arrays(uint8_t*[4], int[4], const uint8_t*, AVPixelFormat, int, int, int)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/imgutils.h:97</i>
     */
    public int av_image_fill_arrays(Pointer<Pointer<Byte > > dst_data, Pointer<Integer > dst_linesize, Pointer<Byte > src, IntValuedEnum<AvutilLibrary.AVPixelFormat > pix_fmt, int width, int height, int align) {
        return av_image_fill_arrays(Pointer.getPeer(dst_data), Pointer.getPeer(dst_linesize), Pointer.getPeer(src), (int)pix_fmt.value(), width, height, align);
    }
    protected native int av_image_fill_arrays(@Ptr long dst_data, @Ptr long dst_linesize, @Ptr long src, int pix_fmt, int width, int height, int align);
    /**
     * Return the size in bytes of the amount of data required to store an<br>
     * image with the given parameters.<br>
     * @param[in] align the assumed linesize alignment<br>
     * Original signature : <code>int av_image_get_buffer_size(AVPixelFormat, int, int, int)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/imgutils.h:104</i>
     */
    public int av_image_get_buffer_size(IntValuedEnum<AvutilLibrary.AVPixelFormat > pix_fmt, int width, int height, int align) {
        return av_image_get_buffer_size((int)pix_fmt.value(), width, height, align);
    }
    protected native int av_image_get_buffer_size(int pix_fmt, int width, int height, int align);
    /**
     * Copy image data from an image into a buffer.<br>
     * av_image_get_buffer_size() can be used to compute the required size<br>
     * for the buffer to fill.<br>
     * @param dst           a buffer into which picture data will be copied<br>
     * @param dst_size      the size in bytes of dst<br>
     * @param src_data      pointers containing the source image data<br>
     * @param src_linesizes linesizes for the image in src_data<br>
     * @param pix_fmt       the pixel format of the source image<br>
     * @param width         the width of the source image in pixels<br>
     * @param height        the height of the source image in pixels<br>
     * @param align         the assumed linesize alignment for dst<br>
     * @return the number of bytes written to dst, or a negative value<br>
     * (error code) on error<br>
     * Original signature : <code>int av_image_copy_to_buffer(uint8_t*, int, const const uint8_t*[4], const int[4], AVPixelFormat, int, int, int)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/imgutils.h:121</i>
     */
    public int av_image_copy_to_buffer(Pointer<Byte > dst, int dst_size, Pointer<Pointer<Byte > > src_data, Pointer<Integer > src_linesize, IntValuedEnum<AvutilLibrary.AVPixelFormat > pix_fmt, int width, int height, int align) {
        return av_image_copy_to_buffer(Pointer.getPeer(dst), dst_size, Pointer.getPeer(src_data), Pointer.getPeer(src_linesize), (int)pix_fmt.value(), width, height, align);
    }
    protected native int av_image_copy_to_buffer(@Ptr long dst, int dst_size, @Ptr long src_data, @Ptr long src_linesize, int pix_fmt, int width, int height, int align);
    /**
     * Check if the given dimension of an image is valid, meaning that all<br>
     * bytes of the image can be addressed with a signed int.<br>
     * @param w the width of the picture<br>
     * @param h the height of the picture<br>
     * @param log_offset the offset to sum to the log level for logging with log_ctx<br>
     * @param log_ctx the parent logging context, it may be NULL<br>
     * @return >= 0 if valid, a negative error code otherwise<br>
     * Original signature : <code>int av_image_check_size(unsigned int, unsigned int, int, void*)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/imgutils.h:132</i>
     */
    public int av_image_check_size(int w, int h, int log_offset, Pointer<? > log_ctx) {
        return av_image_check_size(w, h, log_offset, Pointer.getPeer(log_ctx));
    }
    protected native int av_image_check_size(int w, int h, int log_offset, @Ptr long log_ctx);
    /**
     * Check if the given sample aspect ratio of an image is valid.<br>
     * It is considered invalid if the denominator is 0 or if applying the ratio<br>
     * to the image size would make the smaller dimension less than 1. If the<br>
     * sar numerator is 0, it is considered unknown and will return as valid.<br>
     * @param w width of the image<br>
     * @param h height of the image<br>
     * @param sar sample aspect ratio of the image<br>
     * @return 0 if valid, a negative AVERROR code otherwise<br>
     * Original signature : <code>int av_image_check_sar(unsigned int, unsigned int, AVRational)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/imgutils.h:144</i>
     */
    public native int av_image_check_sar(int w, int h, AVRational sar);
    /**
     * Get a seed to use in conjunction with random functions.<br>
     * This function tries to provide a good seed at a best effort bases.<br>
     * Its possible to call this function multiple times if more bits are needed.<br>
     * It can be quite slow, which is why it should only be used as seed for a faster<br>
     * PRNG. The quality of the seed depends on the platform.<br>
     * Original signature : <code>uint32_t av_get_random_seed()</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/random_seed.h:8</i>
     */
    public native int av_get_random_seed();
    /**
     * Allocate an AVRIPEMD context.<br>
     * Original signature : <code>AVRIPEMD* av_ripemd_alloc()</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/ripemd.h:11</i>
     */
    public Pointer<AvutilLibrary.AVRIPEMD > av_ripemd_alloc() {
        return (Pointer)Pointer.pointerToAddress(av_ripemd_alloc$2(), AvutilLibrary.AVRIPEMD.class);
    }
    @Ptr
    @Name("av_ripemd_alloc")
    protected native long av_ripemd_alloc$2();
    /**
     * Initialize RIPEMD hashing.<br>
     * @param context pointer to the function context (of size av_ripemd_size)<br>
     * @param bits    number of bits in digest (128, 160, 256 or 320 bits)<br>
     * @return        zero if initialization succeeded, -1 otherwise<br>
     * Original signature : <code>int av_ripemd_init(AVRIPEMD*, int)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/ripemd.h:19</i>
     */
    public int av_ripemd_init(Pointer<AvutilLibrary.AVRIPEMD > context, int bits) {
        return av_ripemd_init(Pointer.getPeer(context), bits);
    }
    protected native int av_ripemd_init(@Ptr long context, int bits);
    /**
     * Update hash value.<br>
     * @param context hash function context<br>
     * @param data    input data to update hash with<br>
     * @param len     input data length<br>
     * Original signature : <code>void av_ripemd_update(AVRIPEMD*, const uint8_t*, unsigned int)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/ripemd.h:27</i>
     */
    public void av_ripemd_update(Pointer<AvutilLibrary.AVRIPEMD > context, Pointer<Byte > data, int len) {
        av_ripemd_update(Pointer.getPeer(context), Pointer.getPeer(data), len);
    }
    protected native void av_ripemd_update(@Ptr long context, @Ptr long data, int len);
    /**
     * Finish hashing and output digest value.<br>
     * @param context hash function context<br>
     * @param digest  buffer where output digest value is stored<br>
     * Original signature : <code>void av_ripemd_final(AVRIPEMD*, uint8_t*)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/ripemd.h:34</i>
     */
    public void av_ripemd_final(Pointer<AvutilLibrary.AVRIPEMD > context, Pointer<Byte > digest) {
        av_ripemd_final(Pointer.getPeer(context), Pointer.getPeer(digest));
    }
    protected native void av_ripemd_final(@Ptr long context, @Ptr long digest);
    /**
     * Allocate an AVSHA512 context.<br>
     * Original signature : <code>AVSHA512* av_sha512_alloc()</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/sha512.h:11</i>
     */
    public Pointer<AvutilLibrary.AVSHA512 > av_sha512_alloc() {
        return (Pointer)Pointer.pointerToAddress(av_sha512_alloc$2(), AvutilLibrary.AVSHA512.class);
    }
    @Ptr
    @Name("av_sha512_alloc")
    protected native long av_sha512_alloc$2();
    /**
     * Initialize SHA-2 512 hashing.<br>
     * @param context pointer to the function context (of size av_sha512_size)<br>
     * @param bits    number of bits in digest (224, 256, 384 or 512 bits)<br>
     * @return        zero if initialization succeeded, -1 otherwise<br>
     * Original signature : <code>int av_sha512_init(AVSHA512*, int)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/sha512.h:19</i>
     */
    public int av_sha512_init(Pointer<AvutilLibrary.AVSHA512 > context, int bits) {
        return av_sha512_init(Pointer.getPeer(context), bits);
    }
    protected native int av_sha512_init(@Ptr long context, int bits);
    /**
     * Update hash value.<br>
     * @param context hash function context<br>
     * @param data    input data to update hash with<br>
     * @param len     input data length<br>
     * Original signature : <code>void av_sha512_update(AVSHA512*, const uint8_t*, unsigned int)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/sha512.h:27</i>
     */
    public void av_sha512_update(Pointer<AvutilLibrary.AVSHA512 > context, Pointer<Byte > data, int len) {
        av_sha512_update(Pointer.getPeer(context), Pointer.getPeer(data), len);
    }
    protected native void av_sha512_update(@Ptr long context, @Ptr long data, int len);
    /**
     * Finish hashing and output digest value.<br>
     * @param context hash function context<br>
     * @param digest  buffer where output digest value is stored<br>
     * Original signature : <code>void av_sha512_final(AVSHA512*, uint8_t*)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/sha512.h:34</i>
     */
    public void av_sha512_final(Pointer<AvutilLibrary.AVSHA512 > context, Pointer<Byte > digest) {
        av_sha512_final(Pointer.getPeer(context), Pointer.getPeer(digest));
    }
    protected native void av_sha512_final(@Ptr long context, @Ptr long digest);
    /**
     * Initialize an AVFifoBuffer.<br>
     * @param size of FIFO<br>
     * @return AVFifoBuffer or NULL in case of memory allocation failure<br>
     * Original signature : <code>AVFifoBuffer* av_fifo_alloc(unsigned int)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/fifo.h:14</i>
     */
    public Pointer<AVFifoBuffer > av_fifo_alloc(int size) {
        return (Pointer)Pointer.pointerToAddress(av_fifo_alloc$2(size), AVFifoBuffer.class);
    }
    @Ptr
    @Name("av_fifo_alloc")
    protected native long av_fifo_alloc$2(int size);
    /**
     * Initialize an AVFifoBuffer.<br>
     * @param nmemb number of elements<br>
     * @param size  size of the single element<br>
     * @return AVFifoBuffer or NULL in case of memory allocation failure<br>
     * Original signature : <code>AVFifoBuffer* av_fifo_alloc_array(size_t, size_t)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/fifo.h:22</i>
     */
    public Pointer<AVFifoBuffer > av_fifo_alloc_array(@Ptr long nmemb, @Ptr long size) {
        return (Pointer)Pointer.pointerToAddress(av_fifo_alloc_array$2(nmemb, size), AVFifoBuffer.class);
    }
    @Ptr
    @Name("av_fifo_alloc_array")
    protected native long av_fifo_alloc_array$2(@Ptr long nmemb, @Ptr long size);
    /**
     * Free an AVFifoBuffer.<br>
     * @param f AVFifoBuffer to free<br>
     * Original signature : <code>void av_fifo_free(AVFifoBuffer*)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/fifo.h:28</i>
     */
    public void av_fifo_free(Pointer<AVFifoBuffer > f) {
        av_fifo_free(Pointer.getPeer(f));
    }
    protected native void av_fifo_free(@Ptr long f);
    /**
     * Free an AVFifoBuffer and reset pointer to NULL.<br>
     * @param f AVFifoBuffer to free<br>
     * Original signature : <code>void av_fifo_freep(AVFifoBuffer**)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/fifo.h:34</i>
     */
    public void av_fifo_freep(Pointer<Pointer<AVFifoBuffer > > f) {
        av_fifo_freep(Pointer.getPeer(f));
    }
    protected native void av_fifo_freep(@Ptr long f);
    /**
     * Reset the AVFifoBuffer to the state right after av_fifo_alloc, in particular it is emptied.<br>
     * @param f AVFifoBuffer to reset<br>
     * Original signature : <code>void av_fifo_reset(AVFifoBuffer*)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/fifo.h:40</i>
     */
    public void av_fifo_reset(Pointer<AVFifoBuffer > f) {
        av_fifo_reset(Pointer.getPeer(f));
    }
    protected native void av_fifo_reset(@Ptr long f);
    /**
     * Return the amount of data in bytes in the AVFifoBuffer, that is the<br>
     * amount of data you can read from it.<br>
     * @param f AVFifoBuffer to read from<br>
     * @return size<br>
     * Original signature : <code>int av_fifo_size(const AVFifoBuffer*)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/fifo.h:48</i>
     */
    public int av_fifo_size(Pointer<AVFifoBuffer > f) {
        return av_fifo_size(Pointer.getPeer(f));
    }
    protected native int av_fifo_size(@Ptr long f);
    /**
     * Return the amount of space in bytes in the AVFifoBuffer, that is the<br>
     * amount of data you can write into it.<br>
     * @param f AVFifoBuffer to write into<br>
     * @return size<br>
     * Original signature : <code>int av_fifo_space(const AVFifoBuffer*)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/fifo.h:56</i>
     */
    public int av_fifo_space(Pointer<AVFifoBuffer > f) {
        return av_fifo_space(Pointer.getPeer(f));
    }
    protected native int av_fifo_space(@Ptr long f);
    /**
     * Feed data at specific position from an AVFifoBuffer to a user-supplied callback.<br>
     * Similar as av_fifo_gereric_read but without discarding data.<br>
     * @param f AVFifoBuffer to read from<br>
     * @param offset offset from current read position<br>
     * @param buf_size number of bytes to read<br>
     * @param func generic read function<br>
     * @param dest data destination<br>
     * Original signature : <code>int av_fifo_generic_peek_at(AVFifoBuffer*, void*, int, int, av_fifo_generic_peek_at_func_callback*)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/fifo.h:67</i>
     */
    public int av_fifo_generic_peek_at(Pointer<AVFifoBuffer > f, Pointer<? > dest, int offset, int buf_size, Pointer<AvutilLibrary.av_fifo_generic_peek_at_func_callback > func) {
        return av_fifo_generic_peek_at(Pointer.getPeer(f), Pointer.getPeer(dest), offset, buf_size, Pointer.getPeer(func));
    }
    protected native int av_fifo_generic_peek_at(@Ptr long f, @Ptr long dest, int offset, int buf_size, @Ptr long func);
    /**
     * Feed data from an AVFifoBuffer to a user-supplied callback.<br>
     * Similar as av_fifo_gereric_read but without discarding data.<br>
     * @param f AVFifoBuffer to read from<br>
     * @param buf_size number of bytes to read<br>
     * @param func generic read function<br>
     * @param dest data destination<br>
     * Original signature : <code>int av_fifo_generic_peek(AVFifoBuffer*, void*, int, av_fifo_generic_peek_func_callback*)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/fifo.h:77</i>
     */
    public int av_fifo_generic_peek(Pointer<AVFifoBuffer > f, Pointer<? > dest, int buf_size, Pointer<AvutilLibrary.av_fifo_generic_peek_func_callback > func) {
        return av_fifo_generic_peek(Pointer.getPeer(f), Pointer.getPeer(dest), buf_size, Pointer.getPeer(func));
    }
    protected native int av_fifo_generic_peek(@Ptr long f, @Ptr long dest, int buf_size, @Ptr long func);
    /**
     * Feed data from an AVFifoBuffer to a user-supplied callback.<br>
     * @param f AVFifoBuffer to read from<br>
     * @param buf_size number of bytes to read<br>
     * @param func generic read function<br>
     * @param dest data destination<br>
     * Original signature : <code>int av_fifo_generic_read(AVFifoBuffer*, void*, int, av_fifo_generic_read_func_callback*)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/fifo.h:86</i>
     */
    public int av_fifo_generic_read(Pointer<AVFifoBuffer > f, Pointer<? > dest, int buf_size, Pointer<AvutilLibrary.av_fifo_generic_read_func_callback > func) {
        return av_fifo_generic_read(Pointer.getPeer(f), Pointer.getPeer(dest), buf_size, Pointer.getPeer(func));
    }
    protected native int av_fifo_generic_read(@Ptr long f, @Ptr long dest, int buf_size, @Ptr long func);
    /**
     * Feed data from a user-supplied callback to an AVFifoBuffer.<br>
     * @param f AVFifoBuffer to write to<br>
     * @param src data source; non-const since it may be used as a<br>
     * modifiable context by the function defined in func<br>
     * @param size number of bytes to write<br>
     * @param func generic write function; the first parameter is src,<br>
     * the second is dest_buf, the third is dest_buf_size.<br>
     * func must return the number of bytes written to dest_buf, or <= 0 to<br>
     * indicate no more data available to write.<br>
     * If func is NULL, src is interpreted as a simple byte array for source data.<br>
     * @return the number of bytes written to the FIFO<br>
     * Original signature : <code>int av_fifo_generic_write(AVFifoBuffer*, void*, int, av_fifo_generic_write_func_callback*)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/fifo.h:101</i>
     */
    public int av_fifo_generic_write(Pointer<AVFifoBuffer > f, Pointer<? > src, int size, Pointer<AvutilLibrary.av_fifo_generic_write_func_callback > func) {
        return av_fifo_generic_write(Pointer.getPeer(f), Pointer.getPeer(src), size, Pointer.getPeer(func));
    }
    protected native int av_fifo_generic_write(@Ptr long f, @Ptr long src, int size, @Ptr long func);
    /**
     * Resize an AVFifoBuffer.<br>
     * In case of reallocation failure, the old FIFO is kept unchanged.<br>
     * @param f AVFifoBuffer to resize<br>
     * @param size new AVFifoBuffer size in bytes<br>
     * @return <0 for failure, >=0 otherwise<br>
     * Original signature : <code>int av_fifo_realloc2(AVFifoBuffer*, unsigned int)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/fifo.h:110</i>
     */
    public int av_fifo_realloc2(Pointer<AVFifoBuffer > f, int size) {
        return av_fifo_realloc2(Pointer.getPeer(f), size);
    }
    protected native int av_fifo_realloc2(@Ptr long f, int size);
    /**
     * Enlarge an AVFifoBuffer.<br>
     * In case of reallocation failure, the old FIFO is kept unchanged.<br>
     * The new fifo size may be larger than the requested size.<br>
     * @param f AVFifoBuffer to resize<br>
     * @param additional_space the amount of space in bytes to allocate in addition to av_fifo_size()<br>
     * @return <0 for failure, >=0 otherwise<br>
     * Original signature : <code>int av_fifo_grow(AVFifoBuffer*, unsigned int)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/fifo.h:120</i>
     */
    public int av_fifo_grow(Pointer<AVFifoBuffer > f, int additional_space) {
        return av_fifo_grow(Pointer.getPeer(f), additional_space);
    }
    protected native int av_fifo_grow(@Ptr long f, int additional_space);
    /**
     * Read and discard the specified amount of data from an AVFifoBuffer.<br>
     * @param f AVFifoBuffer to read from<br>
     * @param size amount of data to read in bytes<br>
     * Original signature : <code>void av_fifo_drain(AVFifoBuffer*, int)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/fifo.h:127</i>
     */
    public void av_fifo_drain(Pointer<AVFifoBuffer > f, int size) {
        av_fifo_drain(Pointer.getPeer(f), size);
    }
    protected native void av_fifo_drain(@Ptr long f, int size);
    /**
     * Free an AVAudioFifo.<br>
     * @param af  AVAudioFifo to free<br>
     * Original signature : <code>void av_audio_fifo_free(AVAudioFifo*)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/audio_fifo.h:12</i>
     */
    public void av_audio_fifo_free(Pointer<AvutilLibrary.AVAudioFifo > af) {
        av_audio_fifo_free(Pointer.getPeer(af));
    }
    protected native void av_audio_fifo_free(@Ptr long af);
    /**
     * Allocate an AVAudioFifo.<br>
     * @param sample_fmt  sample format<br>
     * @param channels    number of channels<br>
     * @param nb_samples  initial allocation size, in samples<br>
     * @return            newly allocated AVAudioFifo, or NULL on error<br>
     * Original signature : <code>AVAudioFifo* av_audio_fifo_alloc(AVSampleFormat, int, int)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/audio_fifo.h:21</i>
     */
    public Pointer<AvutilLibrary.AVAudioFifo > av_audio_fifo_alloc(IntValuedEnum<AvutilLibrary.AVSampleFormat > sample_fmt, int channels, int nb_samples) {
        return (Pointer)Pointer.pointerToAddress(av_audio_fifo_alloc((int)sample_fmt.value(), channels, nb_samples), AvutilLibrary.AVAudioFifo.class);
    }
    @Ptr
    protected native long av_audio_fifo_alloc(int sample_fmt, int channels, int nb_samples);
    /**
     * Reallocate an AVAudioFifo.<br>
     * @param af          AVAudioFifo to reallocate<br>
     * @param nb_samples  new allocation size, in samples<br>
     * @return            0 if OK, or negative AVERROR code on failure<br>
     * Original signature : <code>int av_audio_fifo_realloc(AVAudioFifo*, int)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/audio_fifo.h:29</i>
     */
    public int av_audio_fifo_realloc(Pointer<AvutilLibrary.AVAudioFifo > af, int nb_samples) {
        return av_audio_fifo_realloc(Pointer.getPeer(af), nb_samples);
    }
    protected native int av_audio_fifo_realloc(@Ptr long af, int nb_samples);
    /**
     * Write data to an AVAudioFifo.<br>
     * The AVAudioFifo will be reallocated automatically if the available space<br>
     * is less than nb_samples.<br>
     * @see enum AVSampleFormat<br>
     * The documentation for AVSampleFormat describes the data layout.<br>
     * @param af          AVAudioFifo to write to<br>
     * @param data        audio data plane pointers<br>
     * @param nb_samples  number of samples to write<br>
     * @return            number of samples actually written, or negative AVERROR<br>
     *                    code on failure. If successful, the number of samples<br>
     *                    actually written will always be nb_samples.<br>
     * Original signature : <code>int av_audio_fifo_write(AVAudioFifo*, void**, int)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/audio_fifo.h:44</i>
     */
    public int av_audio_fifo_write(Pointer<AvutilLibrary.AVAudioFifo > af, Pointer<Pointer<? > > data, int nb_samples) {
        return av_audio_fifo_write(Pointer.getPeer(af), Pointer.getPeer(data), nb_samples);
    }
    protected native int av_audio_fifo_write(@Ptr long af, @Ptr long data, int nb_samples);
    /**
     * Peek data from an AVAudioFifo.<br>
     * @see enum AVSampleFormat<br>
     * The documentation for AVSampleFormat describes the data layout.<br>
     * @param af          AVAudioFifo to read from<br>
     * @param data        audio data plane pointers<br>
     * @param nb_samples  number of samples to peek<br>
     * @return            number of samples actually peek, or negative AVERROR code<br>
     *                    on failure. The number of samples actually peek will not<br>
     *                    be greater than nb_samples, and will only be less than<br>
     *                    nb_samples if av_audio_fifo_size is less than nb_samples.<br>
     * Original signature : <code>int av_audio_fifo_peek(AVAudioFifo*, void**, int)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/audio_fifo.h:58</i>
     */
    public int av_audio_fifo_peek(Pointer<AvutilLibrary.AVAudioFifo > af, Pointer<Pointer<? > > data, int nb_samples) {
        return av_audio_fifo_peek(Pointer.getPeer(af), Pointer.getPeer(data), nb_samples);
    }
    protected native int av_audio_fifo_peek(@Ptr long af, @Ptr long data, int nb_samples);
    /**
     * Read data from an AVAudioFifo.<br>
     * @see enum AVSampleFormat<br>
     * The documentation for AVSampleFormat describes the data layout.<br>
     * @param af          AVAudioFifo to read from<br>
     * @param data        audio data plane pointers<br>
     * @param nb_samples  number of samples to read<br>
     * @return            number of samples actually read, or negative AVERROR code<br>
     *                    on failure. The number of samples actually read will not<br>
     *                    be greater than nb_samples, and will only be less than<br>
     *                    nb_samples if av_audio_fifo_size is less than nb_samples.<br>
     * Original signature : <code>int av_audio_fifo_read(AVAudioFifo*, void**, int)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/audio_fifo.h:72</i>
     */
    public int av_audio_fifo_read(Pointer<AvutilLibrary.AVAudioFifo > af, Pointer<Pointer<? > > data, int nb_samples) {
        return av_audio_fifo_read(Pointer.getPeer(af), Pointer.getPeer(data), nb_samples);
    }
    protected native int av_audio_fifo_read(@Ptr long af, @Ptr long data, int nb_samples);
    /**
     * Drain data from an AVAudioFifo.<br>
     * Removes the data without reading it.<br>
     * @param af          AVAudioFifo to drain<br>
     * @param nb_samples  number of samples to drain<br>
     * @return            0 if OK, or negative AVERROR code on failure<br>
     * Original signature : <code>int av_audio_fifo_drain(AVAudioFifo*, int)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/audio_fifo.h:81</i>
     */
    public int av_audio_fifo_drain(Pointer<AvutilLibrary.AVAudioFifo > af, int nb_samples) {
        return av_audio_fifo_drain(Pointer.getPeer(af), nb_samples);
    }
    protected native int av_audio_fifo_drain(@Ptr long af, int nb_samples);
    /**
     * Reset the AVAudioFifo buffer.<br>
     * This empties all data in the buffer.<br>
     * @param af  AVAudioFifo to reset<br>
     * Original signature : <code>void av_audio_fifo_reset(AVAudioFifo*)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/audio_fifo.h:88</i>
     */
    public void av_audio_fifo_reset(Pointer<AvutilLibrary.AVAudioFifo > af) {
        av_audio_fifo_reset(Pointer.getPeer(af));
    }
    protected native void av_audio_fifo_reset(@Ptr long af);
    /**
     * Get the current number of samples in the AVAudioFifo available for reading.<br>
     * @param af  the AVAudioFifo to query<br>
     * @return    number of samples available for reading<br>
     * Original signature : <code>int av_audio_fifo_size(AVAudioFifo*)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/audio_fifo.h:95</i>
     */
    public int av_audio_fifo_size(Pointer<AvutilLibrary.AVAudioFifo > af) {
        return av_audio_fifo_size(Pointer.getPeer(af));
    }
    protected native int av_audio_fifo_size(@Ptr long af);
    /**
     * Get the current number of samples in the AVAudioFifo available for writing.<br>
     * @param af  the AVAudioFifo to query<br>
     * @return    number of samples available for writing<br>
     * Original signature : <code>int av_audio_fifo_space(AVAudioFifo*)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/audio_fifo.h:102</i>
     */
    public int av_audio_fifo_space(Pointer<AvutilLibrary.AVAudioFifo > af) {
        return av_audio_fifo_space(Pointer.getPeer(af));
    }
    protected native int av_audio_fifo_space(@Ptr long af);
    /**
     * Decode a base64-encoded string.<br>
     * @param out      buffer for decoded data<br>
     * @param in       null-terminated input string<br>
     * @param out_size size in bytes of the out buffer, must be at<br>
     *                 least 3/4 of the length of in<br>
     * @return         number of bytes written, or a negative value in case of<br>
     *                 invalid input<br>
     * Original signature : <code>int av_base64_decode(uint8_t*, const char*, int)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/base64.h:10</i>
     */
    public int av_base64_decode(Pointer<Byte > out, Pointer<Byte > in, int out_size) {
        return av_base64_decode(Pointer.getPeer(out), Pointer.getPeer(in), out_size);
    }
    protected native int av_base64_decode(@Ptr long out, @Ptr long in, int out_size);
    /**
     * Encode data to base64 and null-terminate.<br>
     * @param out      buffer for encoded data<br>
     * @param out_size size in bytes of the out buffer (including the<br>
     *                 null terminator), must be at least AV_BASE64_SIZE(in_size)<br>
     * @param in       input buffer containing the data to encode<br>
     * @param in_size  size in bytes of the in buffer<br>
     * @return         out or NULL in case of error<br>
     * Original signature : <code>char* av_base64_encode(char*, int, const uint8_t*, int)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/base64.h:21</i>
     */
    public Pointer<Byte > av_base64_encode(Pointer<Byte > out, int out_size, Pointer<Byte > in, int in_size) {
        return (Pointer)Pointer.pointerToAddress(av_base64_encode(Pointer.getPeer(out), out_size, Pointer.getPeer(in), in_size), Byte.class);
    }
    @Ptr
    protected native long av_base64_encode(@Ptr long out, int out_size, @Ptr long in, int in_size);
    /**
     * Initialize a CRC table.<br>
     * @param ctx must be an array of size sizeof(AVCRC)*257 or sizeof(AVCRC)*1024<br>
     * @param le If 1, the lowest bit represents the coefficient for the highest<br>
     *           exponent of the corresponding polynomial (both for poly and<br>
     *           actual CRC).<br>
     *           If 0, you must swap the CRC parameter and the result of av_crc<br>
     *           if you need the standard representation (can be simplified in<br>
     *           most cases to e.g. bswap16):<br>
     *           av_bswap32(crc << (32-bits))<br>
     * @param bits number of bits for the CRC<br>
     * @param poly generator polynomial without the x**bits coefficient, in the<br>
     *             representation as specified by le<br>
     * @param ctx_size size of ctx in bytes<br>
     * @return <0 on failure<br>
     * Original signature : <code>int av_crc_init(AVCRC*, int, int, uint32_t, int)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/crc.h:33</i>
     */
    public int av_crc_init(Pointer<Integer > ctx, int le, int bits, int poly, int ctx_size) {
        return av_crc_init(Pointer.getPeer(ctx), le, bits, poly, ctx_size);
    }
    protected native int av_crc_init(@Ptr long ctx, int le, int bits, int poly, int ctx_size);
    /**
     * Get an initialized standard CRC table.<br>
     * @param crc_id ID of a standard CRC<br>
     * @return a pointer to the CRC table or NULL on failure<br>
     * Original signature : <code>AVCRC* av_crc_get_table(AVCRCId)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/crc.h:40</i>
     */
    public Pointer<Integer > av_crc_get_table(IntValuedEnum<AvutilLibrary.AVCRCId > crc_id) {
        return (Pointer)Pointer.pointerToAddress(av_crc_get_table((int)crc_id.value()), Integer.class);
    }
    @Ptr
    protected native long av_crc_get_table(int crc_id);
    /**
     * Calculate the CRC of a block.<br>
     * @param crc CRC of previous blocks if any or initial value for CRC<br>
     * @return CRC updated with the data from the given block<br>
     * @see av_crc_init() "le" parameter<br>
     * Original signature : <code>uint32_t av_crc(const AVCRC*, uint32_t, const uint8_t*, size_t)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/crc.h:48</i>
     */
    public int av_crc(Pointer<Integer > ctx, int crc, Pointer<Byte > buffer, @Ptr long length) {
        return av_crc(Pointer.getPeer(ctx), crc, Pointer.getPeer(buffer), length);
    }
    protected native int av_crc(@Ptr long ctx, int crc, @Ptr long buffer, @Ptr long length);
    /**
     * Allocate an AVMD5 context.<br>
     * Original signature : <code>AVMD5* av_md5_alloc()</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/md5.h:11</i>
     */
    public Pointer<AvutilLibrary.AVMD5 > av_md5_alloc() {
        return (Pointer)Pointer.pointerToAddress(av_md5_alloc$2(), AvutilLibrary.AVMD5.class);
    }
    @Ptr
    @Name("av_md5_alloc")
    protected native long av_md5_alloc$2();
    /**
     * Initialize MD5 hashing.<br>
     * @param ctx pointer to the function context (of size av_md5_size)<br>
     * Original signature : <code>void av_md5_init(AVMD5*)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/md5.h:17</i>
     */
    public void av_md5_init(Pointer<AvutilLibrary.AVMD5 > ctx) {
        av_md5_init(Pointer.getPeer(ctx));
    }
    protected native void av_md5_init(@Ptr long ctx);
    /**
     * Update hash value.<br>
     * @param ctx hash function context<br>
     * @param src input data to update hash with<br>
     * @param len input data length<br>
     * Original signature : <code>void av_md5_update(AVMD5*, const uint8_t*, int)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/md5.h:25</i>
     */
    public void av_md5_update(Pointer<AvutilLibrary.AVMD5 > ctx, Pointer<Byte > src, int len) {
        av_md5_update(Pointer.getPeer(ctx), Pointer.getPeer(src), len);
    }
    protected native void av_md5_update(@Ptr long ctx, @Ptr long src, int len);
    /**
     * Finish hashing and output digest value.<br>
     * @param ctx hash function context<br>
     * @param dst buffer where output digest value is stored<br>
     * Original signature : <code>void av_md5_final(AVMD5*, uint8_t*)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/md5.h:32</i>
     */
    public void av_md5_final(Pointer<AvutilLibrary.AVMD5 > ctx, Pointer<Byte > dst) {
        av_md5_final(Pointer.getPeer(ctx), Pointer.getPeer(dst));
    }
    protected native void av_md5_final(@Ptr long ctx, @Ptr long dst);
    /**
     * Hash an array of data.<br>
     * @param dst The output buffer to write the digest into<br>
     * @param src The data to hash<br>
     * @param len The length of the data, in bytes<br>
     * Original signature : <code>void av_md5_sum(uint8_t*, const uint8_t*, const int)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/md5.h:40</i>
     */
    public void av_md5_sum(Pointer<Byte > dst, Pointer<Byte > src, int len) {
        av_md5_sum(Pointer.getPeer(dst), Pointer.getPeer(src), len);
    }
    protected native void av_md5_sum(@Ptr long dst, @Ptr long src, int len);
    /**
     * Allocate an AVCAMELLIA context<br>
     * To free the struct: av_free(ptr)<br>
     * Original signature : <code>AVCAMELLIA* av_camellia_alloc()</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/camellia.h:14</i>
     */
    public Pointer<AvutilLibrary.AVCAMELLIA > av_camellia_alloc() {
        return (Pointer)Pointer.pointerToAddress(av_camellia_alloc$2(), AvutilLibrary.AVCAMELLIA.class);
    }
    @Ptr
    @Name("av_camellia_alloc")
    protected native long av_camellia_alloc$2();
    /**
     * Initialize an AVCAMELLIA context.<br>
     * @param ctx an AVCAMELLIA context<br>
     * @param key a key of 16, 24, 32 bytes used for encryption/decryption<br>
     * @param key_bits number of keybits: possible are 128, 192, 256<br>
     * Original signature : <code>int av_camellia_init(AVCAMELLIA*, const uint8_t*, int)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/camellia.h:22</i>
     */
    public int av_camellia_init(Pointer<AvutilLibrary.AVCAMELLIA > ctx, Pointer<Byte > key, int key_bits) {
        return av_camellia_init(Pointer.getPeer(ctx), Pointer.getPeer(key), key_bits);
    }
    protected native int av_camellia_init(@Ptr long ctx, @Ptr long key, int key_bits);
    /**
     * Encrypt or decrypt a buffer using a previously initialized context<br>
     * @param ctx an AVCAMELLIA context<br>
     * @param dst destination array, can be equal to src<br>
     * @param src source array, can be equal to dst<br>
     * @param count number of 16 byte blocks<br>
     * @paran iv initialization vector for CBC mode, NULL for ECB mode<br>
     * @param decrypt 0 for encryption, 1 for decryption<br>
     * Original signature : <code>void av_camellia_crypt(AVCAMELLIA*, uint8_t*, const uint8_t*, int, uint8_t*, int)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/camellia.h:33</i>
     */
    public void av_camellia_crypt(Pointer<AvutilLibrary.AVCAMELLIA > ctx, Pointer<Byte > dst, Pointer<Byte > src, int count, Pointer<Byte > iv, int decrypt) {
        av_camellia_crypt(Pointer.getPeer(ctx), Pointer.getPeer(dst), Pointer.getPeer(src), count, Pointer.getPeer(iv), decrypt);
    }
    protected native void av_camellia_crypt(@Ptr long ctx, @Ptr long dst, @Ptr long src, int count, @Ptr long iv, int decrypt);
    /**
     * Allocate an AVSHA context.<br>
     * Original signature : <code>AVSHA* av_sha_alloc()</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/sha.h:11</i>
     */
    public Pointer<AvutilLibrary.AVSHA > av_sha_alloc() {
        return (Pointer)Pointer.pointerToAddress(av_sha_alloc$2(), AvutilLibrary.AVSHA.class);
    }
    @Ptr
    @Name("av_sha_alloc")
    protected native long av_sha_alloc$2();
    /**
     * Initialize SHA-1 or SHA-2 hashing.<br>
     * @param context pointer to the function context (of size av_sha_size)<br>
     * @param bits    number of bits in digest (SHA-1 - 160 bits, SHA-2 224 or 256 bits)<br>
     * @return        zero if initialization succeeded, -1 otherwise<br>
     * Original signature : <code>int av_sha_init(AVSHA*, int)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/sha.h:19</i>
     */
    public int av_sha_init(Pointer<AvutilLibrary.AVSHA > context, int bits) {
        return av_sha_init(Pointer.getPeer(context), bits);
    }
    protected native int av_sha_init(@Ptr long context, int bits);
    /**
     * Update hash value.<br>
     * @param context hash function context<br>
     * @param data    input data to update hash with<br>
     * @param len     input data length<br>
     * Original signature : <code>void av_sha_update(AVSHA*, const uint8_t*, unsigned int)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/sha.h:27</i>
     */
    public void av_sha_update(Pointer<AvutilLibrary.AVSHA > context, Pointer<Byte > data, int len) {
        av_sha_update(Pointer.getPeer(context), Pointer.getPeer(data), len);
    }
    protected native void av_sha_update(@Ptr long context, @Ptr long data, int len);
    /**
     * Finish hashing and output digest value.<br>
     * @param context hash function context<br>
     * @param digest  buffer where output digest value is stored<br>
     * Original signature : <code>void av_sha_final(AVSHA*, uint8_t*)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/sha.h:34</i>
     */
    public void av_sha_final(Pointer<AvutilLibrary.AVSHA > context, Pointer<Byte > digest) {
        av_sha_final(Pointer.getPeer(context), Pointer.getPeer(digest));
    }
    protected native void av_sha_final(@Ptr long context, @Ptr long digest);
    /**
     * Read the file with name filename, and put its content in a newly<br>
     * allocated buffer or map it with mmap() when available.<br>
     * In case of success set *bufptr to the read or mmapped buffer, and<br>
     * *size to the size in bytes of the buffer in *bufptr.<br>
     * The returned buffer must be released with av_file_unmap().<br>
     * @param log_offset loglevel offset used for logging<br>
     * @param log_ctx context used for logging<br>
     * @return a non negative number in case of success, a negative value<br>
     * corresponding to an AVERROR error code in case of failure<br>
     * Original signature : <code>int av_file_map(const char*, uint8_t**, size_t*, int, void*)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/file.h:12</i>
     */
    public int av_file_map(Pointer<Byte > filename, Pointer<Pointer<Byte > > bufptr, Pointer<SizeT > size, int log_offset, Pointer<? > log_ctx) {
        return av_file_map(Pointer.getPeer(filename), Pointer.getPeer(bufptr), Pointer.getPeer(size), log_offset, Pointer.getPeer(log_ctx));
    }
    protected native int av_file_map(@Ptr long filename, @Ptr long bufptr, @Ptr long size, int log_offset, @Ptr long log_ctx);
    /**
     * Unmap or free the buffer bufptr created by av_file_map().<br>
     * @param size size in bytes of bufptr, must be the same as returned<br>
     * by av_file_map()<br>
     * Original signature : <code>void av_file_unmap(uint8_t*, size_t)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/file.h:19</i>
     */
    public void av_file_unmap(Pointer<Byte > bufptr, @Ptr long size) {
        av_file_unmap(Pointer.getPeer(bufptr), size);
    }
    protected native void av_file_unmap(@Ptr long bufptr, @Ptr long size);
    /**
     * Wrapper to work around the lack of mkstemp() on mingw.<br>
     * Also, tries to create file in /tmp first, if possible.<br>
     * *prefix can be a character constant; *filename will be allocated internally.<br>
     * @return file descriptor of opened file (or negative value corresponding to an<br>
     * AVERROR code on error)<br>
     * and opened file name in **filename.<br>
     * @note On very old libcs it is necessary to set a secure umask before<br>
     *       calling this, av_tempfile() can't call umask itself as it is used in<br>
     *       libraries and could interfere with the calling application.<br>
     * Original signature : <code>int av_tempfile(const char*, char**, int, void*)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/file.h:32</i>
     */
    public int av_tempfile(Pointer<Byte > prefix, Pointer<Pointer<Byte > > filename, int log_offset, Pointer<? > log_ctx) {
        return av_tempfile(Pointer.getPeer(prefix), Pointer.getPeer(filename), log_offset, Pointer.getPeer(log_ctx));
    }
    protected native int av_tempfile(@Ptr long prefix, @Ptr long filename, int log_offset, @Ptr long log_ctx);
    /**
     * Allocate an AVTWOFISH context<br>
     * To free the struct: av_free(ptr)<br>
     * Original signature : <code>AVTWOFISH* av_twofish_alloc()</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/twofish.h:14</i>
     */
    public Pointer<AvutilLibrary.AVTWOFISH > av_twofish_alloc() {
        return (Pointer)Pointer.pointerToAddress(av_twofish_alloc$2(), AvutilLibrary.AVTWOFISH.class);
    }
    @Ptr
    @Name("av_twofish_alloc")
    protected native long av_twofish_alloc$2();
    /**
     * Initialize an AVTWOFISH context.<br>
     * @param ctx an AVTWOFISH context<br>
     * @param key a key of size ranging from 1 to 32 bytes used for encryption/decryption<br>
     * @param key_bits number of keybits: 128, 192, 256 If less than the required, padded with zeroes to nearest valid value; return value is 0 if key_bits is 128/192/256, -1 if less than 0, 1 otherwise<br>
     * Original signature : <code>int av_twofish_init(AVTWOFISH*, const uint8_t*, int)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/twofish.h:22</i>
     */
    public int av_twofish_init(Pointer<AvutilLibrary.AVTWOFISH > ctx, Pointer<Byte > key, int key_bits) {
        return av_twofish_init(Pointer.getPeer(ctx), Pointer.getPeer(key), key_bits);
    }
    protected native int av_twofish_init(@Ptr long ctx, @Ptr long key, int key_bits);
    /**
     * Encrypt or decrypt a buffer using a previously initialized context<br>
     * @param ctx an AVTWOFISH context<br>
     * @param dst destination array, can be equal to src<br>
     * @param src source array, can be equal to dst<br>
     * @param count number of 16 byte blocks<br>
     * @paran iv initialization vector for CBC mode, NULL for ECB mode<br>
     * @param decrypt 0 for encryption, 1 for decryption<br>
     * Original signature : <code>void av_twofish_crypt(AVTWOFISH*, uint8_t*, const uint8_t*, int, uint8_t*, int)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/twofish.h:33</i>
     */
    public void av_twofish_crypt(Pointer<AvutilLibrary.AVTWOFISH > ctx, Pointer<Byte > dst, Pointer<Byte > src, int count, Pointer<Byte > iv, int decrypt) {
        av_twofish_crypt(Pointer.getPeer(ctx), Pointer.getPeer(dst), Pointer.getPeer(src), count, Pointer.getPeer(iv), decrypt);
    }
    protected native void av_twofish_crypt(@Ptr long ctx, @Ptr long dst, @Ptr long src, int count, @Ptr long iv, int decrypt);
    /**
     * Parse str and store the parsed ratio in q.<br>
     * Note that a ratio with infinite (1/0) or negative value is<br>
     * considered valid, so you should check on the returned value if you<br>
     * want to exclude those values.<br>
     * The undefined value can be expressed using the "0:0" string.<br>
     * @param[in,out] q pointer to the AVRational which will contain the ratio<br>
     * @param[in] str the string to parse: it has to be a string in the format<br>
     * num:den, a float number or an expression<br>
     * @param[in] max the maximum allowed numerator and denominator<br>
     * @param[in] log_offset log level offset which is applied to the log<br>
     * level of log_ctx<br>
     * @param[in] log_ctx parent logging context<br>
     * @return >= 0 on success, a negative error code otherwise<br>
     * Original signature : <code>int av_parse_ratio(AVRational*, const char*, int, int, void*)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/parseutils.h:16</i>
     */
    public int av_parse_ratio(Pointer<AVRational > q, Pointer<Byte > str, int max, int log_offset, Pointer<? > log_ctx) {
        return av_parse_ratio(Pointer.getPeer(q), Pointer.getPeer(str), max, log_offset, Pointer.getPeer(log_ctx));
    }
    protected native int av_parse_ratio(@Ptr long q, @Ptr long str, int max, int log_offset, @Ptr long log_ctx);
    /**
     * Parse str and put in width_ptr and height_ptr the detected values.<br>
     * @param[in,out] width_ptr pointer to the variable which will contain the detected<br>
     * width value<br>
     * @param[in,out] height_ptr pointer to the variable which will contain the detected<br>
     * height value<br>
     * @param[in] str the string to parse: it has to be a string in the format<br>
     * width x height or a valid video size abbreviation.<br>
     * @return >= 0 on success, a negative error code otherwise<br>
     * Original signature : <code>int av_parse_video_size(int*, int*, const char*)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/parseutils.h:28</i>
     */
    public int av_parse_video_size(Pointer<Integer > width_ptr, Pointer<Integer > height_ptr, Pointer<Byte > str) {
        return av_parse_video_size(Pointer.getPeer(width_ptr), Pointer.getPeer(height_ptr), Pointer.getPeer(str));
    }
    protected native int av_parse_video_size(@Ptr long width_ptr, @Ptr long height_ptr, @Ptr long str);
    /**
     * Parse str and store the detected values in *rate.<br>
     * @param[in,out] rate pointer to the AVRational which will contain the detected<br>
     * frame rate<br>
     * @param[in] str the string to parse: it has to be a string in the format<br>
     * rate_num / rate_den, a float number or a valid video rate abbreviation<br>
     * @return >= 0 on success, a negative error code otherwise<br>
     * Original signature : <code>int av_parse_video_rate(AVRational*, const char*)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/parseutils.h:38</i>
     */
    public int av_parse_video_rate(Pointer<AVRational > rate, Pointer<Byte > str) {
        return av_parse_video_rate(Pointer.getPeer(rate), Pointer.getPeer(str));
    }
    protected native int av_parse_video_rate(@Ptr long rate, @Ptr long str);
    /**
     * Put the RGBA values that correspond to color_string in rgba_color.<br>
     * @param color_string a string specifying a color. It can be the name of<br>
     * a color (case insensitive match) or a [0x|#]RRGGBB[AA] sequence,<br>
     * possibly followed by "@" and a string representing the alpha<br>
     * component.<br>
     * The alpha component may be a string composed by "0x" followed by an<br>
     * hexadecimal number or a decimal number between 0.0 and 1.0, which<br>
     * represents the opacity value (0x00/0.0 means completely transparent,<br>
     * 0xff/1.0 completely opaque).<br>
     * If the alpha component is not specified then 0xff is assumed.<br>
     * The string "random" will result in a random color.<br>
     * @param slen length of the initial part of color_string containing the<br>
     * color. It can be set to -1 if color_string is a null terminated string<br>
     * containing nothing else than the color.<br>
     * @return >= 0 in case of success, a negative value in case of<br>
     * failure (for example if color_string cannot be parsed).<br>
     * Original signature : <code>int av_parse_color(uint8_t*, const char*, int, void*)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/parseutils.h:58</i>
     */
    public int av_parse_color(Pointer<Byte > rgba_color, Pointer<Byte > color_string, int slen, Pointer<? > log_ctx) {
        return av_parse_color(Pointer.getPeer(rgba_color), Pointer.getPeer(color_string), slen, Pointer.getPeer(log_ctx));
    }
    protected native int av_parse_color(@Ptr long rgba_color, @Ptr long color_string, int slen, @Ptr long log_ctx);
    /**
     * Get the name of a color from the internal table of hard-coded named<br>
     * colors.<br>
     * This function is meant to enumerate the color names recognized by<br>
     * av_parse_color().<br>
     * @param color_idx index of the requested color, starting from 0<br>
     * @param rgbp      if not NULL, will point to a 3-elements array with the color value in RGB<br>
     * @return the color name string or NULL if color_idx is not in the array<br>
     * Original signature : <code>char* av_get_known_color_name(int, const uint8_t**)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/parseutils.h:69</i>
     */
    public Pointer<Byte > av_get_known_color_name(int color_idx, Pointer<Pointer<Byte > > rgb) {
        return (Pointer)Pointer.pointerToAddress(av_get_known_color_name(color_idx, Pointer.getPeer(rgb)), Byte.class);
    }
    @Ptr
    protected native long av_get_known_color_name(int color_idx, @Ptr long rgb);
    /**
     * Parse timestr and return in *time a corresponding number of<br>
     * microseconds.<br>
     * @param timeval puts here the number of microseconds corresponding<br>
     * to the string in timestr. If the string represents a duration, it<br>
     * is the number of microseconds contained in the time interval.  If<br>
     * the string is a date, is the number of microseconds since 1st of<br>
     * January, 1970 up to the time of the parsed date.  If timestr cannot<br>
     * be successfully parsed, set *time to INT64_MIN.<br>
     * @param timestr a string representing a date or a duration.<br>
     * - If a date the syntax is:<br>
     * @code<br>
     * [{YYYY-MM-DD|YYYYMMDD}[T|t| ]]{{HH:MM:SS[.m...]]]}|{HHMMSS[.m...]]]}}[Z]<br>
     * now<br>
     * @endcode<br>
     * If the value is "now" it takes the current time.<br>
     * Time is local time unless Z is appended, in which case it is<br>
     * interpreted as UTC.<br>
     * If the year-month-day part is not specified it takes the current<br>
     * year-month-day.<br>
     * - If a duration the syntax is:<br>
     * @code<br>
     * [-][HH:]MM:SS[.m...]<br>
     * [-]S+[.m...]<br>
     * @endcode<br>
     * @param duration flag which tells how to interpret timestr, if not<br>
     * zero timestr is interpreted as a duration, otherwise as a date<br>
     * @return >= 0 in case of success, a negative value corresponding to an<br>
     * AVERROR code otherwise<br>
     * Original signature : <code>int av_parse_time(int64_t*, const char*, int)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/parseutils.h:101</i>
     */
    public int av_parse_time(Pointer<Long > timeval, Pointer<Byte > timestr, int duration) {
        return av_parse_time(Pointer.getPeer(timeval), Pointer.getPeer(timestr), duration);
    }
    protected native int av_parse_time(@Ptr long timeval, @Ptr long timestr, int duration);
    /**
     * Attempt to find a specific tag in a URL.<br>
     * syntax: '?tag1=val1&tag2=val2...'. Little URL decoding is done.<br>
     * Return 1 if found.<br>
     * Original signature : <code>int av_find_info_tag(char*, int, const char*, const char*)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/parseutils.h:108</i>
     */
    public int av_find_info_tag(Pointer<Byte > arg, int arg_size, Pointer<Byte > tag1, Pointer<Byte > info) {
        return av_find_info_tag(Pointer.getPeer(arg), arg_size, Pointer.getPeer(tag1), Pointer.getPeer(info));
    }
    protected native int av_find_info_tag(@Ptr long arg, int arg_size, @Ptr long tag1, @Ptr long info);
    /**
     * Simplified version of strptime<br>
     * Parse the input string p according to the format string fmt and<br>
     * store its results in the structure dt.<br>
     * This implementation supports only a subset of the formats supported<br>
     * by the standard strptime().<br>
     * The supported input field descriptors are listed below.<br>
     * - %H: the hour as a decimal number, using a 24-hour clock, in the<br>
     *   range '00' through '23'<br>
     * - %J: hours as a decimal number, in the range '0' through INT_MAX<br>
     * - %M: the minute as a decimal number, using a 24-hour clock, in the<br>
     *   range '00' through '59'<br>
     * - %S: the second as a decimal number, using a 24-hour clock, in the<br>
     *   range '00' through '59'<br>
     * - %Y: the year as a decimal number, using the Gregorian calendar<br>
     * - %m: the month as a decimal number, in the range '1' through '12'<br>
     * - %d: the day of the month as a decimal number, in the range '1'<br>
     *   through '31'<br>
     * - %T: alias for '%H:%M:%S'<br>
     * - %%: a literal '%'<br>
     * @return a pointer to the first character not processed in this function<br>
     *         call. In case the input string contains more characters than<br>
     *         required by the format string the return value points right after<br>
     *         the last consumed input character. In case the whole input string<br>
     *         is consumed the return value points to the null byte at the end of<br>
     *         the string. On failure NULL is returned.<br>
     * Original signature : <code>char* av_small_strptime(const char*, const char*, tm*)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/parseutils.h:137</i>
     */
    public Pointer<Byte > av_small_strptime(Pointer<Byte > p, Pointer<Byte > fmt, Pointer<AvutilLibrary.tm > dt) {
        return (Pointer)Pointer.pointerToAddress(av_small_strptime(Pointer.getPeer(p), Pointer.getPeer(fmt), Pointer.getPeer(dt)), Byte.class);
    }
    @Ptr
    protected native long av_small_strptime(@Ptr long p, @Ptr long fmt, @Ptr long dt);
    /**
     * Convert the decomposed UTC time in tm to a time_t value.<br>
     * Original signature : <code>time_t av_timegm(tm*)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/parseutils.h:142</i>
     */
    public long av_timegm(Pointer<AvutilLibrary.tm > tm) {
        return av_timegm(Pointer.getPeer(tm));
    }
    protected native long av_timegm(@Ptr long tm);
    /**
     * @brief Decodes LZO 1x compressed data.<br>
     * @param out output buffer<br>
     * @param outlen size of output buffer, number of bytes left are returned here<br>
     * @param in input buffer<br>
     * @param inlen size of input buffer, number of bytes left are returned here<br>
     * @return 0 on success, otherwise a combination of the error flags above<br>
     * Make sure all buffers are appropriately padded, in must provide<br>
     * AV_LZO_INPUT_PADDING, out must provide AV_LZO_OUTPUT_PADDING additional bytes.<br>
     * Original signature : <code>int av_lzo1x_decode(void*, int*, const void*, int*)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/lzo.h:11</i>
     */
    public int av_lzo1x_decode(Pointer<? > out, Pointer<Integer > outlen, Pointer<? > in, Pointer<Integer > inlen) {
        return av_lzo1x_decode(Pointer.getPeer(out), Pointer.getPeer(outlen), Pointer.getPeer(in), Pointer.getPeer(inlen));
    }
    protected native int av_lzo1x_decode(@Ptr long out, @Ptr long outlen, @Ptr long in, @Ptr long inlen);
    /**
     * Allocate an AVXTEA context.<br>
     * Original signature : <code>AVXTEA* av_xtea_alloc()</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/xtea.h:14</i>
     */
    public Pointer<AVXTEA > av_xtea_alloc() {
        return (Pointer)Pointer.pointerToAddress(av_xtea_alloc$2(), AVXTEA.class);
    }
    @Ptr
    @Name("av_xtea_alloc")
    protected native long av_xtea_alloc$2();
    /**
     * Initialize an AVXTEA context.<br>
     * @param ctx an AVXTEA context<br>
     * @param key a key of 16 bytes used for encryption/decryption<br>
     * Original signature : <code>void av_xtea_init(AVXTEA*, const uint8_t[16])</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/xtea.h:21</i>
     */
    public void av_xtea_init(Pointer<AVXTEA > ctx, Pointer<Byte > key) {
        av_xtea_init(Pointer.getPeer(ctx), Pointer.getPeer(key));
    }
    protected native void av_xtea_init(@Ptr long ctx, @Ptr long key);
    /**
     * Encrypt or decrypt a buffer using a previously initialized context.<br>
     * @param ctx an AVXTEA context<br>
     * @param dst destination array, can be equal to src<br>
     * @param src source array, can be equal to dst<br>
     * @param count number of 8 byte blocks<br>
     * @param iv initialization vector for CBC mode, if NULL then ECB will be used<br>
     * @param decrypt 0 for encryption, 1 for decryption<br>
     * Original signature : <code>void av_xtea_crypt(AVXTEA*, uint8_t*, const uint8_t*, int, uint8_t*, int)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/xtea.h:32</i>
     */
    public void av_xtea_crypt(Pointer<AVXTEA > ctx, Pointer<Byte > dst, Pointer<Byte > src, int count, Pointer<Byte > iv, int decrypt) {
        av_xtea_crypt(Pointer.getPeer(ctx), Pointer.getPeer(dst), Pointer.getPeer(src), count, Pointer.getPeer(iv), decrypt);
    }
    protected native void av_xtea_crypt(@Ptr long ctx, @Ptr long dst, @Ptr long src, int count, @Ptr long iv, int decrypt);
    /**
     * Allocate an AVAES context.<br>
     * Original signature : <code>AVAES* av_aes_alloc()</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/aes.h:11</i>
     */
    public Pointer<AvutilLibrary.AVAES > av_aes_alloc() {
        return (Pointer)Pointer.pointerToAddress(av_aes_alloc$2(), AvutilLibrary.AVAES.class);
    }
    @Ptr
    @Name("av_aes_alloc")
    protected native long av_aes_alloc$2();
    /**
     * Initialize an AVAES context.<br>
     * @param key_bits 128, 192 or 256<br>
     * @param decrypt 0 for encryption, 1 for decryption<br>
     * Original signature : <code>int av_aes_init(AVAES*, const uint8_t*, int, int)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/aes.h:18</i>
     */
    public int av_aes_init(Pointer<AvutilLibrary.AVAES > a, Pointer<Byte > key, int key_bits, int decrypt) {
        return av_aes_init(Pointer.getPeer(a), Pointer.getPeer(key), key_bits, decrypt);
    }
    protected native int av_aes_init(@Ptr long a, @Ptr long key, int key_bits, int decrypt);
    /**
     * Encrypt or decrypt a buffer using a previously initialized context.<br>
     * @param count number of 16 byte blocks<br>
     * @param dst destination array, can be equal to src<br>
     * @param src source array, can be equal to dst<br>
     * @param iv initialization vector for CBC mode, if NULL then ECB will be used<br>
     * @param decrypt 0 for encryption, 1 for decryption<br>
     * Original signature : <code>void av_aes_crypt(AVAES*, uint8_t*, const uint8_t*, int, uint8_t*, int)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/aes.h:28</i>
     */
    public void av_aes_crypt(Pointer<AvutilLibrary.AVAES > a, Pointer<Byte > dst, Pointer<Byte > src, int count, Pointer<Byte > iv, int decrypt) {
        av_aes_crypt(Pointer.getPeer(a), Pointer.getPeer(dst), Pointer.getPeer(src), count, Pointer.getPeer(iv), decrypt);
    }
    protected native void av_aes_crypt(@Ptr long a, @Ptr long dst, @Ptr long src, int count, @Ptr long iv, int decrypt);
    /**
     * Original signature : <code>void av_lfg_init(AVLFG*, unsigned int)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/lfg.h:21</i>
     */
    public void av_lfg_init(Pointer<AVLFG > c, int seed) {
        av_lfg_init(Pointer.getPeer(c), seed);
    }
    protected native void av_lfg_init(@Ptr long c, int seed);
    /**
     * Get the next two numbers generated by a Box-Muller Gaussian<br>
     * generator using the random numbers issued by lfg.<br>
     * @param out array where the two generated numbers are placed<br>
     * Original signature : <code>void av_bmg_get(AVLFG*, double[2])</code><br>
     * <i>native declaration : ffmpeg_build/include/libavutil/lfg.h:48</i>
     */
    public void av_bmg_get(Pointer<AVLFG > lfg, Pointer<Double > out) {
        av_bmg_get(Pointer.getPeer(lfg), Pointer.getPeer(out));
    }
    protected native void av_bmg_get(@Ptr long lfg, @Ptr long out);
    /**
     * @file<br>
     * @brief Public header for libavutil TEA algorithm<br>
     * @defgroup lavu_tea TEA<br>
     * @ingroup lavu_crypto<br>
     * @{
     */
    public int av_tea_size() {
        try {
            return (int)BridJ.getNativeLibrary("avutil").getSymbolPointer("av_tea_size").getInt();
        }catch (Throwable $ex$) {
            throw new RuntimeException($ex$);
        }
    }
    /**
     * @file<br>
     * @brief Public header for libavutil TEA algorithm<br>
     * @defgroup lavu_tea TEA<br>
     * @ingroup lavu_crypto<br>
     * @{
     */
    public AvutilLibrary av_tea_size(int av_tea_size) {
        try {
            {
                BridJ.getNativeLibrary("avutil").getSymbolPointer("av_tea_size").setInt(av_tea_size);
                return this;
            }
        }catch (Throwable $ex$) {
            throw new RuntimeException($ex$);
        }
    }
    /**
     * @file<br>
     * @brief Public header for libavutil CAST5 algorithm<br>
     * @defgroup lavu_cast5 CAST5<br>
     * @ingroup lavu_crypto<br>
     * @{
     */
    public int av_cast5_size() {
        try {
            return (int)BridJ.getNativeLibrary("avutil").getSymbolPointer("av_cast5_size").getInt();
        }catch (Throwable $ex$) {
            throw new RuntimeException($ex$);
        }
    }
    /**
     * @file<br>
     * @brief Public header for libavutil CAST5 algorithm<br>
     * @defgroup lavu_cast5 CAST5<br>
     * @ingroup lavu_crypto<br>
     * @{
     */
    public AvutilLibrary av_cast5_size(int av_cast5_size) {
        try {
            {
                BridJ.getNativeLibrary("avutil").getSymbolPointer("av_cast5_size").setInt(av_cast5_size);
                return this;
            }
        }catch (Throwable $ex$) {
            throw new RuntimeException($ex$);
        }
    }
    /**
     * @defgroup lavu_ripemd RIPEMD<br>
     * @ingroup lavu_crypto<br>
     * @{
     */
    public int av_ripemd_size() {
        try {
            return (int)BridJ.getNativeLibrary("avutil").getSymbolPointer("av_ripemd_size").getInt();
        }catch (Throwable $ex$) {
            throw new RuntimeException($ex$);
        }
    }
    /**
     * @defgroup lavu_ripemd RIPEMD<br>
     * @ingroup lavu_crypto<br>
     * @{
     */
    public AvutilLibrary av_ripemd_size(int av_ripemd_size) {
        try {
            {
                BridJ.getNativeLibrary("avutil").getSymbolPointer("av_ripemd_size").setInt(av_ripemd_size);
                return this;
            }
        }catch (Throwable $ex$) {
            throw new RuntimeException($ex$);
        }
    }
    /**
     * @defgroup lavu_sha512 SHA512<br>
     * @ingroup lavu_crypto<br>
     * @{
     */
    public int av_sha512_size() {
        try {
            return (int)BridJ.getNativeLibrary("avutil").getSymbolPointer("av_sha512_size").getInt();
        }catch (Throwable $ex$) {
            throw new RuntimeException($ex$);
        }
    }
    /**
     * @defgroup lavu_sha512 SHA512<br>
     * @ingroup lavu_crypto<br>
     * @{
     */
    public AvutilLibrary av_sha512_size(int av_sha512_size) {
        try {
            {
                BridJ.getNativeLibrary("avutil").getSymbolPointer("av_sha512_size").setInt(av_sha512_size);
                return this;
            }
        }catch (Throwable $ex$) {
            throw new RuntimeException($ex$);
        }
    }
    /**
     * @defgroup lavu_md5 MD5<br>
     * @ingroup lavu_crypto<br>
     * @{
     */
    public int av_md5_size() {
        try {
            return (int)BridJ.getNativeLibrary("avutil").getSymbolPointer("av_md5_size").getInt();
        }catch (Throwable $ex$) {
            throw new RuntimeException($ex$);
        }
    }
    /**
     * @defgroup lavu_md5 MD5<br>
     * @ingroup lavu_crypto<br>
     * @{
     */
    public AvutilLibrary av_md5_size(int av_md5_size) {
        try {
            {
                BridJ.getNativeLibrary("avutil").getSymbolPointer("av_md5_size").setInt(av_md5_size);
                return this;
            }
        }catch (Throwable $ex$) {
            throw new RuntimeException($ex$);
        }
    }
    /**
     * @file<br>
     * @brief Public header for libavutil CAMELLIA algorithm<br>
     * @defgroup lavu_camellia CAMELLIA<br>
     * @ingroup lavu_crypto<br>
     * @{
     */
    public int av_camellia_size() {
        try {
            return (int)BridJ.getNativeLibrary("avutil").getSymbolPointer("av_camellia_size").getInt();
        }catch (Throwable $ex$) {
            throw new RuntimeException($ex$);
        }
    }
    /**
     * @file<br>
     * @brief Public header for libavutil CAMELLIA algorithm<br>
     * @defgroup lavu_camellia CAMELLIA<br>
     * @ingroup lavu_crypto<br>
     * @{
     */
    public AvutilLibrary av_camellia_size(int av_camellia_size) {
        try {
            {
                BridJ.getNativeLibrary("avutil").getSymbolPointer("av_camellia_size").setInt(av_camellia_size);
                return this;
            }
        }catch (Throwable $ex$) {
            throw new RuntimeException($ex$);
        }
    }
    /**
     * @defgroup lavu_sha SHA<br>
     * @ingroup lavu_crypto<br>
     * @{
     */
    public int av_sha_size() {
        try {
            return (int)BridJ.getNativeLibrary("avutil").getSymbolPointer("av_sha_size").getInt();
        }catch (Throwable $ex$) {
            throw new RuntimeException($ex$);
        }
    }
    /**
     * @defgroup lavu_sha SHA<br>
     * @ingroup lavu_crypto<br>
     * @{
     */
    public AvutilLibrary av_sha_size(int av_sha_size) {
        try {
            {
                BridJ.getNativeLibrary("avutil").getSymbolPointer("av_sha_size").setInt(av_sha_size);
                return this;
            }
        }catch (Throwable $ex$) {
            throw new RuntimeException($ex$);
        }
    }
    /**
     * @file<br>
     * @brief Public header for libavutil TWOFISH algorithm<br>
     * @defgroup lavu_twofish TWOFISH<br>
     * @ingroup lavu_crypto<br>
     * @{
     */
    public int av_twofish_size() {
        try {
            return (int)BridJ.getNativeLibrary("avutil").getSymbolPointer("av_twofish_size").getInt();
        }catch (Throwable $ex$) {
            throw new RuntimeException($ex$);
        }
    }
    /**
     * @file<br>
     * @brief Public header for libavutil TWOFISH algorithm<br>
     * @defgroup lavu_twofish TWOFISH<br>
     * @ingroup lavu_crypto<br>
     * @{
     */
    public AvutilLibrary av_twofish_size(int av_twofish_size) {
        try {
            {
                BridJ.getNativeLibrary("avutil").getSymbolPointer("av_twofish_size").setInt(av_twofish_size);
                return this;
            }
        }catch (Throwable $ex$) {
            throw new RuntimeException($ex$);
        }
    }
    /**
     * @defgroup lavu_aes AES<br>
     * @ingroup lavu_crypto<br>
     * @{
     */
    public int av_aes_size() {
        try {
            return (int)BridJ.getNativeLibrary("avutil").getSymbolPointer("av_aes_size").getInt();
        }catch (Throwable $ex$) {
            throw new RuntimeException($ex$);
        }
    }
    /**
     * @defgroup lavu_aes AES<br>
     * @ingroup lavu_crypto<br>
     * @{
     */
    public AvutilLibrary av_aes_size(int av_aes_size) {
        try {
            {
                BridJ.getNativeLibrary("avutil").getSymbolPointer("av_aes_size").setInt(av_aes_size);
                return this;
            }
        }catch (Throwable $ex$) {
            throw new RuntimeException($ex$);
        }
    }
    /** Undefined type */
    public static interface AVExpr {

    };
    /** Undefined type */
    public static interface AVRIPEMD {

    };
    /** Undefined type */
    public static interface AVSHA512 {

    };
    /** Undefined type */
    public static interface AVCAST5 {

    };
    /** Undefined type */
    public static interface AVAES {

    };
    /** Undefined type */
    public static interface AVTEA {

    };
    /** Undefined type */
    public static interface AVMurMur3 {

    };
    /** Undefined type */
    public static interface AVSHA {

    };
    /** Undefined type */
    public static interface AVHashContext {

    };
    /** Undefined type */
    public static interface AVAudioFifo {

    };
    /** Undefined type */
    public static interface AVBufferPool {

    };
    /** Undefined type */
    public static interface AVTWOFISH {

    };
    /** Undefined type */
    public static interface AVBuffer {

    };
    /** Undefined type */
    public static interface AVHMAC {

    };
    /** Undefined type */
    public static interface AVMD5 {

    };
    /** Undefined type */
    public static interface AVCAMELLIA {

    };
    /** Undefined type */
    public static interface tm {

    };
    /** Undefined type */
    public static interface AVThreadMessageQueue {

    };
}
