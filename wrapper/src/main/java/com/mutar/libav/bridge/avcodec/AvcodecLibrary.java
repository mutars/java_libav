package com.mutar.libav.bridge.avcodec;
import java.lang.reflect.Type;
import java.util.Collections;
import java.util.Iterator;

import org.bridj.BridJ;
import org.bridj.CRuntime;
import org.bridj.Callback;
import org.bridj.FlagSet;
import org.bridj.IntValuedEnum;
import org.bridj.Pointer;
import org.bridj.ann.Library;
import org.bridj.ann.Name;
import org.bridj.ann.Ptr;
import org.bridj.ann.Runtime;
import org.bridj.util.DefaultParameterizedType;

import com.mutar.libav.bridge.avdevice.AvdeviceLibrary.AVDictionary;
import com.mutar.libav.bridge.avutil.AVClass;
import com.mutar.libav.bridge.avutil.AVFrame;
import com.mutar.libav.bridge.avutil.AVRational;
import com.mutar.libav.bridge.avutil.AvutilLibrary.AVChromaLocation;
import com.mutar.libav.bridge.avutil.AvutilLibrary.AVMediaType;
import com.mutar.libav.bridge.avutil.AvutilLibrary.AVPixelFormat;
import com.mutar.libav.bridge.avutil.AvutilLibrary.AVSampleFormat;
/**
 * Wrapper for library <b>avcodec</b><br>
 * This file was autogenerated by <a href="http://jnaerator.googlecode.com/">JNAerator</a>,<br>
 * a tool written by <a href="http://ochafik.com/">Olivier Chafik</a> that <a href="http://code.google.com/p/jnaerator/wiki/CreditsAndLicense">uses a few opensource projects.</a>.<br>
 * For help, please visit <a href="http://nativelibs4java.googlecode.com/">NativeLibs4Java</a> or <a href="http://bridj.googlecode.com/">BridJ</a> .
 */
@Library(value="avcodec", dependencies= {"swresample", "x264", "fdk-aac"})
@Runtime(CRuntime.class)
public class AvcodecLibrary {
    static {
        BridJ.register();
    }
    /**
     * Identify the syntax and semantics of the bitstream.<br>
     * The principle is roughly:<br>
     * Two decoders with the same ID can decode the same streams.<br>
     * Two encoders with the same ID can encode compatible streams.<br>
     * There may be slight deviations from the principle due to implementation<br>
     * details.<br>
     * If you add a codec ID to this list, add it so that<br>
     * 1. no value of a existing codec ID changes (that would break ABI),<br>
     * 2. it is as close as possible to similar codecs<br>
     * After adding new codec IDs, do not forget to add an entry to the codec<br>
     * descriptor list and bump libavcodec minor version.<br>
     * enum values<br>
     * <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h:430</i>
     */
    public enum AVCodecID implements IntValuedEnum<AVCodecID > {
        AV_CODEC_ID_NONE(0),
        AV_CODEC_ID_MPEG1VIDEO(1),
        /** < preferred ID for MPEG-1/2 video decoding */
        AV_CODEC_ID_MPEG2VIDEO(2),
        AV_CODEC_ID_MPEG2VIDEO_XVMC(3),
        AV_CODEC_ID_H261(4),
        AV_CODEC_ID_H263(5),
        AV_CODEC_ID_RV10(6),
        AV_CODEC_ID_RV20(7),
        AV_CODEC_ID_MJPEG(8),
        AV_CODEC_ID_MJPEGB(9),
        AV_CODEC_ID_LJPEG(10),
        AV_CODEC_ID_SP5X(11),
        AV_CODEC_ID_JPEGLS(12),
        AV_CODEC_ID_MPEG4(13),
        AV_CODEC_ID_RAWVIDEO(14),
        AV_CODEC_ID_MSMPEG4V1(15),
        AV_CODEC_ID_MSMPEG4V2(16),
        AV_CODEC_ID_MSMPEG4V3(17),
        AV_CODEC_ID_WMV1(18),
        AV_CODEC_ID_WMV2(19),
        AV_CODEC_ID_H263P(20),
        AV_CODEC_ID_H263I(21),
        AV_CODEC_ID_FLV1(22),
        AV_CODEC_ID_SVQ1(23),
        AV_CODEC_ID_SVQ3(24),
        AV_CODEC_ID_DVVIDEO(25),
        AV_CODEC_ID_HUFFYUV(26),
        AV_CODEC_ID_CYUV(27),
        AV_CODEC_ID_H264(28),
        AV_CODEC_ID_INDEO3(29),
        AV_CODEC_ID_VP3(30),
        AV_CODEC_ID_THEORA(31),
        AV_CODEC_ID_ASV1(32),
        AV_CODEC_ID_ASV2(33),
        AV_CODEC_ID_FFV1(34),
        AV_CODEC_ID_4XM(35),
        AV_CODEC_ID_VCR1(36),
        AV_CODEC_ID_CLJR(37),
        AV_CODEC_ID_MDEC(38),
        AV_CODEC_ID_ROQ(39),
        AV_CODEC_ID_INTERPLAY_VIDEO(40),
        AV_CODEC_ID_XAN_WC3(41),
        AV_CODEC_ID_XAN_WC4(42),
        AV_CODEC_ID_RPZA(43),
        AV_CODEC_ID_CINEPAK(44),
        AV_CODEC_ID_WS_VQA(45),
        AV_CODEC_ID_MSRLE(46),
        AV_CODEC_ID_MSVIDEO1(47),
        AV_CODEC_ID_IDCIN(48),
        AV_CODEC_ID_8BPS(49),
        AV_CODEC_ID_SMC(50),
        AV_CODEC_ID_FLIC(51),
        AV_CODEC_ID_TRUEMOTION1(52),
        AV_CODEC_ID_VMDVIDEO(53),
        AV_CODEC_ID_MSZH(54),
        AV_CODEC_ID_ZLIB(55),
        AV_CODEC_ID_QTRLE(56),
        AV_CODEC_ID_TSCC(57),
        AV_CODEC_ID_ULTI(58),
        AV_CODEC_ID_QDRAW(59),
        AV_CODEC_ID_VIXL(60),
        AV_CODEC_ID_QPEG(61),
        AV_CODEC_ID_PNG(62),
        AV_CODEC_ID_PPM(63),
        AV_CODEC_ID_PBM(64),
        AV_CODEC_ID_PGM(65),
        AV_CODEC_ID_PGMYUV(66),
        AV_CODEC_ID_PAM(67),
        AV_CODEC_ID_FFVHUFF(68),
        AV_CODEC_ID_RV30(69),
        AV_CODEC_ID_RV40(70),
        AV_CODEC_ID_VC1(71),
        AV_CODEC_ID_WMV3(72),
        AV_CODEC_ID_LOCO(73),
        AV_CODEC_ID_WNV1(74),
        AV_CODEC_ID_AASC(75),
        AV_CODEC_ID_INDEO2(76),
        AV_CODEC_ID_FRAPS(77),
        AV_CODEC_ID_TRUEMOTION2(78),
        AV_CODEC_ID_BMP(79),
        AV_CODEC_ID_CSCD(80),
        AV_CODEC_ID_MMVIDEO(81),
        AV_CODEC_ID_ZMBV(82),
        AV_CODEC_ID_AVS(83),
        AV_CODEC_ID_SMACKVIDEO(84),
        AV_CODEC_ID_NUV(85),
        AV_CODEC_ID_KMVC(86),
        AV_CODEC_ID_FLASHSV(87),
        AV_CODEC_ID_CAVS(88),
        AV_CODEC_ID_JPEG2000(89),
        AV_CODEC_ID_VMNC(90),
        AV_CODEC_ID_VP5(91),
        AV_CODEC_ID_VP6(92),
        AV_CODEC_ID_VP6F(93),
        AV_CODEC_ID_TARGA(94),
        AV_CODEC_ID_DSICINVIDEO(95),
        AV_CODEC_ID_TIERTEXSEQVIDEO(96),
        AV_CODEC_ID_TIFF(97),
        AV_CODEC_ID_GIF(98),
        AV_CODEC_ID_DXA(99),
        AV_CODEC_ID_DNXHD(100),
        AV_CODEC_ID_THP(101),
        AV_CODEC_ID_SGI(102),
        AV_CODEC_ID_C93(103),
        AV_CODEC_ID_BETHSOFTVID(104),
        AV_CODEC_ID_PTX(105),
        AV_CODEC_ID_TXD(106),
        AV_CODEC_ID_VP6A(107),
        AV_CODEC_ID_AMV(108),
        AV_CODEC_ID_VB(109),
        AV_CODEC_ID_PCX(110),
        AV_CODEC_ID_SUNRAST(111),
        AV_CODEC_ID_INDEO4(112),
        AV_CODEC_ID_INDEO5(113),
        AV_CODEC_ID_MIMIC(114),
        AV_CODEC_ID_RL2(115),
        AV_CODEC_ID_ESCAPE124(116),
        AV_CODEC_ID_DIRAC(117),
        AV_CODEC_ID_BFI(118),
        AV_CODEC_ID_CMV(119),
        AV_CODEC_ID_MOTIONPIXELS(120),
        AV_CODEC_ID_TGV(121),
        AV_CODEC_ID_TGQ(122),
        AV_CODEC_ID_TQI(123),
        AV_CODEC_ID_AURA(124),
        AV_CODEC_ID_AURA2(125),
        AV_CODEC_ID_V210X(126),
        AV_CODEC_ID_TMV(127),
        AV_CODEC_ID_V210(128),
        AV_CODEC_ID_DPX(129),
        AV_CODEC_ID_MAD(130),
        AV_CODEC_ID_FRWU(131),
        AV_CODEC_ID_FLASHSV2(132),
        AV_CODEC_ID_CDGRAPHICS(133),
        AV_CODEC_ID_R210(134),
        AV_CODEC_ID_ANM(135),
        AV_CODEC_ID_BINKVIDEO(136),
        AV_CODEC_ID_IFF_ILBM(137),
        AV_CODEC_ID_KGV1(138),
        AV_CODEC_ID_YOP(139),
        AV_CODEC_ID_VP8(140),
        AV_CODEC_ID_PICTOR(141),
        AV_CODEC_ID_ANSI(142),
        AV_CODEC_ID_A64_MULTI(143),
        AV_CODEC_ID_A64_MULTI5(144),
        AV_CODEC_ID_R10K(145),
        AV_CODEC_ID_MXPEG(146),
        AV_CODEC_ID_LAGARITH(147),
        AV_CODEC_ID_PRORES(148),
        AV_CODEC_ID_JV(149),
        AV_CODEC_ID_DFA(150),
        AV_CODEC_ID_WMV3IMAGE(151),
        AV_CODEC_ID_VC1IMAGE(152),
        AV_CODEC_ID_UTVIDEO(153),
        AV_CODEC_ID_BMV_VIDEO(154),
        AV_CODEC_ID_VBLE(155),
        AV_CODEC_ID_DXTORY(156),
        AV_CODEC_ID_V410(157),
        AV_CODEC_ID_XWD(158),
        AV_CODEC_ID_CDXL(159),
        AV_CODEC_ID_XBM(160),
        AV_CODEC_ID_ZEROCODEC(161),
        AV_CODEC_ID_MSS1(162),
        AV_CODEC_ID_MSA1(163),
        AV_CODEC_ID_TSCC2(164),
        AV_CODEC_ID_MTS2(165),
        AV_CODEC_ID_CLLC(166),
        AV_CODEC_ID_MSS2(167),
        AV_CODEC_ID_VP9(168),
        AV_CODEC_ID_AIC(169),
        AV_CODEC_ID_ESCAPE130(170),
        AV_CODEC_ID_G2M(171),
        AV_CODEC_ID_WEBP(172),
        AV_CODEC_ID_HNM4_VIDEO(173),
        AV_CODEC_ID_HEVC(174),
        AV_CODEC_ID_FIC(175),
        AV_CODEC_ID_ALIAS_PIX(176),
        AV_CODEC_ID_BRENDER_PIX(177),
        AV_CODEC_ID_PAF_VIDEO(178),
        AV_CODEC_ID_EXR(179),
        AV_CODEC_ID_VP7(180),
        AV_CODEC_ID_SANM(181),
        AV_CODEC_ID_SGIRLE(182),
        AV_CODEC_ID_MVC1(183),
        AV_CODEC_ID_MVC2(184),
        AV_CODEC_ID_HQX(185),
        AV_CODEC_ID_TDSC(186),
        AV_CODEC_ID_HQ_HQA(187),
        AV_CODEC_ID_HAP(188),
        AV_CODEC_ID_DDS(189),
        AV_CODEC_ID_DXV(190),
        AV_CODEC_ID_SCREENPRESSO(191),
        AV_CODEC_ID_Y41P(0x8000),
        AV_CODEC_ID_AVRP((0x8000 + 1)),
        AV_CODEC_ID_012V((0x8000 + 2)),
        AV_CODEC_ID_AVUI((0x8000 + 3)),
        AV_CODEC_ID_AYUV((0x8000 + 4)),
        AV_CODEC_ID_TARGA_Y216((0x8000 + 5)),
        AV_CODEC_ID_V308((0x8000 + 6)),
        AV_CODEC_ID_V408((0x8000 + 7)),
        AV_CODEC_ID_YUV4((0x8000 + 8)),
        AV_CODEC_ID_AVRN((0x8000 + 9)),
        AV_CODEC_ID_CPIA((0x8000 + 10)),
        AV_CODEC_ID_XFACE((0x8000 + 11)),
        AV_CODEC_ID_SNOW((0x8000 + 12)),
        AV_CODEC_ID_SMVJPEG((0x8000 + 13)),
        AV_CODEC_ID_APNG((0x8000 + 14)),
        /** < A dummy id pointing at the start of audio codecs */
        AV_CODEC_ID_FIRST_AUDIO(0x10000),
        AV_CODEC_ID_PCM_S16LE(0x10000),
        AV_CODEC_ID_PCM_S16BE((0x10000 + 1)),
        AV_CODEC_ID_PCM_U16LE((0x10000 + 2)),
        AV_CODEC_ID_PCM_U16BE((0x10000 + 3)),
        AV_CODEC_ID_PCM_S8((0x10000 + 4)),
        AV_CODEC_ID_PCM_U8((0x10000 + 5)),
        AV_CODEC_ID_PCM_MULAW((0x10000 + 6)),
        AV_CODEC_ID_PCM_ALAW((0x10000 + 7)),
        AV_CODEC_ID_PCM_S32LE((0x10000 + 8)),
        AV_CODEC_ID_PCM_S32BE((0x10000 + 9)),
        AV_CODEC_ID_PCM_U32LE((0x10000 + 10)),
        AV_CODEC_ID_PCM_U32BE((0x10000 + 11)),
        AV_CODEC_ID_PCM_S24LE((0x10000 + 12)),
        AV_CODEC_ID_PCM_S24BE((0x10000 + 13)),
        AV_CODEC_ID_PCM_U24LE((0x10000 + 14)),
        AV_CODEC_ID_PCM_U24BE((0x10000 + 15)),
        AV_CODEC_ID_PCM_S24DAUD((0x10000 + 16)),
        AV_CODEC_ID_PCM_ZORK((0x10000 + 17)),
        AV_CODEC_ID_PCM_S16LE_PLANAR((0x10000 + 18)),
        AV_CODEC_ID_PCM_DVD((0x10000 + 19)),
        AV_CODEC_ID_PCM_F32BE((0x10000 + 20)),
        AV_CODEC_ID_PCM_F32LE((0x10000 + 21)),
        AV_CODEC_ID_PCM_F64BE((0x10000 + 22)),
        AV_CODEC_ID_PCM_F64LE((0x10000 + 23)),
        AV_CODEC_ID_PCM_BLURAY((0x10000 + 24)),
        AV_CODEC_ID_PCM_LXF((0x10000 + 25)),
        AV_CODEC_ID_S302M((0x10000 + 26)),
        AV_CODEC_ID_PCM_S8_PLANAR((0x10000 + 27)),
        AV_CODEC_ID_PCM_S24LE_PLANAR((0x10000 + 28)),
        AV_CODEC_ID_PCM_S32LE_PLANAR((0x10000 + 29)),
        AV_CODEC_ID_PCM_S16BE_PLANAR((0x10000 + 30)),
        AV_CODEC_ID_ADPCM_IMA_QT(0x11000),
        AV_CODEC_ID_ADPCM_IMA_WAV((0x11000 + 1)),
        AV_CODEC_ID_ADPCM_IMA_DK3((0x11000 + 2)),
        AV_CODEC_ID_ADPCM_IMA_DK4((0x11000 + 3)),
        AV_CODEC_ID_ADPCM_IMA_WS((0x11000 + 4)),
        AV_CODEC_ID_ADPCM_IMA_SMJPEG((0x11000 + 5)),
        AV_CODEC_ID_ADPCM_MS((0x11000 + 6)),
        AV_CODEC_ID_ADPCM_4XM((0x11000 + 7)),
        AV_CODEC_ID_ADPCM_XA((0x11000 + 8)),
        AV_CODEC_ID_ADPCM_ADX((0x11000 + 9)),
        AV_CODEC_ID_ADPCM_EA((0x11000 + 10)),
        AV_CODEC_ID_ADPCM_G726((0x11000 + 11)),
        AV_CODEC_ID_ADPCM_CT((0x11000 + 12)),
        AV_CODEC_ID_ADPCM_SWF((0x11000 + 13)),
        AV_CODEC_ID_ADPCM_YAMAHA((0x11000 + 14)),
        AV_CODEC_ID_ADPCM_SBPRO_4((0x11000 + 15)),
        AV_CODEC_ID_ADPCM_SBPRO_3((0x11000 + 16)),
        AV_CODEC_ID_ADPCM_SBPRO_2((0x11000 + 17)),
        AV_CODEC_ID_ADPCM_THP((0x11000 + 18)),
        AV_CODEC_ID_ADPCM_IMA_AMV((0x11000 + 19)),
        AV_CODEC_ID_ADPCM_EA_R1((0x11000 + 20)),
        AV_CODEC_ID_ADPCM_EA_R3((0x11000 + 21)),
        AV_CODEC_ID_ADPCM_EA_R2((0x11000 + 22)),
        AV_CODEC_ID_ADPCM_IMA_EA_SEAD((0x11000 + 23)),
        AV_CODEC_ID_ADPCM_IMA_EA_EACS((0x11000 + 24)),
        AV_CODEC_ID_ADPCM_EA_XAS((0x11000 + 25)),
        AV_CODEC_ID_ADPCM_EA_MAXIS_XA((0x11000 + 26)),
        AV_CODEC_ID_ADPCM_IMA_ISS((0x11000 + 27)),
        AV_CODEC_ID_ADPCM_G722((0x11000 + 28)),
        AV_CODEC_ID_ADPCM_IMA_APC((0x11000 + 29)),
        AV_CODEC_ID_ADPCM_VIMA((0x11000 + 30)),
        AV_CODEC_ID_VIMA(0x11000 + 30),
        AV_CODEC_ID_ADPCM_AFC(0x11800),
        AV_CODEC_ID_ADPCM_IMA_OKI((0x11800 + 1)),
        AV_CODEC_ID_ADPCM_DTK((0x11800 + 2)),
        AV_CODEC_ID_ADPCM_IMA_RAD((0x11800 + 3)),
        AV_CODEC_ID_ADPCM_G726LE((0x11800 + 4)),
        AV_CODEC_ID_ADPCM_THP_LE((0x11800 + 5)),
        AV_CODEC_ID_ADPCM_PSX((0x11800 + 6)),
        AV_CODEC_ID_AMR_NB(0x12000),
        AV_CODEC_ID_AMR_WB((0x12000 + 1)),
        AV_CODEC_ID_RA_144(0x13000),
        AV_CODEC_ID_RA_288((0x13000 + 1)),
        AV_CODEC_ID_ROQ_DPCM(0x14000),
        AV_CODEC_ID_INTERPLAY_DPCM((0x14000 + 1)),
        AV_CODEC_ID_XAN_DPCM((0x14000 + 2)),
        AV_CODEC_ID_SOL_DPCM((0x14000 + 3)),
        AV_CODEC_ID_MP2(0x15000),
        /** < preferred ID for decoding MPEG audio layer 1, 2 or 3 */
        AV_CODEC_ID_MP3((0x15000 + 1)),
        AV_CODEC_ID_AAC((0x15000 + 2)),
        AV_CODEC_ID_AC3((0x15000 + 3)),
        AV_CODEC_ID_DTS((0x15000 + 4)),
        AV_CODEC_ID_VORBIS((0x15000 + 5)),
        AV_CODEC_ID_DVAUDIO((0x15000 + 6)),
        AV_CODEC_ID_WMAV1((0x15000 + 7)),
        AV_CODEC_ID_WMAV2((0x15000 + 8)),
        AV_CODEC_ID_MACE3((0x15000 + 9)),
        AV_CODEC_ID_MACE6((0x15000 + 10)),
        AV_CODEC_ID_VMDAUDIO((0x15000 + 11)),
        AV_CODEC_ID_FLAC((0x15000 + 12)),
        AV_CODEC_ID_MP3ADU((0x15000 + 13)),
        AV_CODEC_ID_MP3ON4((0x15000 + 14)),
        AV_CODEC_ID_SHORTEN((0x15000 + 15)),
        AV_CODEC_ID_ALAC((0x15000 + 16)),
        AV_CODEC_ID_WESTWOOD_SND1((0x15000 + 17)),
        /** < as in Berlin toast format */
        AV_CODEC_ID_GSM((0x15000 + 18)),
        AV_CODEC_ID_QDM2((0x15000 + 19)),
        AV_CODEC_ID_COOK((0x15000 + 20)),
        AV_CODEC_ID_TRUESPEECH((0x15000 + 21)),
        AV_CODEC_ID_TTA((0x15000 + 22)),
        AV_CODEC_ID_SMACKAUDIO((0x15000 + 23)),
        AV_CODEC_ID_QCELP((0x15000 + 24)),
        AV_CODEC_ID_WAVPACK((0x15000 + 25)),
        AV_CODEC_ID_DSICINAUDIO((0x15000 + 26)),
        AV_CODEC_ID_IMC((0x15000 + 27)),
        AV_CODEC_ID_MUSEPACK7((0x15000 + 28)),
        AV_CODEC_ID_MLP((0x15000 + 29)),
        /** as found in WAV */
        AV_CODEC_ID_GSM_MS((0x15000 + 30)),
        AV_CODEC_ID_ATRAC3((0x15000 + 31)),
        AV_CODEC_ID_VOXWARE((0x15000 + 32)),
        AV_CODEC_ID_APE((0x15000 + 33)),
        AV_CODEC_ID_NELLYMOSER((0x15000 + 34)),
        AV_CODEC_ID_MUSEPACK8((0x15000 + 35)),
        AV_CODEC_ID_SPEEX((0x15000 + 36)),
        AV_CODEC_ID_WMAVOICE((0x15000 + 37)),
        AV_CODEC_ID_WMAPRO((0x15000 + 38)),
        AV_CODEC_ID_WMALOSSLESS((0x15000 + 39)),
        AV_CODEC_ID_ATRAC3P((0x15000 + 40)),
        AV_CODEC_ID_EAC3((0x15000 + 41)),
        AV_CODEC_ID_SIPR((0x15000 + 42)),
        AV_CODEC_ID_MP1((0x15000 + 43)),
        AV_CODEC_ID_TWINVQ((0x15000 + 44)),
        AV_CODEC_ID_TRUEHD((0x15000 + 45)),
        AV_CODEC_ID_MP4ALS((0x15000 + 46)),
        AV_CODEC_ID_ATRAC1((0x15000 + 47)),
        AV_CODEC_ID_BINKAUDIO_RDFT((0x15000 + 48)),
        AV_CODEC_ID_BINKAUDIO_DCT((0x15000 + 49)),
        AV_CODEC_ID_AAC_LATM((0x15000 + 50)),
        AV_CODEC_ID_QDMC((0x15000 + 51)),
        AV_CODEC_ID_CELT((0x15000 + 52)),
        AV_CODEC_ID_G723_1((0x15000 + 53)),
        AV_CODEC_ID_G729((0x15000 + 54)),
        AV_CODEC_ID_8SVX_EXP((0x15000 + 55)),
        AV_CODEC_ID_8SVX_FIB((0x15000 + 56)),
        AV_CODEC_ID_BMV_AUDIO((0x15000 + 57)),
        AV_CODEC_ID_RALF((0x15000 + 58)),
        AV_CODEC_ID_IAC((0x15000 + 59)),
        AV_CODEC_ID_ILBC((0x15000 + 60)),
        AV_CODEC_ID_OPUS((0x15000 + 61)),
        AV_CODEC_ID_COMFORT_NOISE((0x15000 + 62)),
        AV_CODEC_ID_TAK((0x15000 + 63)),
        AV_CODEC_ID_METASOUND((0x15000 + 64)),
        AV_CODEC_ID_PAF_AUDIO((0x15000 + 65)),
        AV_CODEC_ID_ON2AVC((0x15000 + 66)),
        AV_CODEC_ID_DSS_SP((0x15000 + 67)),
        AV_CODEC_ID_FFWAVESYNTH(0x15800),
        AV_CODEC_ID_SONIC((0x15800 + 1)),
        AV_CODEC_ID_SONIC_LS((0x15800 + 2)),
        AV_CODEC_ID_EVRC((0x15800 + 3)),
        AV_CODEC_ID_SMV((0x15800 + 4)),
        AV_CODEC_ID_DSD_LSBF((0x15800 + 5)),
        AV_CODEC_ID_DSD_MSBF((0x15800 + 6)),
        AV_CODEC_ID_DSD_LSBF_PLANAR((0x15800 + 7)),
        AV_CODEC_ID_DSD_MSBF_PLANAR((0x15800 + 8)),
        AV_CODEC_ID_4GV((0x15800 + 9)),
        /** < A dummy ID pointing at the start of subtitle codecs. */
        AV_CODEC_ID_FIRST_SUBTITLE(0x17000),
        AV_CODEC_ID_DVD_SUBTITLE(0x17000),
        AV_CODEC_ID_DVB_SUBTITLE((0x17000 + 1)),
        /** < raw UTF-8 text */
        AV_CODEC_ID_TEXT((0x17000 + 2)),
        AV_CODEC_ID_XSUB((0x17000 + 3)),
        AV_CODEC_ID_SSA((0x17000 + 4)),
        AV_CODEC_ID_MOV_TEXT((0x17000 + 5)),
        AV_CODEC_ID_HDMV_PGS_SUBTITLE((0x17000 + 6)),
        AV_CODEC_ID_DVB_TELETEXT((0x17000 + 7)),
        AV_CODEC_ID_SRT((0x17000 + 8)),
        AV_CODEC_ID_MICRODVD(0x17800),
        AV_CODEC_ID_EIA_608((0x17800 + 1)),
        AV_CODEC_ID_JACOSUB((0x17800 + 2)),
        AV_CODEC_ID_SAMI((0x17800 + 3)),
        AV_CODEC_ID_REALTEXT((0x17800 + 4)),
        AV_CODEC_ID_STL((0x17800 + 5)),
        AV_CODEC_ID_SUBVIEWER1((0x17800 + 6)),
        AV_CODEC_ID_SUBVIEWER((0x17800 + 7)),
        AV_CODEC_ID_SUBRIP((0x17800 + 8)),
        AV_CODEC_ID_WEBVTT((0x17800 + 9)),
        AV_CODEC_ID_MPL2((0x17800 + 10)),
        AV_CODEC_ID_VPLAYER((0x17800 + 11)),
        AV_CODEC_ID_PJS((0x17800 + 12)),
        AV_CODEC_ID_ASS((0x17800 + 13)),
        AV_CODEC_ID_HDMV_TEXT_SUBTITLE((0x17800 + 14)),
        /** < A dummy ID pointing at the start of various fake codecs. */
        AV_CODEC_ID_FIRST_UNKNOWN(0x18000),
        AV_CODEC_ID_TTF(0x18000),
        AV_CODEC_ID_BINTEXT(0x18800),
        AV_CODEC_ID_XBIN((0x18800 + 1)),
        AV_CODEC_ID_IDF((0x18800 + 2)),
        AV_CODEC_ID_OTF((0x18800 + 3)),
        AV_CODEC_ID_SMPTE_KLV((0x18800 + 4)),
        AV_CODEC_ID_DVD_NAV((0x18800 + 5)),
        AV_CODEC_ID_TIMED_ID3((0x18800 + 6)),
        AV_CODEC_ID_BIN_DATA((0x18800 + 7)),
        /** < codec_id is not known (like AV_CODEC_ID_NONE) but lavf should attempt to identify it */
        AV_CODEC_ID_PROBE(0x19000),
        /**
         * < _FAKE_ codec to indicate a raw MPEG-2 TS<br>
         * stream (only used by libavformat)
         */
        AV_CODEC_ID_MPEG2TS(0x20000),
        /**
         * < _FAKE_ codec to indicate a MPEG-4 Systems<br>
         * stream (only used by libavformat)
         */
        AV_CODEC_ID_MPEG4SYSTEMS(0x20001),
        /** < Dummy codec for streams containing only metadata information. */
        AV_CODEC_ID_FFMETADATA(0x21000),
        /** < Passthrough codec, AVFrames wrapped in AVPacket */
        AV_CODEC_ID_WRAPPED_AVFRAME(0x21001);
        AVCodecID(long value) {
            this.value = value;
        }
        public final long value;
        public long value() {
            return this.value;
        }
        public Iterator<AVCodecID > iterator() {
            return Collections.singleton(this).iterator();
        }
        public static IntValuedEnum<AVCodecID > fromValue(int value) {
            return FlagSet.fromValue(value, values());
        }
    };
    /**
     * @ingroup lavc_encoding<br>
     * motion estimation type.<br>
     * @deprecated use codec private option instead<br>
     * enum values<br>
     * <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h:471</i>
     */
    public enum Motion_Est_ID implements IntValuedEnum<Motion_Est_ID > {
        /** < no search, that is use 0,0 vector whenever one is needed */
        ME_ZERO(1),
        ME_FULL(2),
        ME_LOG(3),
        ME_PHODS(4),
        /** < enhanced predictive zonal search */
        ME_EPZS(5),
        /** < reserved for experiments */
        ME_X1(6),
        /** < hexagon based search */
        ME_HEX(7),
        /** < uneven multi-hexagon search */
        ME_UMH(8),
        /** < transformed exhaustive search algorithm */
        ME_TESA(9),
        /** < iterative search */
        ME_ITER(50);
        Motion_Est_ID(long value) {
            this.value = value;
        }
        public final long value;
        public long value() {
            return this.value;
        }
        public Iterator<Motion_Est_ID > iterator() {
            return Collections.singleton(this).iterator();
        }
        public static IntValuedEnum<Motion_Est_ID > fromValue(int value) {
            return FlagSet.fromValue(value, values());
        }
    };
    /**
     * @ingroup lavc_decoding<br>
     * enum values<br>
     * <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h:488</i>
     */
    public enum AVDiscard implements IntValuedEnum<AVDiscard > {
        /** < discard nothing */
        AVDISCARD_NONE(-16),
        /** < discard useless packets like 0 size packets in avi */
        AVDISCARD_DEFAULT(0),
        /** < discard all non reference */
        AVDISCARD_NONREF(8),
        /** < discard all bidirectional frames */
        AVDISCARD_BIDIR(16),
        /** < discard all non intra frames */
        AVDISCARD_NONINTRA(24),
        /** < discard all frames except keyframes */
        AVDISCARD_NONKEY(32),
        /** < discard all */
        AVDISCARD_ALL(48);
        AVDiscard(long value) {
            this.value = value;
        }
        public final long value;
        public long value() {
            return this.value;
        }
        public Iterator<AVDiscard > iterator() {
            return Collections.singleton(this).iterator();
        }
        public static IntValuedEnum<AVDiscard > fromValue(int value) {
            return FlagSet.fromValue(value, values());
        }
    };
    /**
     * enum values<br>
     * <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h:501</i>
     */
    public enum AVAudioServiceType implements IntValuedEnum<AVAudioServiceType > {
        AV_AUDIO_SERVICE_TYPE_MAIN(0),
        AV_AUDIO_SERVICE_TYPE_EFFECTS(1),
        AV_AUDIO_SERVICE_TYPE_VISUALLY_IMPAIRED(2),
        AV_AUDIO_SERVICE_TYPE_HEARING_IMPAIRED(3),
        AV_AUDIO_SERVICE_TYPE_DIALOGUE(4),
        AV_AUDIO_SERVICE_TYPE_COMMENTARY(5),
        AV_AUDIO_SERVICE_TYPE_EMERGENCY(6),
        AV_AUDIO_SERVICE_TYPE_VOICE_OVER(7),
        AV_AUDIO_SERVICE_TYPE_KARAOKE(8),
        /** < Not part of ABI */
        AV_AUDIO_SERVICE_TYPE_NB(9);
        AVAudioServiceType(long value) {
            this.value = value;
        }
        public final long value;
        public long value() {
            return this.value;
        }
        public Iterator<AVAudioServiceType > iterator() {
            return Collections.singleton(this).iterator();
        }
        public static IntValuedEnum<AVAudioServiceType > fromValue(int value) {
            return FlagSet.fromValue(value, values());
        }
    };
    /**
     * @defgroup lavc_packet AVPacket<br>
     * Types and functions for working with AVPacket.<br>
     * @{<br>
     * enum values<br>
     * <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h:544</i>
     */
    public enum AVPacketSideDataType implements IntValuedEnum<AVPacketSideDataType > {
        AV_PKT_DATA_PALETTE(0),
        AV_PKT_DATA_NEW_EXTRADATA(1),
        AV_PKT_DATA_PARAM_CHANGE(2),
        AV_PKT_DATA_H263_MB_INFO(3),
        AV_PKT_DATA_REPLAYGAIN(4),
        AV_PKT_DATA_DISPLAYMATRIX(5),
        AV_PKT_DATA_STEREO3D(6),
        AV_PKT_DATA_AUDIO_SERVICE_TYPE(7),
        AV_PKT_DATA_QUALITY_STATS(8),
        AV_PKT_DATA_SKIP_SAMPLES(70),
        AV_PKT_DATA_JP_DUALMONO(71),
        AV_PKT_DATA_STRINGS_METADATA(72),
        AV_PKT_DATA_SUBTITLE_POSITION(73),
        AV_PKT_DATA_MATROSKA_BLOCKADDITIONAL(74),
        AV_PKT_DATA_WEBVTT_IDENTIFIER(75),
        AV_PKT_DATA_WEBVTT_SETTINGS(76),
        AV_PKT_DATA_METADATA_UPDATE(77);
        AVPacketSideDataType(long value) {
            this.value = value;
        }
        public final long value;
        public long value() {
            return this.value;
        }
        public Iterator<AVPacketSideDataType > iterator() {
            return Collections.singleton(this).iterator();
        }
        public static IntValuedEnum<AVPacketSideDataType > fromValue(int value) {
            return FlagSet.fromValue(value, values());
        }
    };
    /**
     * enum values<br>
     * <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h:592</i>
     */
    public enum AVSideDataParamChangeFlags implements IntValuedEnum<AVSideDataParamChangeFlags > {
        AV_SIDE_DATA_PARAM_CHANGE_CHANNEL_COUNT(0x0001),
        AV_SIDE_DATA_PARAM_CHANGE_CHANNEL_LAYOUT(0x0002),
        AV_SIDE_DATA_PARAM_CHANGE_SAMPLE_RATE(0x0004),
        AV_SIDE_DATA_PARAM_CHANGE_DIMENSIONS(0x0008);
        AVSideDataParamChangeFlags(long value) {
            this.value = value;
        }
        public final long value;
        public long value() {
            return this.value;
        }
        public Iterator<AVSideDataParamChangeFlags > iterator() {
            return Collections.singleton(this).iterator();
        }
        public static IntValuedEnum<AVSideDataParamChangeFlags > fromValue(int value) {
            return FlagSet.fromValue(value, values());
        }
    };
    /**
     * enum values<br>
     * <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h:606</i>
     */
    public enum AVFieldOrder implements IntValuedEnum<AVFieldOrder > {
        AV_FIELD_UNKNOWN(0),
        AV_FIELD_PROGRESSIVE(1),
        /** < Top coded_first, top displayed first */
        AV_FIELD_TT(2),
        /** < Bottom coded first, bottom displayed first */
        AV_FIELD_BB(3),
        /** < Top coded first, bottom displayed first */
        AV_FIELD_TB(4),
        /** < Bottom coded first, top displayed first */
        AV_FIELD_BT(5);
        AVFieldOrder(long value) {
            this.value = value;
        }
        public final long value;
        public long value() {
            return this.value;
        }
        public Iterator<AVFieldOrder > iterator() {
            return Collections.singleton(this).iterator();
        }
        public static IntValuedEnum<AVFieldOrder > fromValue(int value) {
            return FlagSet.fromValue(value, values());
        }
    };
    /**
     * @}<br>
     * enum values<br>
     * <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h:1011</i>
     */
    public enum AVSubtitleType implements IntValuedEnum<AVSubtitleType > {
        SUBTITLE_NONE(0),
        /** < A bitmap, pict will be set */
        SUBTITLE_BITMAP(1),
        SUBTITLE_TEXT(2),
        SUBTITLE_ASS(3);
        AVSubtitleType(long value) {
            this.value = value;
        }
        public final long value;
        public long value() {
            return this.value;
        }
        public Iterator<AVSubtitleType > iterator() {
            return Collections.singleton(this).iterator();
        }
        public static IntValuedEnum<AVSubtitleType > fromValue(int value) {
            return FlagSet.fromValue(value, values());
        }
    };
    /**
     * @defgroup lavc_parsing Frame parsing<br>
     * @{<br>
     * enum values<br>
     * <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h:1561</i>
     */
    public enum AVPictureStructure implements IntValuedEnum<AVPictureStructure > {
        /** < unknown */
        AV_PICTURE_STRUCTURE_UNKNOWN(0),
        /** < coded as top field */
        AV_PICTURE_STRUCTURE_TOP_FIELD(1),
        /** < coded as bottom field */
        AV_PICTURE_STRUCTURE_BOTTOM_FIELD(2),
        /** < coded as frame */
        AV_PICTURE_STRUCTURE_FRAME(3);
        AVPictureStructure(long value) {
            this.value = value;
        }
        public final long value;
        public long value() {
            return this.value;
        }
        public Iterator<AVPictureStructure > iterator() {
            return Collections.singleton(this).iterator();
        }
        public static IntValuedEnum<AVPictureStructure > fromValue(int value) {
            return FlagSet.fromValue(value, values());
        }
    };
    /**
     * Lock operation used by lockmgr<br>
     * enum values<br>
     * <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h:2196</i>
     */
    public enum AVLockOp implements IntValuedEnum<AVLockOp > {
        /** < Create a mutex */
        AV_LOCK_CREATE(0),
        /** < Lock the mutex */
        AV_LOCK_OBTAIN(1),
        /** < Unlock the mutex */
        AV_LOCK_RELEASE(2),
        /** < Free mutex resources */
        AV_LOCK_DESTROY(3);
        AVLockOp(long value) {
            this.value = value;
        }
        public final long value;
        public long value() {
            return this.value;
        }
        public Iterator<AVLockOp > iterator() {
            return Collections.singleton(this).iterator();
        }
        public static IntValuedEnum<AVLockOp > fromValue(int value) {
            return FlagSet.fromValue(value, values());
        }
    };
    public static final int kVDADecodeInfo_Asynchronous = 1 << 0;
    public static final int kVDADecodeInfo_FrameDropped = 1 << 1;
    /**
     * Conversion Error : a.num<br>
     * SKIPPED:<br>
     * <i>native declaration : ffmpeg_build/include/libavutil/rational.h:0</i><br>
     * const int64_t tmp = a.num * (int64_t)b.den - b.num * (int64_t)a.den;
     */
    /** <i>native declaration : ffmpeg_build/include/libavcodec/version.h</i> */
    public static final int LIBAVCODEC_VERSION_MAJOR = (int)57;
    /** <i>native declaration : ffmpeg_build/include/libavcodec/version.h</i> */
    public static final int LIBAVCODEC_VERSION_MINOR = (int)7;
    /** <i>native declaration : ffmpeg_build/include/libavcodec/version.h</i> */
    public static final int LIBAVCODEC_VERSION_MICRO = (int)100;
    /** <i>native declaration : ffmpeg_build/include/libavcodec/version.h</i> */
    public static final int LIBAVCODEC_VERSION_INT = (int)((57) << 16 | (7) << 8 | (100));
    /**
     * define<br>
     * Conversion Error : 57.7.<br>
     * SKIPPED:<br>
     * <i>native declaration : ffmpeg_build/include/libavcodec/version.h:0</i><br>
     * 57.7.
     */
    /** <i>native declaration : ffmpeg_build/include/libavcodec/version.h</i> */
    public static final int LIBAVCODEC_BUILD = (int)((57) << 16 | (7) << 8 | (100));
    /** <i>native declaration : ffmpeg_build/include/libavcodec/version.h</i> */
    public static final String LIBAVCODEC_IDENT = (String)"Lavc";
    /** <i>native declaration : ffmpeg_build/include/libavcodec/version.h</i> */
    public static final boolean FF_API_VIMA_DECODER = (boolean)(57 < 58);
    /** <i>native declaration : ffmpeg_build/include/libavcodec/version.h</i> */
    public static final boolean FF_API_AUDIO_CONVERT = (boolean)(57 < 58);
    /** <i>native declaration : ffmpeg_build/include/libavcodec/version.h</i> */
    public static final boolean FF_API_AVCODEC_RESAMPLE = (boolean)(57 < 58);
    /** <i>native declaration : ffmpeg_build/include/libavcodec/version.h</i> */
    public static final boolean FF_API_MISSING_SAMPLE = (boolean)(57 < 58);
    /** <i>native declaration : ffmpeg_build/include/libavcodec/version.h</i> */
    public static final boolean FF_API_LOWRES = (boolean)(57 < 58);
    /** <i>native declaration : ffmpeg_build/include/libavcodec/version.h</i> */
    public static final boolean FF_API_CAP_VDPAU = (boolean)(57 < 58);
    /** <i>native declaration : ffmpeg_build/include/libavcodec/version.h</i> */
    public static final boolean FF_API_BUFS_VDPAU = (boolean)(57 < 58);
    /** <i>native declaration : ffmpeg_build/include/libavcodec/version.h</i> */
    public static final boolean FF_API_VOXWARE = (boolean)(57 < 58);
    /** <i>native declaration : ffmpeg_build/include/libavcodec/version.h</i> */
    public static final boolean FF_API_SET_DIMENSIONS = (boolean)(57 < 58);
    /** <i>native declaration : ffmpeg_build/include/libavcodec/version.h</i> */
    public static final boolean FF_API_DEBUG_MV = (boolean)(57 < 58);
    /** <i>native declaration : ffmpeg_build/include/libavcodec/version.h</i> */
    public static final boolean FF_API_AC_VLC = (boolean)(57 < 58);
    /** <i>native declaration : ffmpeg_build/include/libavcodec/version.h</i> */
    public static final boolean FF_API_OLD_MSMPEG4 = (boolean)(57 < 58);
    /** <i>native declaration : ffmpeg_build/include/libavcodec/version.h</i> */
    public static final boolean FF_API_ASPECT_EXTENDED = (boolean)(57 < 58);
    /** <i>native declaration : ffmpeg_build/include/libavcodec/version.h</i> */
    public static final boolean FF_API_ARCH_ALPHA = (boolean)(57 < 58);
    /** <i>native declaration : ffmpeg_build/include/libavcodec/version.h</i> */
    public static final boolean FF_API_ERROR_RATE = (boolean)(57 < 58);
    /** <i>native declaration : ffmpeg_build/include/libavcodec/version.h</i> */
    public static final boolean FF_API_QSCALE_TYPE = (boolean)(57 < 58);
    /** <i>native declaration : ffmpeg_build/include/libavcodec/version.h</i> */
    public static final boolean FF_API_MB_TYPE = (boolean)(57 < 58);
    /** <i>native declaration : ffmpeg_build/include/libavcodec/version.h</i> */
    public static final boolean FF_API_MAX_BFRAMES = (boolean)(57 < 58);
    /** <i>native declaration : ffmpeg_build/include/libavcodec/version.h</i> */
    public static final boolean FF_API_NEG_LINESIZES = (boolean)(57 < 58);
    /** <i>native declaration : ffmpeg_build/include/libavcodec/version.h</i> */
    public static final boolean FF_API_EMU_EDGE = (boolean)(57 < 58);
    /** <i>native declaration : ffmpeg_build/include/libavcodec/version.h</i> */
    public static final boolean FF_API_ARCH_SH4 = (boolean)(57 < 58);
    /** <i>native declaration : ffmpeg_build/include/libavcodec/version.h</i> */
    public static final boolean FF_API_ARCH_SPARC = (boolean)(57 < 58);
    /** <i>native declaration : ffmpeg_build/include/libavcodec/version.h</i> */
    public static final boolean FF_API_UNUSED_MEMBERS = (boolean)(57 < 58);
    /** <i>native declaration : ffmpeg_build/include/libavcodec/version.h</i> */
    public static final boolean FF_API_IDCT_XVIDMMX = (boolean)(57 < 58);
    /** <i>native declaration : ffmpeg_build/include/libavcodec/version.h</i> */
    public static final boolean FF_API_INPUT_PRESERVED = (boolean)(57 < 58);
    /** <i>native declaration : ffmpeg_build/include/libavcodec/version.h</i> */
    public static final boolean FF_API_NORMALIZE_AQP = (boolean)(57 < 58);
    /** <i>native declaration : ffmpeg_build/include/libavcodec/version.h</i> */
    public static final boolean FF_API_GMC = (boolean)(57 < 58);
    /** <i>native declaration : ffmpeg_build/include/libavcodec/version.h</i> */
    public static final boolean FF_API_MV0 = (boolean)(57 < 58);
    /** <i>native declaration : ffmpeg_build/include/libavcodec/version.h</i> */
    public static final boolean FF_API_CODEC_NAME = (boolean)(57 < 58);
    /** <i>native declaration : ffmpeg_build/include/libavcodec/version.h</i> */
    public static final boolean FF_API_AFD = (boolean)(57 < 58);
    /** <i>native declaration : ffmpeg_build/include/libavcodec/version.h</i> */
    public static final boolean FF_API_VISMV = (boolean)(57 < 58);
    /** <i>native declaration : ffmpeg_build/include/libavcodec/version.h</i> */
    public static final boolean FF_API_AUDIOENC_DELAY = (boolean)(57 < 58);
    /** <i>native declaration : ffmpeg_build/include/libavcodec/version.h</i> */
    public static final boolean FF_API_VAAPI_CONTEXT = (boolean)(57 < 58);
    /** <i>native declaration : ffmpeg_build/include/libavcodec/version.h</i> */
    public static final boolean FF_API_AVCTX_TIMEBASE = (boolean)(57 < 59);
    /** <i>native declaration : ffmpeg_build/include/libavcodec/version.h</i> */
    public static final boolean FF_API_MPV_OPT = (boolean)(57 < 59);
    /** <i>native declaration : ffmpeg_build/include/libavcodec/version.h</i> */
    public static final boolean FF_API_STREAM_CODEC_TAG = (boolean)(57 < 59);
    /** <i>native declaration : ffmpeg_build/include/libavcodec/version.h</i> */
    public static final boolean FF_API_QUANT_BIAS = (boolean)(57 < 59);
    /** <i>native declaration : ffmpeg_build/include/libavcodec/version.h</i> */
    public static final boolean FF_API_RC_STRATEGY = (boolean)(57 < 59);
    /** <i>native declaration : ffmpeg_build/include/libavcodec/version.h</i> */
    public static final boolean FF_API_CODED_FRAME = (boolean)(57 < 59);
    /** <i>native declaration : ffmpeg_build/include/libavcodec/version.h</i> */
    public static final boolean FF_API_MOTION_EST = (boolean)(57 < 59);
    /** <i>native declaration : ffmpeg_build/include/libavcodec/version.h</i> */
    public static final boolean FF_API_WITHOUT_PREFIX = (boolean)(57 < 59);
    /** <i>native declaration : ffmpeg_build/include/libavcodec/version.h</i> */
    public static final boolean FF_API_SIDEDATA_ONLY_PKT = (boolean)(57 < 59);
    /** <i>native declaration : ffmpeg_build/include/libavcodec/version.h</i> */
    public static final boolean FF_API_VDPAU_PROFILE = (boolean)(57 < 59);
    /** <i>native declaration : ffmpeg_build/include/libavcodec/version.h</i> */
    public static final boolean FF_API_CONVERGENCE_DURATION = (boolean)(57 < 59);
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int AV_CODEC_PROP_INTRA_ONLY = (int)(1 << 0);
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int AV_CODEC_PROP_LOSSY = (int)(1 << 1);
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int AV_CODEC_PROP_LOSSLESS = (int)(1 << 2);
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int AV_CODEC_PROP_REORDER = (int)(1 << 3);
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int AV_CODEC_PROP_BITMAP_SUB = (int)(1 << 16);
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int AV_CODEC_PROP_TEXT_SUB = (int)(1 << 17);
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int AV_INPUT_BUFFER_PADDING_SIZE = (int)32;
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int AV_INPUT_BUFFER_MIN_SIZE = (int)16384;
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int FF_INPUT_BUFFER_PADDING_SIZE = (int)32;
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int FF_MIN_BUFFER_SIZE = (int)16384;
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int FF_MAX_B_FRAMES = (int)16;
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int AV_CODEC_FLAG_UNALIGNED = (int)(1 << 0);
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int AV_CODEC_FLAG_QSCALE = (int)(1 << 1);
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int AV_CODEC_FLAG_4MV = (int)(1 << 2);
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int AV_CODEC_FLAG_OUTPUT_CORRUPT = (int)(1 << 3);
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int AV_CODEC_FLAG_QPEL = (int)(1 << 4);
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int AV_CODEC_FLAG_PASS1 = (int)(1 << 9);
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int AV_CODEC_FLAG_PASS2 = (int)(1 << 10);
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int AV_CODEC_FLAG_LOOP_FILTER = (int)(1 << 11);
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int AV_CODEC_FLAG_GRAY = (int)(1 << 13);
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int AV_CODEC_FLAG_PSNR = (int)(1 << 15);
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int AV_CODEC_FLAG_TRUNCATED = (int)(1 << 16);
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int AV_CODEC_FLAG_INTERLACED_DCT = (int)(1 << 18);
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int AV_CODEC_FLAG_LOW_DELAY = (int)(1 << 19);
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int AV_CODEC_FLAG_GLOBAL_HEADER = (int)(1 << 22);
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int AV_CODEC_FLAG_BITEXACT = (int)(1 << 23);
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int AV_CODEC_FLAG_AC_PRED = (int)(1 << 24);
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int AV_CODEC_FLAG_INTERLACED_ME = (int)(1 << 29);
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int AV_CODEC_FLAG_CLOSED_GOP = (int)(1 << 31);
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int AV_CODEC_FLAG2_FAST = (int)(1 << 0);
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int AV_CODEC_FLAG2_NO_OUTPUT = (int)(1 << 2);
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int AV_CODEC_FLAG2_LOCAL_HEADER = (int)(1 << 3);
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int AV_CODEC_FLAG2_DROP_FRAME_TIMECODE = (int)(1 << 13);
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int AV_CODEC_FLAG2_CHUNKS = (int)(1 << 15);
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int AV_CODEC_FLAG2_IGNORE_CROP = (int)(1 << 16);
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int AV_CODEC_FLAG2_SHOW_ALL = (int)(1 << 22);
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int AV_CODEC_FLAG2_EXPORT_MVS = (int)(1 << 28);
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int AV_CODEC_FLAG2_SKIP_MANUAL = (int)(1 << 29);
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int AV_CODEC_CAP_DRAW_HORIZ_BAND = (int)(1 << 0);
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int AV_CODEC_CAP_DR1 = (int)(1 << 1);
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int AV_CODEC_CAP_TRUNCATED = (int)(1 << 3);
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int AV_CODEC_CAP_DELAY = (int)(1 << 5);
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int AV_CODEC_CAP_SMALL_LAST_FRAME = (int)(1 << 6);
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int AV_CODEC_CAP_HWACCEL_VDPAU = (int)(1 << 7);
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int AV_CODEC_CAP_SUBFRAMES = (int)(1 << 8);
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int AV_CODEC_CAP_EXPERIMENTAL = (int)(1 << 9);
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int AV_CODEC_CAP_CHANNEL_CONF = (int)(1 << 10);
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int AV_CODEC_CAP_FRAME_THREADS = (int)(1 << 12);
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int AV_CODEC_CAP_SLICE_THREADS = (int)(1 << 13);
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int AV_CODEC_CAP_PARAM_CHANGE = (int)(1 << 14);
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int AV_CODEC_CAP_AUTO_THREADS = (int)(1 << 15);
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int AV_CODEC_CAP_VARIABLE_FRAME_SIZE = (int)(1 << 16);
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int AV_CODEC_CAP_INTRA_ONLY = (int)0x40000000;
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int AV_CODEC_CAP_LOSSLESS = (int)0x80000000;
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int CODEC_FLAG_UNALIGNED = (int)(1 << 0);
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int CODEC_FLAG_QSCALE = (int)(1 << 1);
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int CODEC_FLAG_4MV = (int)(1 << 2);
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int CODEC_FLAG_OUTPUT_CORRUPT = (int)(1 << 3);
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int CODEC_FLAG_QPEL = (int)(1 << 4);
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int CODEC_FLAG_GMC = (int)0x0020;
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int CODEC_FLAG_MV0 = (int)0x0040;
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int CODEC_FLAG_INPUT_PRESERVED = (int)0x0100;
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int CODEC_FLAG_PASS1 = (int)(1 << 9);
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int CODEC_FLAG_PASS2 = (int)(1 << 10);
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int CODEC_FLAG_GRAY = (int)(1 << 13);
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int CODEC_FLAG_EMU_EDGE = (int)0x4000;
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int CODEC_FLAG_PSNR = (int)(1 << 15);
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int CODEC_FLAG_TRUNCATED = (int)(1 << 16);
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int CODEC_FLAG_NORMALIZE_AQP = (int)0x00020000;
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int CODEC_FLAG_INTERLACED_DCT = (int)(1 << 18);
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int CODEC_FLAG_LOW_DELAY = (int)(1 << 19);
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int CODEC_FLAG_GLOBAL_HEADER = (int)(1 << 22);
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int CODEC_FLAG_BITEXACT = (int)(1 << 23);
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int CODEC_FLAG_AC_PRED = (int)(1 << 24);
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int CODEC_FLAG_LOOP_FILTER = (int)(1 << 11);
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int CODEC_FLAG_INTERLACED_ME = (int)(1 << 29);
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int CODEC_FLAG_CLOSED_GOP = (int)(1 << 31);
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int CODEC_FLAG2_FAST = (int)(1 << 0);
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int CODEC_FLAG2_NO_OUTPUT = (int)(1 << 2);
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int CODEC_FLAG2_LOCAL_HEADER = (int)(1 << 3);
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int CODEC_FLAG2_DROP_FRAME_TIMECODE = (int)(1 << 13);
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int CODEC_FLAG2_IGNORE_CROP = (int)(1 << 16);
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int CODEC_FLAG2_CHUNKS = (int)(1 << 15);
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int CODEC_FLAG2_SHOW_ALL = (int)(1 << 22);
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int CODEC_FLAG2_EXPORT_MVS = (int)(1 << 28);
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int CODEC_FLAG2_SKIP_MANUAL = (int)(1 << 29);
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int CODEC_CAP_DRAW_HORIZ_BAND = (int)(1 << 0);
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int CODEC_CAP_DR1 = (int)(1 << 1);
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int CODEC_CAP_TRUNCATED = (int)(1 << 3);
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int CODEC_CAP_HWACCEL = (int)0x0010;
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int CODEC_CAP_DELAY = (int)(1 << 5);
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int CODEC_CAP_SMALL_LAST_FRAME = (int)(1 << 6);
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int CODEC_CAP_HWACCEL_VDPAU = (int)(1 << 7);
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int CODEC_CAP_SUBFRAMES = (int)(1 << 8);
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int CODEC_CAP_EXPERIMENTAL = (int)(1 << 9);
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int CODEC_CAP_CHANNEL_CONF = (int)(1 << 10);
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int CODEC_CAP_NEG_LINESIZES = (int)0x0800;
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int CODEC_CAP_FRAME_THREADS = (int)(1 << 12);
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int CODEC_CAP_SLICE_THREADS = (int)(1 << 13);
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int CODEC_CAP_PARAM_CHANGE = (int)(1 << 14);
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int CODEC_CAP_AUTO_THREADS = (int)(1 << 15);
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int CODEC_CAP_VARIABLE_FRAME_SIZE = (int)(1 << 16);
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int CODEC_CAP_INTRA_ONLY = (int)0x40000000;
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int CODEC_CAP_LOSSLESS = (int)0x80000000;
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int HWACCEL_CODEC_CAP_EXPERIMENTAL = (int)0x0200;
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int MB_TYPE_INTRA4x4 = (int)0x0001;
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int MB_TYPE_INTRA16x16 = (int)0x0002;
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int MB_TYPE_INTRA_PCM = (int)0x0004;
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int MB_TYPE_16x16 = (int)0x0008;
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int MB_TYPE_16x8 = (int)0x0010;
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int MB_TYPE_8x16 = (int)0x0020;
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int MB_TYPE_8x8 = (int)0x0040;
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int MB_TYPE_INTERLACED = (int)0x0080;
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int MB_TYPE_DIRECT2 = (int)0x0100;
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int MB_TYPE_ACPRED = (int)0x0200;
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int MB_TYPE_GMC = (int)0x0400;
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int MB_TYPE_SKIP = (int)0x0800;
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int MB_TYPE_P0L0 = (int)0x1000;
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int MB_TYPE_P1L0 = (int)0x2000;
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int MB_TYPE_P0L1 = (int)0x4000;
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int MB_TYPE_P1L1 = (int)0x8000;
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int MB_TYPE_L0 = (int)(0x1000 | 0x2000);
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int MB_TYPE_L1 = (int)(0x4000 | 0x8000);
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int MB_TYPE_L0L1 = (int)((0x1000 | 0x2000) | (0x4000 | 0x8000));
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int MB_TYPE_QUANT = (int)0x00010000;
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int MB_TYPE_CBP = (int)0x00020000;
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int FF_QSCALE_TYPE_MPEG1 = (int)0;
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int FF_QSCALE_TYPE_MPEG2 = (int)1;
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int FF_QSCALE_TYPE_H264 = (int)2;
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int FF_QSCALE_TYPE_VP56 = (int)3;
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int AV_GET_BUFFER_FLAG_REF = (int)(1 << 0);
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int AV_PKT_FLAG_KEY = (int)0x0001;
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int AV_PKT_FLAG_CORRUPT = (int)0x0002;
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int FF_COMPRESSION_DEFAULT = (int)-1;
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int FF_ASPECT_EXTENDED = (int)15;
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int FF_RC_STRATEGY_XVID = (int)1;
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int FF_PRED_LEFT = (int)0;
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int FF_PRED_PLANE = (int)1;
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int FF_PRED_MEDIAN = (int)2;
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int FF_CMP_SAD = (int)0;
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int FF_CMP_SSE = (int)1;
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int FF_CMP_SATD = (int)2;
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int FF_CMP_DCT = (int)3;
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int FF_CMP_PSNR = (int)4;
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int FF_CMP_BIT = (int)5;
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int FF_CMP_RD = (int)6;
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int FF_CMP_ZERO = (int)7;
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int FF_CMP_VSAD = (int)8;
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int FF_CMP_VSSE = (int)9;
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int FF_CMP_NSSE = (int)10;
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int FF_CMP_W53 = (int)11;
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int FF_CMP_W97 = (int)12;
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int FF_CMP_DCTMAX = (int)13;
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int FF_CMP_DCT264 = (int)14;
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int FF_CMP_CHROMA = (int)256;
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int FF_DTG_AFD_SAME = (int)8;
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int FF_DTG_AFD_4_3 = (int)9;
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int FF_DTG_AFD_16_9 = (int)10;
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int FF_DTG_AFD_14_9 = (int)11;
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int FF_DTG_AFD_4_3_SP_14_9 = (int)13;
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int FF_DTG_AFD_16_9_SP_14_9 = (int)14;
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int FF_DTG_AFD_SP_4_3 = (int)15;
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int FF_DEFAULT_QUANT_BIAS = (int)999999;
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int SLICE_FLAG_CODED_ORDER = (int)0x0001;
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int SLICE_FLAG_ALLOW_FIELD = (int)0x0002;
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int SLICE_FLAG_ALLOW_PLANE = (int)0x0004;
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int FF_MB_DECISION_SIMPLE = (int)0;
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int FF_MB_DECISION_BITS = (int)1;
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int FF_MB_DECISION_RD = (int)2;
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int FF_CODER_TYPE_VLC = (int)0;
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int FF_CODER_TYPE_AC = (int)1;
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int FF_CODER_TYPE_RAW = (int)2;
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int FF_CODER_TYPE_RLE = (int)3;
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int FF_CODER_TYPE_DEFLATE = (int)4;
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int FF_BUG_AUTODETECT = (int)1;
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int FF_BUG_OLD_MSMPEG4 = (int)2;
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int FF_BUG_XVID_ILACE = (int)4;
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int FF_BUG_UMP4 = (int)8;
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int FF_BUG_NO_PADDING = (int)16;
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int FF_BUG_AMV = (int)32;
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int FF_BUG_AC_VLC = (int)0;
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int FF_BUG_QPEL_CHROMA = (int)64;
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int FF_BUG_STD_QPEL = (int)128;
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int FF_BUG_QPEL_CHROMA2 = (int)256;
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int FF_BUG_DIRECT_BLOCKSIZE = (int)512;
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int FF_BUG_EDGE = (int)1024;
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int FF_BUG_HPEL_CHROMA = (int)2048;
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int FF_BUG_DC_CLIP = (int)4096;
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int FF_BUG_MS = (int)8192;
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int FF_BUG_TRUNCATED = (int)16384;
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int FF_COMPLIANCE_VERY_STRICT = (int)2;
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int FF_COMPLIANCE_STRICT = (int)1;
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int FF_COMPLIANCE_NORMAL = (int)0;
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int FF_COMPLIANCE_UNOFFICIAL = (int)-1;
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int FF_COMPLIANCE_EXPERIMENTAL = (int)-2;
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int FF_EC_GUESS_MVS = (int)1;
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int FF_EC_DEBLOCK = (int)2;
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int FF_EC_FAVOR_INTER = (int)256;
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int FF_DEBUG_PICT_INFO = (int)1;
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int FF_DEBUG_RC = (int)2;
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int FF_DEBUG_BITSTREAM = (int)4;
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int FF_DEBUG_MB_TYPE = (int)8;
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int FF_DEBUG_QP = (int)16;
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int FF_DEBUG_MV = (int)32;
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int FF_DEBUG_DCT_COEFF = (int)0x00000040;
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int FF_DEBUG_SKIP = (int)0x00000080;
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int FF_DEBUG_STARTCODE = (int)0x00000100;
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int FF_DEBUG_PTS = (int)0x00000200;
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int FF_DEBUG_ER = (int)0x00000400;
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int FF_DEBUG_MMCO = (int)0x00000800;
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int FF_DEBUG_BUGS = (int)0x00001000;
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int FF_DEBUG_VIS_QP = (int)0x00002000;
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int FF_DEBUG_VIS_MB_TYPE = (int)0x00004000;
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int FF_DEBUG_BUFFERS = (int)0x00008000;
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int FF_DEBUG_THREADS = (int)0x00010000;
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int FF_DEBUG_GREEN_MD = (int)0x00800000;
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int FF_DEBUG_NOMC = (int)0x01000000;
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int FF_DEBUG_VIS_MV_P_FOR = (int)0x00000001;
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int FF_DEBUG_VIS_MV_B_FOR = (int)0x00000002;
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int FF_DEBUG_VIS_MV_B_BACK = (int)0x00000004;
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int AV_EF_CRCCHECK = (int)(1 << 0);
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int AV_EF_BITSTREAM = (int)(1 << 1);
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int AV_EF_BUFFER = (int)(1 << 2);
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int AV_EF_EXPLODE = (int)(1 << 3);
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int AV_EF_IGNORE_ERR = (int)(1 << 15);
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int AV_EF_CAREFUL = (int)(1 << 16);
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int AV_EF_COMPLIANT = (int)(1 << 17);
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int AV_EF_AGGRESSIVE = (int)(1 << 18);
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int FF_DCT_AUTO = (int)0;
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int FF_DCT_FASTINT = (int)1;
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int FF_DCT_INT = (int)2;
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int FF_DCT_MMX = (int)3;
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int FF_DCT_ALTIVEC = (int)5;
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int FF_DCT_FAAN = (int)6;
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int FF_IDCT_AUTO = (int)0;
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int FF_IDCT_INT = (int)1;
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int FF_IDCT_SIMPLE = (int)2;
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int FF_IDCT_SIMPLEMMX = (int)3;
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int FF_IDCT_ARM = (int)7;
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int FF_IDCT_ALTIVEC = (int)8;
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int FF_IDCT_SH4 = (int)9;
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int FF_IDCT_SIMPLEARM = (int)10;
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int FF_IDCT_IPP = (int)13;
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int FF_IDCT_XVID = (int)14;
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int FF_IDCT_XVIDMMX = (int)14;
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int FF_IDCT_SIMPLEARMV5TE = (int)16;
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int FF_IDCT_SIMPLEARMV6 = (int)17;
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int FF_IDCT_SIMPLEVIS = (int)18;
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int FF_IDCT_FAAN = (int)20;
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int FF_IDCT_SIMPLENEON = (int)22;
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int FF_IDCT_SIMPLEALPHA = (int)23;
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int FF_IDCT_SIMPLEAUTO = (int)128;
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int FF_THREAD_FRAME = (int)1;
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int FF_THREAD_SLICE = (int)2;
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int FF_PROFILE_UNKNOWN = (int)-99;
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int FF_PROFILE_RESERVED = (int)-100;
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int FF_PROFILE_AAC_MAIN = (int)0;
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int FF_PROFILE_AAC_LOW = (int)1;
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int FF_PROFILE_AAC_SSR = (int)2;
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int FF_PROFILE_AAC_LTP = (int)3;
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int FF_PROFILE_AAC_HE = (int)4;
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int FF_PROFILE_AAC_HE_V2 = (int)28;
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int FF_PROFILE_AAC_LD = (int)22;
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int FF_PROFILE_AAC_ELD = (int)38;
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int FF_PROFILE_MPEG2_AAC_LOW = (int)128;
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int FF_PROFILE_MPEG2_AAC_HE = (int)131;
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int FF_PROFILE_DTS = (int)20;
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int FF_PROFILE_DTS_ES = (int)30;
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int FF_PROFILE_DTS_96_24 = (int)40;
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int FF_PROFILE_DTS_HD_HRA = (int)50;
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int FF_PROFILE_DTS_HD_MA = (int)60;
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int FF_PROFILE_DTS_EXPRESS = (int)70;
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int FF_PROFILE_MPEG2_422 = (int)0;
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int FF_PROFILE_MPEG2_HIGH = (int)1;
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int FF_PROFILE_MPEG2_SS = (int)2;
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int FF_PROFILE_MPEG2_SNR_SCALABLE = (int)3;
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int FF_PROFILE_MPEG2_MAIN = (int)4;
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int FF_PROFILE_MPEG2_SIMPLE = (int)5;
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int FF_PROFILE_H264_CONSTRAINED = (int)(1 << 9);
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int FF_PROFILE_H264_INTRA = (int)(1 << 11);
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int FF_PROFILE_H264_BASELINE = (int)66;
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int FF_PROFILE_H264_CONSTRAINED_BASELINE = (int)(66 | (1 << 9));
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int FF_PROFILE_H264_MAIN = (int)77;
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int FF_PROFILE_H264_EXTENDED = (int)88;
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int FF_PROFILE_H264_HIGH = (int)100;
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int FF_PROFILE_H264_HIGH_10 = (int)110;
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int FF_PROFILE_H264_HIGH_10_INTRA = (int)(110 | (1 << 11));
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int FF_PROFILE_H264_HIGH_422 = (int)122;
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int FF_PROFILE_H264_HIGH_422_INTRA = (int)(122 | (1 << 11));
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int FF_PROFILE_H264_HIGH_444 = (int)144;
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int FF_PROFILE_H264_HIGH_444_PREDICTIVE = (int)244;
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int FF_PROFILE_H264_HIGH_444_INTRA = (int)(244 | (1 << 11));
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int FF_PROFILE_H264_CAVLC_444 = (int)44;
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int FF_PROFILE_VC1_SIMPLE = (int)0;
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int FF_PROFILE_VC1_MAIN = (int)1;
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int FF_PROFILE_VC1_COMPLEX = (int)2;
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int FF_PROFILE_VC1_ADVANCED = (int)3;
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int FF_PROFILE_MPEG4_SIMPLE = (int)0;
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int FF_PROFILE_MPEG4_SIMPLE_SCALABLE = (int)1;
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int FF_PROFILE_MPEG4_CORE = (int)2;
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int FF_PROFILE_MPEG4_MAIN = (int)3;
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int FF_PROFILE_MPEG4_N_BIT = (int)4;
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int FF_PROFILE_MPEG4_SCALABLE_TEXTURE = (int)5;
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int FF_PROFILE_MPEG4_SIMPLE_FACE_ANIMATION = (int)6;
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int FF_PROFILE_MPEG4_BASIC_ANIMATED_TEXTURE = (int)7;
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int FF_PROFILE_MPEG4_HYBRID = (int)8;
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int FF_PROFILE_MPEG4_ADVANCED_REAL_TIME = (int)9;
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int FF_PROFILE_MPEG4_CORE_SCALABLE = (int)10;
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int FF_PROFILE_MPEG4_ADVANCED_CODING = (int)11;
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int FF_PROFILE_MPEG4_ADVANCED_CORE = (int)12;
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int FF_PROFILE_MPEG4_ADVANCED_SCALABLE_TEXTURE = (int)13;
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int FF_PROFILE_MPEG4_SIMPLE_STUDIO = (int)14;
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int FF_PROFILE_MPEG4_ADVANCED_SIMPLE = (int)15;
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int FF_PROFILE_JPEG2000_CSTREAM_RESTRICTION_0 = (int)0;
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int FF_PROFILE_JPEG2000_CSTREAM_RESTRICTION_1 = (int)1;
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int FF_PROFILE_JPEG2000_CSTREAM_NO_RESTRICTION = (int)2;
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int FF_PROFILE_JPEG2000_DCINEMA_2K = (int)3;
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int FF_PROFILE_JPEG2000_DCINEMA_4K = (int)4;
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int FF_PROFILE_VP9_0 = (int)0;
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int FF_PROFILE_VP9_1 = (int)1;
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int FF_PROFILE_VP9_2 = (int)2;
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int FF_PROFILE_VP9_3 = (int)3;
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int FF_PROFILE_HEVC_MAIN = (int)1;
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int FF_PROFILE_HEVC_MAIN_10 = (int)2;
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int FF_PROFILE_HEVC_MAIN_STILL_PICTURE = (int)3;
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int FF_PROFILE_HEVC_REXT = (int)4;
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int FF_LEVEL_UNKNOWN = (int)-99;
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int FF_SUB_CHARENC_MODE_DO_NOTHING = (int)-1;
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int FF_SUB_CHARENC_MODE_AUTOMATIC = (int)0;
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int FF_SUB_CHARENC_MODE_PRE_DECODER = (int)1;
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int FF_CODEC_PROPERTY_LOSSLESS = (int)0x00000001;
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int FF_CODEC_PROPERTY_CLOSED_CAPTIONS = (int)0x00000002;
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int AV_HWACCEL_FLAG_IGNORE_LEVEL = (int)(1 << 0);
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int AV_HWACCEL_FLAG_ALLOW_HIGH_DEPTH = (int)(1 << 1);
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int AV_SUBTITLE_FLAG_FORCED = (int)0x00000001;
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int AV_PARSER_PTS_NB = (int)4;
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int PARSER_FLAG_COMPLETE_FRAMES = (int)0x0001;
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int PARSER_FLAG_ONCE = (int)0x0002;
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int PARSER_FLAG_FETCHED_OFFSET = (int)0x0004;
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h</i> */
    public static final int PARSER_FLAG_USE_CODEC_TS = (int)0x1000;
    /** <i>native declaration : ffmpeg_build/include/libavcodec/vdpau.h</i> */
    public static final int FF_VDPAU_STATE_USED_FOR_RENDER = (int)1;
    /** <i>native declaration : ffmpeg_build/include/libavcodec/vdpau.h</i> */
    public static final int FF_VDPAU_STATE_USED_FOR_REFERENCE = (int)2;
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h:2334</i> */
    public static abstract class avcodec_default_execute_func_callback extends Callback<avcodec_default_execute_func_callback > {
        public int apply(Pointer<AVCodecContext > c2, Pointer<? > arg2) {
            return apply(Pointer.getPeer(c2), Pointer.getPeer(arg2));
        }
        public int apply(@Ptr long c2, @Ptr long arg2) {
            return apply((Pointer)Pointer.pointerToAddress(c2, AVCodecContext.class), Pointer.pointerToAddress(arg2));
        }
    };
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h:2335</i> */
    public static abstract class avcodec_default_execute2_func_callback extends Callback<avcodec_default_execute2_func_callback > {
        public int apply(Pointer<AVCodecContext > c2, Pointer<? > arg2, int int1, int int2) {
            return apply(Pointer.getPeer(c2), Pointer.getPeer(arg2), int1, int2);
        }
        public int apply(@Ptr long c2, @Ptr long arg2, int int1, int int2) {
            return apply((Pointer)Pointer.pointerToAddress(c2, AVCodecContext.class), Pointer.pointerToAddress(arg2), int1, int2);
        }
    };
    /** <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h:2348</i> */
    public static abstract class av_lockmgr_register_cb_callback extends Callback<av_lockmgr_register_cb_callback > {
        public int apply(Pointer<Pointer<? > > mutex, IntValuedEnum<AvcodecLibrary.AVLockOp > op) {
            return apply(Pointer.getPeer(mutex), (int)op.value());
        }
        public int apply(@Ptr long mutex, int op) {
            return apply((Pointer)Pointer.pointerToAddress(mutex, DefaultParameterizedType.paramType(Pointer.class, (Type)null)), FlagSet.fromValue(op, AvcodecLibrary.AVLockOp.class));
        }
    };
    /** <i>native declaration : ffmpeg_build/include/libavcodec/vdpau.h:8</i> */
    public static abstract class AVVDPAU_Render2 extends Callback<AVVDPAU_Render2 > {
        public int apply(Pointer<AVCodecContext > AVCodecContextPtr1, Pointer<AVFrame > AVFramePtr1, Pointer<Pointer<? > > VdpPictureInfoPtr1, int uint32_t1, Pointer VdpBitstreamBufferPtr1) {
            return apply(Pointer.getPeer(AVCodecContextPtr1), Pointer.getPeer(AVFramePtr1), Pointer.getPeer(VdpPictureInfoPtr1), uint32_t1, Pointer.getPeer(VdpBitstreamBufferPtr1));
        }
        public int apply(@Ptr long AVCodecContextPtr1, @Ptr long AVFramePtr1, @Ptr long VdpPictureInfoPtr1, int uint32_t1, @Ptr long VdpBitstreamBufferPtr1) {
            return apply((Pointer)Pointer.pointerToAddress(AVCodecContextPtr1, AVCodecContext.class), (Pointer)Pointer.pointerToAddress(AVFramePtr1, AVFrame.class), (Pointer)Pointer.pointerToAddress(VdpPictureInfoPtr1, DefaultParameterizedType.paramType(Pointer.class, (Type)null)), uint32_t1, Pointer.pointerToAddress(VdpBitstreamBufferPtr1));
        }
    };
    /**
     * Original signature : <code>AVRational av_codec_get_pkt_timebase(const AVCodecContext*)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h:873</i>
     */
    public AVRational av_codec_get_pkt_timebase(Pointer<AVCodecContext > avctx) {
        return av_codec_get_pkt_timebase(Pointer.getPeer(avctx));
    }
    protected native AVRational av_codec_get_pkt_timebase(@Ptr long avctx);
    /**
     * Original signature : <code>void av_codec_set_pkt_timebase(AVCodecContext*, AVRational)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h:875</i>
     */
    public void av_codec_set_pkt_timebase(Pointer<AVCodecContext > avctx, AVRational val) {
        av_codec_set_pkt_timebase(Pointer.getPeer(avctx), val);
    }
    protected native void av_codec_set_pkt_timebase(@Ptr long avctx, AVRational val);
    /**
     * Original signature : <code>AVCodecDescriptor* av_codec_get_codec_descriptor(const AVCodecContext*)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h:877</i>
     */
    public Pointer<AVCodecDescriptor > av_codec_get_codec_descriptor(Pointer<AVCodecContext > avctx) {
        return (Pointer)Pointer.pointerToAddress(av_codec_get_codec_descriptor(Pointer.getPeer(avctx)), AVCodecDescriptor.class);
    }
    @Ptr
    protected native long av_codec_get_codec_descriptor(@Ptr long avctx);
    /**
     * Original signature : <code>void av_codec_set_codec_descriptor(AVCodecContext*, const AVCodecDescriptor*)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h:879</i>
     */
    public void av_codec_set_codec_descriptor(Pointer<AVCodecContext > avctx, Pointer<AVCodecDescriptor > desc) {
        av_codec_set_codec_descriptor(Pointer.getPeer(avctx), Pointer.getPeer(desc));
    }
    protected native void av_codec_set_codec_descriptor(@Ptr long avctx, @Ptr long desc);
    /**
     * Original signature : <code>int av_codec_get_codec_properties(const AVCodecContext*)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h:881</i>
     */
    public int av_codec_get_codec_properties(Pointer<AVCodecContext > avctx) {
        return av_codec_get_codec_properties(Pointer.getPeer(avctx));
    }
    protected native int av_codec_get_codec_properties(@Ptr long avctx);
    /**
     * Original signature : <code>int av_codec_get_lowres(const AVCodecContext*)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h:883</i>
     */
    public int av_codec_get_lowres(Pointer<AVCodecContext > avctx) {
        return av_codec_get_lowres(Pointer.getPeer(avctx));
    }
    protected native int av_codec_get_lowres(@Ptr long avctx);
    /**
     * Original signature : <code>void av_codec_set_lowres(AVCodecContext*, int)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h:885</i>
     */
    public void av_codec_set_lowres(Pointer<AVCodecContext > avctx, int val) {
        av_codec_set_lowres(Pointer.getPeer(avctx), val);
    }
    protected native void av_codec_set_lowres(@Ptr long avctx, int val);
    /**
     * Original signature : <code>int av_codec_get_seek_preroll(const AVCodecContext*)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h:887</i>
     */
    public int av_codec_get_seek_preroll(Pointer<AVCodecContext > avctx) {
        return av_codec_get_seek_preroll(Pointer.getPeer(avctx));
    }
    protected native int av_codec_get_seek_preroll(@Ptr long avctx);
    /**
     * Original signature : <code>void av_codec_set_seek_preroll(AVCodecContext*, int)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h:889</i>
     */
    public void av_codec_set_seek_preroll(Pointer<AVCodecContext > avctx, int val) {
        av_codec_set_seek_preroll(Pointer.getPeer(avctx), val);
    }
    protected native void av_codec_set_seek_preroll(@Ptr long avctx, int val);
    /**
     * Original signature : <code>uint16_t* av_codec_get_chroma_intra_matrix(const AVCodecContext*)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h:891</i>
     */
    public Pointer<Short > av_codec_get_chroma_intra_matrix(Pointer<AVCodecContext > avctx) {
        return (Pointer)Pointer.pointerToAddress(av_codec_get_chroma_intra_matrix(Pointer.getPeer(avctx)), Short.class);
    }
    @Ptr
    protected native long av_codec_get_chroma_intra_matrix(@Ptr long avctx);
    /**
     * Original signature : <code>void av_codec_set_chroma_intra_matrix(AVCodecContext*, uint16_t*)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h:893</i>
     */
    public void av_codec_set_chroma_intra_matrix(Pointer<AVCodecContext > avctx, Pointer<Short > val) {
        av_codec_set_chroma_intra_matrix(Pointer.getPeer(avctx), Pointer.getPeer(val));
    }
    protected native void av_codec_set_chroma_intra_matrix(@Ptr long avctx, @Ptr long val);
    /**
     * Original signature : <code>int av_codec_get_max_lowres(const AVCodec*)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h:957</i>
     */
    public int av_codec_get_max_lowres(Pointer<AVCodec > codec) {
        return av_codec_get_max_lowres(Pointer.getPeer(codec));
    }
    protected native int av_codec_get_max_lowres(@Ptr long codec);
    /**
     * If c is NULL, returns the first registered codec,<br>
     * if c is non-NULL, returns the next registered codec after c,<br>
     * or NULL if c is the last one.<br>
     * Original signature : <code>AVCodec* av_codec_next(const AVCodec*)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h:1047</i>
     */
    public Pointer<AVCodec > av_codec_next(Pointer<AVCodec > c) {
        return (Pointer)Pointer.pointerToAddress(av_codec_next(Pointer.getPeer(c)), AVCodec.class);
    }
    @Ptr
    protected native long av_codec_next(@Ptr long c);
    /**
     * Return the LIBAVCODEC_VERSION_INT constant.<br>
     * Original signature : <code>int avcodec_version()</code><br>
     * <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h:1052</i>
     */
    public native int avcodec_version();
    /**
     * Return the libavcodec build-time configuration.<br>
     * Original signature : <code>char* avcodec_configuration()</code><br>
     * <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h:1057</i>
     */
    public Pointer<Byte > avcodec_configuration() {
        return (Pointer)Pointer.pointerToAddress(avcodec_configuration$2(), Byte.class);
    }
    @Ptr
    @Name("avcodec_configuration")
    protected native long avcodec_configuration$2();
    /**
     * Return the libavcodec license.<br>
     * Original signature : <code>char* avcodec_license()</code><br>
     * <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h:1062</i>
     */
    public Pointer<Byte > avcodec_license() {
        return (Pointer)Pointer.pointerToAddress(avcodec_license$2(), Byte.class);
    }
    @Ptr
    @Name("avcodec_license")
    protected native long avcodec_license$2();
    /**
     * Register the codec codec and initialize libavcodec.<br>
     * @warning either this function or avcodec_register_all() must be called<br>
     * before any other libavcodec functions.<br>
     * @see avcodec_register_all()<br>
     * Original signature : <code>void avcodec_register(AVCodec*)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h:1070</i>
     */
    public void avcodec_register(Pointer<AVCodec > codec) {
        avcodec_register(Pointer.getPeer(codec));
    }
    protected native void avcodec_register(@Ptr long codec);
    /**
     * Register all the codecs, parsers and bitstream filters which were enabled at<br>
     * configuration time. If you do not call this function you can select exactly<br>
     * which formats you want to support, by using the individual registration<br>
     * functions.<br>
     * @see avcodec_register<br>
     * @see av_register_codec_parser<br>
     * @see av_register_bitstream_filter<br>
     * Original signature : <code>void avcodec_register_all()</code><br>
     * <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h:1081</i>
     */
    public native void avcodec_register_all();
    /**
     * Allocate an AVCodecContext and set its fields to default values. The<br>
     * resulting struct should be freed with avcodec_free_context().<br>
     * @param codec if non-NULL, allocate private data and initialize defaults<br>
     *              for the given codec. It is illegal to then call avcodec_open2()<br>
     *              with a different codec.<br>
     *              If NULL, then the codec-specific defaults won't be initialized,<br>
     *              which may result in suboptimal default settings (this is<br>
     *              important mainly for encoders, e.g. libx264).<br>
     * @return An AVCodecContext filled with default values or NULL on failure.<br>
     * @see avcodec_get_context_defaults<br>
     * Original signature : <code>AVCodecContext* avcodec_alloc_context3(const AVCodec*)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h:1095</i>
     */
    public Pointer<AVCodecContext > avcodec_alloc_context3(Pointer<AVCodec > codec) {
        return (Pointer)Pointer.pointerToAddress(avcodec_alloc_context3(Pointer.getPeer(codec)), AVCodecContext.class);
    }
    @Ptr
    protected native long avcodec_alloc_context3(@Ptr long codec);
    /**
     * Free the codec context and everything associated with it and write NULL to<br>
     * the provided pointer.<br>
     * Original signature : <code>void avcodec_free_context(AVCodecContext**)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h:1101</i>
     */
    public void avcodec_free_context(Pointer<Pointer<AVCodecContext > > avctx) {
        avcodec_free_context(Pointer.getPeer(avctx));
    }
    protected native void avcodec_free_context(@Ptr long avctx);
    /**
     * Set the fields of the given AVCodecContext to default values corresponding<br>
     * to the given codec (defaults may be codec-dependent).<br>
     * Do not call this function if a non-NULL codec has been passed<br>
     * to avcodec_alloc_context3() that allocated this AVCodecContext.<br>
     * If codec is non-NULL, it is illegal to call avcodec_open2() with a<br>
     * different codec on this AVCodecContext.<br>
     * Original signature : <code>int avcodec_get_context_defaults3(AVCodecContext*, const AVCodec*)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h:1111</i>
     */
    public int avcodec_get_context_defaults3(Pointer<AVCodecContext > s, Pointer<AVCodec > codec) {
        return avcodec_get_context_defaults3(Pointer.getPeer(s), Pointer.getPeer(codec));
    }
    protected native int avcodec_get_context_defaults3(@Ptr long s, @Ptr long codec);
    /**
     * Get the AVClass for AVCodecContext. It can be used in combination with<br>
     * AV_OPT_SEARCH_FAKE_OBJ for examining options.<br>
     * @see av_opt_find().<br>
     * Original signature : <code>AVClass* avcodec_get_class()</code><br>
     * <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h:1118</i>
     */
    public Pointer<AVClass > avcodec_get_class() {
        return (Pointer)Pointer.pointerToAddress(avcodec_get_class$2(), AVClass.class);
    }
    @Ptr
    @Name("avcodec_get_class")
    protected native long avcodec_get_class$2();
    /**
     * Get the AVClass for AVFrame. It can be used in combination with<br>
     * AV_OPT_SEARCH_FAKE_OBJ for examining options.<br>
     * @see av_opt_find().<br>
     * Original signature : <code>AVClass* avcodec_get_frame_class()</code><br>
     * <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h:1125</i>
     */
    public Pointer<AVClass > avcodec_get_frame_class() {
        return (Pointer)Pointer.pointerToAddress(avcodec_get_frame_class$2(), AVClass.class);
    }
    @Ptr
    @Name("avcodec_get_frame_class")
    protected native long avcodec_get_frame_class$2();
    /**
     * Get the AVClass for AVSubtitleRect. It can be used in combination with<br>
     * AV_OPT_SEARCH_FAKE_OBJ for examining options.<br>
     * @see av_opt_find().<br>
     * Original signature : <code>AVClass* avcodec_get_subtitle_rect_class()</code><br>
     * <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h:1132</i>
     */
    public Pointer<AVClass > avcodec_get_subtitle_rect_class() {
        return (Pointer)Pointer.pointerToAddress(avcodec_get_subtitle_rect_class$2(), AVClass.class);
    }
    @Ptr
    @Name("avcodec_get_subtitle_rect_class")
    protected native long avcodec_get_subtitle_rect_class$2();
    /**
     * Copy the settings of the source AVCodecContext into the destination<br>
     * AVCodecContext. The resulting destination codec context will be<br>
     * unopened, i.e. you are required to call avcodec_open2() before you<br>
     * can use this AVCodecContext to decode/encode video/audio data.<br>
     * @param dest target codec context, should be initialized with<br>
     *             avcodec_alloc_context3(NULL), but otherwise uninitialized<br>
     * @param src source codec context<br>
     * @return AVERROR() on error (e.g. memory allocation error), 0 on success<br>
     * Original signature : <code>int avcodec_copy_context(AVCodecContext*, const AVCodecContext*)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h:1144</i>
     */
    public int avcodec_copy_context(Pointer<AVCodecContext > dest, Pointer<AVCodecContext > src) {
        return avcodec_copy_context(Pointer.getPeer(dest), Pointer.getPeer(src));
    }
    protected native int avcodec_copy_context(@Ptr long dest, @Ptr long src);
    /**
     * Initialize the AVCodecContext to use the given AVCodec. Prior to using this<br>
     * function the context has to be allocated with avcodec_alloc_context3().<br>
     * The functions avcodec_find_decoder_by_name(), avcodec_find_encoder_by_name(),<br>
     * avcodec_find_decoder() and avcodec_find_encoder() provide an easy way for<br>
     * retrieving a codec.<br>
     * @warning This function is not thread safe!<br>
     * @note Always call this function before using decoding routines (such as<br>
     * @ref avcodec_decode_video2()).<br>
     * @code<br>
     * avcodec_register_all();<br>
     * av_dict_set(&opts, "b", "2.5M", 0);<br>
     * codec = avcodec_find_decoder(AV_CODEC_ID_H264);<br>
     * if (!codec)<br>
     *     exit(1);<br>
     * context = avcodec_alloc_context3(codec);<br>
     * if (avcodec_open2(context, codec, opts) < 0)<br>
     *     exit(1);<br>
     * @endcode<br>
     * @param avctx The context to initialize.<br>
     * @param codec The codec to open this context for. If a non-NULL codec has been<br>
     *              previously passed to avcodec_alloc_context3() or<br>
     *              avcodec_get_context_defaults3() for this context, then this<br>
     *              parameter MUST be either NULL or equal to the previously passed<br>
     *              codec.<br>
     * @param options A dictionary filled with AVCodecContext and codec-private options.<br>
     *                On return this object will be filled with options that were not found.<br>
     * @return zero on success, a negative value on error<br>
     * @see avcodec_alloc_context3(), avcodec_find_decoder(), avcodec_find_encoder(),<br>
     *      av_dict_set(), av_opt_find().<br>
     * Original signature : <code>int avcodec_open2(AVCodecContext*, const AVCodec*, AVDictionary**)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h:1177</i>
     */
    public int avcodec_open2(Pointer<AVCodecContext > avctx, Pointer<AVCodec > codec, Pointer<Pointer<AVDictionary > > options) {
        return avcodec_open2(Pointer.getPeer(avctx), Pointer.getPeer(codec), Pointer.getPeer(options));
    }
    protected native int avcodec_open2(@Ptr long avctx, @Ptr long codec, @Ptr long options);
    /**
     * Close a given AVCodecContext and free all the data associated with it<br>
     * (but not the AVCodecContext itself).<br>
     * Calling this function on an AVCodecContext that hasn't been opened will free<br>
     * the codec-specific data allocated in avcodec_alloc_context3() /<br>
     * avcodec_get_context_defaults3() with a non-NULL codec. Subsequent calls will<br>
     * do nothing.<br>
     * Original signature : <code>int avcodec_close(AVCodecContext*)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h:1187</i>
     */
    public int avcodec_close(Pointer<AVCodecContext > avctx) {
        return avcodec_close(Pointer.getPeer(avctx));
    }
    protected native int avcodec_close(@Ptr long avctx);
    /**
     * Free all allocated data in the given subtitle struct.<br>
     * @param sub AVSubtitle to free.<br>
     * Original signature : <code>void avsubtitle_free(AVSubtitle*)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h:1193</i>
     */
    public void avsubtitle_free(Pointer<AVSubtitle > sub) {
        avsubtitle_free(Pointer.getPeer(sub));
    }
    protected native void avsubtitle_free(@Ptr long sub);
    /**
     * Initialize optional fields of a packet with default values.<br>
     * Note, this does not touch the data and size members, which have to be<br>
     * initialized separately.<br>
     * @param pkt packet<br>
     * Original signature : <code>void av_init_packet(AVPacket*)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h:1201</i>
     */
    public void av_init_packet(Pointer<AVPacket > pkt) {
        av_init_packet(Pointer.getPeer(pkt));
    }
    protected native void av_init_packet(@Ptr long pkt);
    /**
     * Allocate the payload of a packet and initialize its fields with<br>
     * default values.<br>
     * @param pkt packet<br>
     * @param size wanted payload size<br>
     * @return 0 if OK, AVERROR_xxx otherwise<br>
     * Original signature : <code>int av_new_packet(AVPacket*, int)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h:1210</i>
     */
    public int av_new_packet(Pointer<AVPacket > pkt, int size) {
        return av_new_packet(Pointer.getPeer(pkt), size);
    }
    protected native int av_new_packet(@Ptr long pkt, int size);
    /**
     * Reduce packet size, correctly zeroing padding<br>
     * @param pkt packet<br>
     * @param size new size<br>
     * Original signature : <code>void av_shrink_packet(AVPacket*, int)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h:1217</i>
     */
    public void av_shrink_packet(Pointer<AVPacket > pkt, int size) {
        av_shrink_packet(Pointer.getPeer(pkt), size);
    }
    protected native void av_shrink_packet(@Ptr long pkt, int size);
    /**
     * Increase packet size, correctly zeroing padding<br>
     * @param pkt packet<br>
     * @param grow_by number of bytes by which to increase the size of the packet<br>
     * Original signature : <code>int av_grow_packet(AVPacket*, int)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h:1224</i>
     */
    public int av_grow_packet(Pointer<AVPacket > pkt, int grow_by) {
        return av_grow_packet(Pointer.getPeer(pkt), grow_by);
    }
    protected native int av_grow_packet(@Ptr long pkt, int grow_by);
    /**
     * Initialize a reference-counted packet from av_malloc()ed data.<br>
     * @param pkt packet to be initialized. This function will set the data, size,<br>
     *        buf and destruct fields, all others are left untouched.<br>
     * @param data Data allocated by av_malloc() to be used as packet data. If this<br>
     *        function returns successfully, the data is owned by the underlying AVBuffer.<br>
     *        The caller may not access the data through other means.<br>
     * @param size size of data in bytes, without the padding. I.e. the full buffer<br>
     *        size is assumed to be size + AV_INPUT_BUFFER_PADDING_SIZE.<br>
     * @return 0 on success, a negative AVERROR on error<br>
     * Original signature : <code>int av_packet_from_data(AVPacket*, uint8_t*, int)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h:1237</i>
     */
    public int av_packet_from_data(Pointer<AVPacket > pkt, Pointer<Byte > data, int size) {
        return av_packet_from_data(Pointer.getPeer(pkt), Pointer.getPeer(data), size);
    }
    protected native int av_packet_from_data(@Ptr long pkt, @Ptr long data, int size);
    /**
     * @warning This is a hack - the packet memory allocation stuff is broken. The<br>
     * packet is allocated if it was not really allocated.<br>
     * Original signature : <code>int av_dup_packet(AVPacket*)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h:1243</i>
     */
    public int av_dup_packet(Pointer<AVPacket > pkt) {
        return av_dup_packet(Pointer.getPeer(pkt));
    }
    protected native int av_dup_packet(@Ptr long pkt);
    /**
     * Copy packet, including contents<br>
     * @return 0 on success, negative AVERROR on fail<br>
     * Original signature : <code>int av_copy_packet(AVPacket*, const AVPacket*)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h:1249</i>
     */
    public int av_copy_packet(Pointer<AVPacket > dst, Pointer<AVPacket > src) {
        return av_copy_packet(Pointer.getPeer(dst), Pointer.getPeer(src));
    }
    protected native int av_copy_packet(@Ptr long dst, @Ptr long src);
    /**
     * Copy packet side data<br>
     * @return 0 on success, negative AVERROR on fail<br>
     * Original signature : <code>int av_copy_packet_side_data(AVPacket*, const AVPacket*)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h:1255</i>
     */
    public int av_copy_packet_side_data(Pointer<AVPacket > dst, Pointer<AVPacket > src) {
        return av_copy_packet_side_data(Pointer.getPeer(dst), Pointer.getPeer(src));
    }
    protected native int av_copy_packet_side_data(@Ptr long dst, @Ptr long src);
    /**
     * Free a packet.<br>
     * @param pkt packet to free<br>
     * Original signature : <code>void av_free_packet(AVPacket*)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h:1261</i>
     */
    public void av_free_packet(Pointer<AVPacket > pkt) {
        av_free_packet(Pointer.getPeer(pkt));
    }
    protected native void av_free_packet(@Ptr long pkt);
    /**
     * Allocate new information of a packet.<br>
     * @param pkt packet<br>
     * @param type side information type<br>
     * @param size side information size<br>
     * @return pointer to fresh allocated data or NULL otherwise<br>
     * Original signature : <code>uint8_t* av_packet_new_side_data(AVPacket*, AVPacketSideDataType, int)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h:1270</i>
     */
    public Pointer<Byte > av_packet_new_side_data(Pointer<AVPacket > pkt, IntValuedEnum<AvcodecLibrary.AVPacketSideDataType > type, int size) {
        return (Pointer)Pointer.pointerToAddress(av_packet_new_side_data(Pointer.getPeer(pkt), (int)type.value(), size), Byte.class);
    }
    @Ptr
    protected native long av_packet_new_side_data(@Ptr long pkt, int type, int size);
    /**
     * Shrink the already allocated side data buffer<br>
     * @param pkt packet<br>
     * @param type side information type<br>
     * @param size new side information size<br>
     * @return 0 on success, < 0 on failure<br>
     * Original signature : <code>int av_packet_shrink_side_data(AVPacket*, AVPacketSideDataType, int)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h:1279</i>
     */
    public int av_packet_shrink_side_data(Pointer<AVPacket > pkt, IntValuedEnum<AvcodecLibrary.AVPacketSideDataType > type, int size) {
        return av_packet_shrink_side_data(Pointer.getPeer(pkt), (int)type.value(), size);
    }
    protected native int av_packet_shrink_side_data(@Ptr long pkt, int type, int size);
    /**
     * Get side information from packet.<br>
     * @param pkt packet<br>
     * @param type desired side information type<br>
     * @param size pointer for side information size to store (optional)<br>
     * @return pointer to data if present or NULL otherwise<br>
     * Original signature : <code>uint8_t* av_packet_get_side_data(AVPacket*, AVPacketSideDataType, int*)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h:1288</i>
     */
    public Pointer<Byte > av_packet_get_side_data(Pointer<AVPacket > pkt, IntValuedEnum<AvcodecLibrary.AVPacketSideDataType > type, Pointer<Integer > size) {
        return (Pointer)Pointer.pointerToAddress(av_packet_get_side_data(Pointer.getPeer(pkt), (int)type.value(), Pointer.getPeer(size)), Byte.class);
    }
    @Ptr
    protected native long av_packet_get_side_data(@Ptr long pkt, int type, @Ptr long size);
    /**
     * Original signature : <code>int av_packet_merge_side_data(AVPacket*)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h:1290</i>
     */
    public int av_packet_merge_side_data(Pointer<AVPacket > pkt) {
        return av_packet_merge_side_data(Pointer.getPeer(pkt));
    }
    protected native int av_packet_merge_side_data(@Ptr long pkt);
    /**
     * Original signature : <code>int av_packet_split_side_data(AVPacket*)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h:1292</i>
     */
    public int av_packet_split_side_data(Pointer<AVPacket > pkt) {
        return av_packet_split_side_data(Pointer.getPeer(pkt));
    }
    protected native int av_packet_split_side_data(@Ptr long pkt);
    /**
     * Original signature : <code>char* av_packet_side_data_name(AVPacketSideDataType)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h:1294</i>
     */
    public Pointer<Byte > av_packet_side_data_name(IntValuedEnum<AvcodecLibrary.AVPacketSideDataType > type) {
        return (Pointer)Pointer.pointerToAddress(av_packet_side_data_name((int)type.value()), Byte.class);
    }
    @Ptr
    protected native long av_packet_side_data_name(int type);
    /**
     * Pack a dictionary for use in side_data.<br>
     * @param dict The dictionary to pack.<br>
     * @param size pointer to store the size of the returned data<br>
     * @return pointer to data if successful, NULL otherwise<br>
     * Original signature : <code>uint8_t* av_packet_pack_dictionary(AVDictionary*, int*)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h:1302</i>
     */
    public Pointer<Byte > av_packet_pack_dictionary(Pointer<AVDictionary > dict, Pointer<Integer > size) {
        return (Pointer)Pointer.pointerToAddress(av_packet_pack_dictionary(Pointer.getPeer(dict), Pointer.getPeer(size)), Byte.class);
    }
    @Ptr
    protected native long av_packet_pack_dictionary(@Ptr long dict, @Ptr long size);
    /**
     * Unpack a dictionary from side_data.<br>
     * @param data data from side_data<br>
     * @param size size of the data<br>
     * @param dict the metadata storage dictionary<br>
     * @return 0 on success, < 0 on failure<br>
     * Original signature : <code>int av_packet_unpack_dictionary(const uint8_t*, int, AVDictionary**)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h:1311</i>
     */
    public int av_packet_unpack_dictionary(Pointer<Byte > data, int size, Pointer<Pointer<AVDictionary > > dict) {
        return av_packet_unpack_dictionary(Pointer.getPeer(data), size, Pointer.getPeer(dict));
    }
    protected native int av_packet_unpack_dictionary(@Ptr long data, int size, @Ptr long dict);
    /**
     * Convenience function to free all the side data stored.<br>
     * All the other fields stay untouched.<br>
     * @param pkt packet<br>
     * Original signature : <code>void av_packet_free_side_data(AVPacket*)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h:1318</i>
     */
    public void av_packet_free_side_data(Pointer<AVPacket > pkt) {
        av_packet_free_side_data(Pointer.getPeer(pkt));
    }
    protected native void av_packet_free_side_data(@Ptr long pkt);
    /**
     * Setup a new reference to the data described by a given packet<br>
     * If src is reference-counted, setup dst as a new reference to the<br>
     * buffer in src. Otherwise allocate a new buffer in dst and copy the<br>
     * data from src into it.<br>
     * All the other fields are copied from src.<br>
     * @see av_packet_unref<br>
     * @param dst Destination packet<br>
     * @param src Source packet<br>
     * @return 0 on success, a negative AVERROR on error.<br>
     * Original signature : <code>int av_packet_ref(AVPacket*, const AVPacket*)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h:1331</i>
     */
    public int av_packet_ref(Pointer<AVPacket > dst, Pointer<AVPacket > src) {
        return av_packet_ref(Pointer.getPeer(dst), Pointer.getPeer(src));
    }
    protected native int av_packet_ref(@Ptr long dst, @Ptr long src);
    /**
     * Wipe the packet.<br>
     * Unreference the buffer referenced by the packet and reset the<br>
     * remaining packet fields to their default values.<br>
     * @param pkt The packet to be unreferenced.<br>
     * Original signature : <code>void av_packet_unref(AVPacket*)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h:1339</i>
     */
    public void av_packet_unref(Pointer<AVPacket > pkt) {
        av_packet_unref(Pointer.getPeer(pkt));
    }
    protected native void av_packet_unref(@Ptr long pkt);
    /**
     * Move every field in src to dst and reset src.<br>
     * @see av_packet_unref<br>
     * @param src Source packet, will be reset<br>
     * @param dst Destination packet<br>
     * Original signature : <code>void av_packet_move_ref(AVPacket*, AVPacket*)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h:1347</i>
     */
    public void av_packet_move_ref(Pointer<AVPacket > dst, Pointer<AVPacket > src) {
        av_packet_move_ref(Pointer.getPeer(dst), Pointer.getPeer(src));
    }
    protected native void av_packet_move_ref(@Ptr long dst, @Ptr long src);
    /**
     * Copy only "properties" fields from src to dst.<br>
     * Properties for the purpose of this function are all the fields<br>
     * beside those related to the packet data (buf, data, size)<br>
     * @param dst Destination packet<br>
     * @param src Source packet<br>
     * @return 0 on success AVERROR on failure.<br>
     * Original signature : <code>int av_packet_copy_props(AVPacket*, const AVPacket*)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h:1357</i>
     */
    public int av_packet_copy_props(Pointer<AVPacket > dst, Pointer<AVPacket > src) {
        return av_packet_copy_props(Pointer.getPeer(dst), Pointer.getPeer(src));
    }
    protected native int av_packet_copy_props(@Ptr long dst, @Ptr long src);
    /**
     * Convert valid timing fields (timestamps / durations) in a packet from one<br>
     * timebase to another. Timestamps with unknown values (AV_NOPTS_VALUE) will be<br>
     * ignored.<br>
     * @param pkt packet on which the conversion will be performed<br>
     * @param tb_src source timebase, in which the timing fields in pkt are<br>
     *               expressed<br>
     * @param tb_dst destination timebase, to which the timing fields will be<br>
     *               converted<br>
     * Original signature : <code>void av_packet_rescale_ts(AVPacket*, AVRational, AVRational)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h:1369</i>
     */
    public void av_packet_rescale_ts(Pointer<AVPacket > pkt, AVRational tb_src, AVRational tb_dst) {
        av_packet_rescale_ts(Pointer.getPeer(pkt), tb_src, tb_dst);
    }
    protected native void av_packet_rescale_ts(@Ptr long pkt, AVRational tb_src, AVRational tb_dst);
    /**
     * Find a registered decoder with a matching codec ID.<br>
     * @param id AVCodecID of the requested decoder<br>
     * @return A decoder if one was found, NULL otherwise.<br>
     * Original signature : <code>AVCodec* avcodec_find_decoder(AVCodecID)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h:1376</i>
     */
    public Pointer<AVCodec > avcodec_find_decoder(IntValuedEnum<AvcodecLibrary.AVCodecID > id) {
        return (Pointer)Pointer.pointerToAddress(avcodec_find_decoder((int)id.value()), AVCodec.class);
    }
    @Ptr
    protected native long avcodec_find_decoder(int id);
    /**
     * Find a registered decoder with the specified name.<br>
     * @param name name of the requested decoder<br>
     * @return A decoder if one was found, NULL otherwise.<br>
     * Original signature : <code>AVCodec* avcodec_find_decoder_by_name(const char*)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h:1383</i>
     */
    public Pointer<AVCodec > avcodec_find_decoder_by_name(Pointer<Byte > name) {
        return (Pointer)Pointer.pointerToAddress(avcodec_find_decoder_by_name(Pointer.getPeer(name)), AVCodec.class);
    }
    @Ptr
    protected native long avcodec_find_decoder_by_name(@Ptr long name);
    /**
     * The default callback for AVCodecContext.get_buffer2(). It is made public so<br>
     * it can be called by custom get_buffer2() implementations for decoders without<br>
     * AV_CODEC_CAP_DR1 set.<br>
     * Original signature : <code>int avcodec_default_get_buffer2(AVCodecContext*, AVFrame*, int)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h:1390</i>
     */
    public int avcodec_default_get_buffer2(Pointer<AVCodecContext > s, Pointer<AVFrame > frame, int flags) {
        return avcodec_default_get_buffer2(Pointer.getPeer(s), Pointer.getPeer(frame), flags);
    }
    protected native int avcodec_default_get_buffer2(@Ptr long s, @Ptr long frame, int flags);
    /**
     * Return the amount of padding in pixels which the get_buffer callback must<br>
     * provide around the edge of the image for codecs which do not have the<br>
     * CODEC_FLAG_EMU_EDGE flag.<br>
     * @return Required padding in pixels.<br>
     * @deprecated CODEC_FLAG_EMU_EDGE is deprecated, so this function is no longer<br>
     * needed<br>
     * Original signature : <code>int avcodec_get_edge_width()</code><br>
     * <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h:1400</i>
     */
    public native int avcodec_get_edge_width();
    /**
     * Modify width and height values so that they will result in a memory<br>
     * buffer that is acceptable for the codec if you do not use any horizontal<br>
     * padding.<br>
     * May only be used if a codec with AV_CODEC_CAP_DR1 has been opened.<br>
     * Original signature : <code>void avcodec_align_dimensions(AVCodecContext*, int*, int*)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h:1408</i>
     */
    public void avcodec_align_dimensions(Pointer<AVCodecContext > s, Pointer<Integer > width, Pointer<Integer > height) {
        avcodec_align_dimensions(Pointer.getPeer(s), Pointer.getPeer(width), Pointer.getPeer(height));
    }
    protected native void avcodec_align_dimensions(@Ptr long s, @Ptr long width, @Ptr long height);
    /**
     * Modify width and height values so that they will result in a memory<br>
     * buffer that is acceptable for the codec if you also ensure that all<br>
     * line sizes are a multiple of the respective linesize_align[i].<br>
     * May only be used if a codec with AV_CODEC_CAP_DR1 has been opened.<br>
     * Original signature : <code>void avcodec_align_dimensions2(AVCodecContext*, int*, int*, int[8])</code><br>
     * <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h:1416</i>
     */
    public void avcodec_align_dimensions2(Pointer<AVCodecContext > s, Pointer<Integer > width, Pointer<Integer > height, Pointer<Integer > linesize_align) {
        avcodec_align_dimensions2(Pointer.getPeer(s), Pointer.getPeer(width), Pointer.getPeer(height), Pointer.getPeer(linesize_align));
    }
    protected native void avcodec_align_dimensions2(@Ptr long s, @Ptr long width, @Ptr long height, @Ptr long linesize_align);
    /**
     * Converts AVChromaLocation to swscale x/y chroma position.<br>
     * The positions represent the chroma (0,0) position in a coordinates system<br>
     * with luma (0,0) representing the origin and luma(1,1) representing 256,256<br>
     * @param xpos  horizontal chroma sample position<br>
     * @param ypos  vertical   chroma sample position<br>
     * Original signature : <code>int avcodec_enum_to_chroma_pos(int*, int*, AVChromaLocation)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h:1425</i>
     */
    public int avcodec_enum_to_chroma_pos(Pointer<Integer > xpos, Pointer<Integer > ypos, IntValuedEnum<AVChromaLocation > pos) {
        return avcodec_enum_to_chroma_pos(Pointer.getPeer(xpos), Pointer.getPeer(ypos), (int)pos.value());
    }
    protected native int avcodec_enum_to_chroma_pos(@Ptr long xpos, @Ptr long ypos, int pos);
    /**
     * Converts swscale x/y chroma position to AVChromaLocation.<br>
     * The positions represent the chroma (0,0) position in a coordinates system<br>
     * with luma (0,0) representing the origin and luma(1,1) representing 256,256<br>
     * @param xpos  horizontal chroma sample position<br>
     * @param ypos  vertical   chroma sample position<br>
     * Original signature : <code>AVChromaLocation avcodec_chroma_pos_to_enum(int, int)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h:1434</i>
     */
    public IntValuedEnum<AVChromaLocation > avcodec_chroma_pos_to_enum(int xpos, int ypos) {
        return FlagSet.fromValue(avcodec_chroma_pos_to_enum$2(xpos, ypos), AVChromaLocation.class);
    }
    @Name("avcodec_chroma_pos_to_enum")
    protected native int avcodec_chroma_pos_to_enum$2(int xpos, int ypos);
    /**
     * Decode the audio frame of size avpkt->size from avpkt->data into frame.<br>
     * Some decoders may support multiple frames in a single AVPacket. Such<br>
     * decoders would then just decode the first frame and the return value would be<br>
     * less than the packet size. In this case, avcodec_decode_audio4 has to be<br>
     * called again with an AVPacket containing the remaining data in order to<br>
     * decode the second frame, etc...  Even if no frames are returned, the packet<br>
     * needs to be fed to the decoder with remaining data until it is completely<br>
     * consumed or an error occurs.<br>
     * Some decoders (those marked with AV_CODEC_CAP_DELAY) have a delay between input<br>
     * and output. This means that for some packets they will not immediately<br>
     * produce decoded output and need to be flushed at the end of decoding to get<br>
     * all the decoded data. Flushing is done by calling this function with packets<br>
     * with avpkt->data set to NULL and avpkt->size set to 0 until it stops<br>
     * returning samples. It is safe to flush even those decoders that are not<br>
     * marked with AV_CODEC_CAP_DELAY, then no samples will be returned.<br>
     * @warning The input buffer, avpkt->data must be AV_INPUT_BUFFER_PADDING_SIZE<br>
     *          larger than the actual read bytes because some optimized bitstream<br>
     *          readers read 32 or 64 bits at once and could read over the end.<br>
     * @note The AVCodecContext MUST have been opened with @ref avcodec_open2()<br>
     * before packets may be fed to the decoder.<br>
     * @param      avctx the codec context<br>
     * @param[out] frame The AVFrame in which to store decoded audio samples.<br>
     *                   The decoder will allocate a buffer for the decoded frame by<br>
     *                   calling the AVCodecContext.get_buffer2() callback.<br>
     *                   When AVCodecContext.refcounted_frames is set to 1, the frame is<br>
     *                   reference counted and the returned reference belongs to the<br>
     *                   caller. The caller must release the frame using av_frame_unref()<br>
     *                   when the frame is no longer needed. The caller may safely write<br>
     *                   to the frame if av_frame_is_writable() returns 1.<br>
     *                   When AVCodecContext.refcounted_frames is set to 0, the returned<br>
     *                   reference belongs to the decoder and is valid only until the<br>
     *                   next call to this function or until closing or flushing the<br>
     *                   decoder. The caller may not write to it.<br>
     * @param[out] got_frame_ptr Zero if no frame could be decoded, otherwise it is<br>
     *                           non-zero. Note that this field being set to zero<br>
     *                           does not mean that an error has occurred. For<br>
     *                           decoders with AV_CODEC_CAP_DELAY set, no given decode<br>
     *                           call is guaranteed to produce a frame.<br>
     * @param[in]  avpkt The input AVPacket containing the input buffer.<br>
     *                   At least avpkt->data and avpkt->size should be set. Some<br>
     *                   decoders might also require additional fields to be set.<br>
     * @return A negative error code is returned if an error occurred during<br>
     *         decoding, otherwise the number of bytes consumed from the input<br>
     *         AVPacket is returned.<br>
     * Original signature : <code>int avcodec_decode_audio4(AVCodecContext*, AVFrame*, int*, const AVPacket*)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h:1482</i>
     */
    public int avcodec_decode_audio4(Pointer<AVCodecContext > avctx, Pointer<AVFrame > frame, Pointer<Integer > got_frame_ptr, Pointer<AVPacket > avpkt) {
        return avcodec_decode_audio4(Pointer.getPeer(avctx), Pointer.getPeer(frame), Pointer.getPeer(got_frame_ptr), Pointer.getPeer(avpkt));
    }
    protected native int avcodec_decode_audio4(@Ptr long avctx, @Ptr long frame, @Ptr long got_frame_ptr, @Ptr long avpkt);
    /**
     * Decode the video frame of size avpkt->size from avpkt->data into picture.<br>
     * Some decoders may support multiple frames in a single AVPacket, such<br>
     * decoders would then just decode the first frame.<br>
     * @warning The input buffer must be AV_INPUT_BUFFER_PADDING_SIZE larger than<br>
     * the actual read bytes because some optimized bitstream readers read 32 or 64<br>
     * bits at once and could read over the end.<br>
     * @warning The end of the input buffer buf should be set to 0 to ensure that<br>
     * no overreading happens for damaged MPEG streams.<br>
     * @note Codecs which have the AV_CODEC_CAP_DELAY capability set have a delay<br>
     * between input and output, these need to be fed with avpkt->data=NULL,<br>
     * avpkt->size=0 at the end to return the remaining frames.<br>
     * @note The AVCodecContext MUST have been opened with @ref avcodec_open2()<br>
     * before packets may be fed to the decoder.<br>
     * @param avctx the codec context<br>
     * @param[out] picture The AVFrame in which the decoded video frame will be stored.<br>
     *             Use av_frame_alloc() to get an AVFrame. The codec will<br>
     *             allocate memory for the actual bitmap by calling the<br>
     *             AVCodecContext.get_buffer2() callback.<br>
     *             When AVCodecContext.refcounted_frames is set to 1, the frame is<br>
     *             reference counted and the returned reference belongs to the<br>
     *             caller. The caller must release the frame using av_frame_unref()<br>
     *             when the frame is no longer needed. The caller may safely write<br>
     *             to the frame if av_frame_is_writable() returns 1.<br>
     *             When AVCodecContext.refcounted_frames is set to 0, the returned<br>
     *             reference belongs to the decoder and is valid only until the<br>
     *             next call to this function or until closing or flushing the<br>
     *             decoder. The caller may not write to it.<br>
     * @param[in] avpkt The input AVPacket containing the input buffer.<br>
     *            You can create such packet with av_init_packet() and by then setting<br>
     *            data and size, some decoders might in addition need other fields like<br>
     *            flags&AV_PKT_FLAG_KEY. All decoders are designed to use the least<br>
     *            fields possible.<br>
     * @param[in,out] got_picture_ptr Zero if no frame could be decompressed, otherwise, it is nonzero.<br>
     * @return On error a negative value is returned, otherwise the number of bytes<br>
     * used or zero if no frame could be decompressed.<br>
     * Original signature : <code>int avcodec_decode_video2(AVCodecContext*, AVFrame*, int*, const AVPacket*)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h:1521</i>
     */
    public int avcodec_decode_video2(Pointer<AVCodecContext > avctx, Pointer<AVFrame > picture, Pointer<Integer > got_picture_ptr, Pointer<AVPacket > avpkt) {
        return avcodec_decode_video2(Pointer.getPeer(avctx), Pointer.getPeer(picture), Pointer.getPeer(got_picture_ptr), Pointer.getPeer(avpkt));
    }
    protected native int avcodec_decode_video2(@Ptr long avctx, @Ptr long picture, @Ptr long got_picture_ptr, @Ptr long avpkt);
    /**
     * Decode a subtitle message.<br>
     * Return a negative value on error, otherwise return the number of bytes used.<br>
     * If no subtitle could be decompressed, got_sub_ptr is zero.<br>
     * Otherwise, the subtitle is stored in *sub.<br>
     * Note that AV_CODEC_CAP_DR1 is not available for subtitle codecs. This is for<br>
     * simplicity, because the performance difference is expect to be negligible<br>
     * and reusing a get_buffer written for video codecs would probably perform badly<br>
     * due to a potentially very different allocation pattern.<br>
     * Some decoders (those marked with CODEC_CAP_DELAY) have a delay between input<br>
     * and output. This means that for some packets they will not immediately<br>
     * produce decoded output and need to be flushed at the end of decoding to get<br>
     * all the decoded data. Flushing is done by calling this function with packets<br>
     * with avpkt->data set to NULL and avpkt->size set to 0 until it stops<br>
     * returning subtitles. It is safe to flush even those decoders that are not<br>
     * marked with CODEC_CAP_DELAY, then no subtitles will be returned.<br>
     * @note The AVCodecContext MUST have been opened with @ref avcodec_open2()<br>
     * before packets may be fed to the decoder.<br>
     * @param avctx the codec context<br>
     * @param[out] sub The Preallocated AVSubtitle in which the decoded subtitle will be stored,<br>
     *                 must be freed with avsubtitle_free if *got_sub_ptr is set.<br>
     * @param[in,out] got_sub_ptr Zero if no subtitle could be decompressed, otherwise, it is nonzero.<br>
     * @param[in] avpkt The input AVPacket containing the input buffer.<br>
     * Original signature : <code>int avcodec_decode_subtitle2(AVCodecContext*, AVSubtitle*, int*, AVPacket*)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h:1547</i>
     */
    public int avcodec_decode_subtitle2(Pointer<AVCodecContext > avctx, Pointer<AVSubtitle > sub, Pointer<Integer > got_sub_ptr, Pointer<AVPacket > avpkt) {
        return avcodec_decode_subtitle2(Pointer.getPeer(avctx), Pointer.getPeer(sub), Pointer.getPeer(got_sub_ptr), Pointer.getPeer(avpkt));
    }
    protected native int avcodec_decode_subtitle2(@Ptr long avctx, @Ptr long sub, @Ptr long got_sub_ptr, @Ptr long avpkt);
    /**
     * Original signature : <code>AVCodecParser* av_parser_next(const AVCodecParser*)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h:1621</i>
     */
    public Pointer<AVCodecParser > av_parser_next(Pointer<AVCodecParser > c) {
        return (Pointer)Pointer.pointerToAddress(av_parser_next(Pointer.getPeer(c)), AVCodecParser.class);
    }
    @Ptr
    protected native long av_parser_next(@Ptr long c);
    /**
     * Original signature : <code>void av_register_codec_parser(AVCodecParser*)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h:1623</i>
     */
    public void av_register_codec_parser(Pointer<AVCodecParser > parser) {
        av_register_codec_parser(Pointer.getPeer(parser));
    }
    protected native void av_register_codec_parser(@Ptr long parser);
    /**
     * Original signature : <code>AVCodecParserContext* av_parser_init(int)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h:1625</i>
     */
    public Pointer<AVCodecParserContext > av_parser_init(int codec_id) {
        return (Pointer)Pointer.pointerToAddress(av_parser_init$2(codec_id), AVCodecParserContext.class);
    }
    @Ptr
    @Name("av_parser_init")
    protected native long av_parser_init$2(int codec_id);
    /**
     * Parse a packet.<br>
     * @param s             parser context.<br>
     * @param avctx         codec context.<br>
     * @param poutbuf       set to pointer to parsed buffer or NULL if not yet finished.<br>
     * @param poutbuf_size  set to size of parsed buffer or zero if not yet finished.<br>
     * @param buf           input buffer.<br>
     * @param buf_size      input length, to signal EOF, this should be 0 (so that the last frame can be output).<br>
     * @param pts           input presentation timestamp.<br>
     * @param dts           input decoding timestamp.<br>
     * @param pos           input byte position in stream.<br>
     * @return the number of bytes of the input bitstream used.<br>
     * Example:<br>
     * @code<br>
     *   while(in_len){<br>
     *       len = av_parser_parse2(myparser, AVCodecContext, &data, &size,<br>
     *                                        in_data, in_len,<br>
     *                                        pts, dts, pos);<br>
     *       in_data += len;<br>
     *       in_len  -= len;<br>
     *       if(size)<br>
     *          decode_frame(data, size);<br>
     *   }<br>
     * @endcode<br>
     * Original signature : <code>int av_parser_parse2(AVCodecParserContext*, AVCodecContext*, uint8_t**, int*, const uint8_t*, int, int64_t, int64_t, int64_t)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h:1652</i>
     */
    public int av_parser_parse2(Pointer<AVCodecParserContext > s, Pointer<AVCodecContext > avctx, Pointer<Pointer<Byte > > poutbuf, Pointer<Integer > poutbuf_size, Pointer<Byte > buf, int buf_size, long pts, long dts, long pos) {
        return av_parser_parse2(Pointer.getPeer(s), Pointer.getPeer(avctx), Pointer.getPeer(poutbuf), Pointer.getPeer(poutbuf_size), Pointer.getPeer(buf), buf_size, pts, dts, pos);
    }
    protected native int av_parser_parse2(@Ptr long s, @Ptr long avctx, @Ptr long poutbuf, @Ptr long poutbuf_size, @Ptr long buf, int buf_size, long pts, long dts, long pos);
    /**
     * @return 0 if the output buffer is a subset of the input, 1 if it is allocated and must be freed<br>
     * @deprecated use AVBitStreamFilter<br>
     * Original signature : <code>int av_parser_change(AVCodecParserContext*, AVCodecContext*, uint8_t**, int*, const uint8_t*, int, int)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h:1658</i>
     */
    public int av_parser_change(Pointer<AVCodecParserContext > s, Pointer<AVCodecContext > avctx, Pointer<Pointer<Byte > > poutbuf, Pointer<Integer > poutbuf_size, Pointer<Byte > buf, int buf_size, int keyframe) {
        return av_parser_change(Pointer.getPeer(s), Pointer.getPeer(avctx), Pointer.getPeer(poutbuf), Pointer.getPeer(poutbuf_size), Pointer.getPeer(buf), buf_size, keyframe);
    }
    protected native int av_parser_change(@Ptr long s, @Ptr long avctx, @Ptr long poutbuf, @Ptr long poutbuf_size, @Ptr long buf, int buf_size, int keyframe);
    /**
     * Original signature : <code>void av_parser_close(AVCodecParserContext*)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h:1660</i>
     */
    public void av_parser_close(Pointer<AVCodecParserContext > s) {
        av_parser_close(Pointer.getPeer(s));
    }
    protected native void av_parser_close(@Ptr long s);
    /**
     * Find a registered encoder with a matching codec ID.<br>
     * @param id AVCodecID of the requested encoder<br>
     * @return An encoder if one was found, NULL otherwise.<br>
     * Original signature : <code>AVCodec* avcodec_find_encoder(AVCodecID)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h:1667</i>
     */
    public Pointer<AVCodec > avcodec_find_encoder(IntValuedEnum<AvcodecLibrary.AVCodecID > id) {
        return (Pointer)Pointer.pointerToAddress(avcodec_find_encoder((int)id.value()), AVCodec.class);
    }
    @Ptr
    protected native long avcodec_find_encoder(int id);
    /**
     * Find a registered encoder with the specified name.<br>
     * @param name name of the requested encoder<br>
     * @return An encoder if one was found, NULL otherwise.<br>
     * Original signature : <code>AVCodec* avcodec_find_encoder_by_name(const char*)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h:1674</i>
     */
    public Pointer<AVCodec > avcodec_find_encoder_by_name(Pointer<Byte > name) {
        return (Pointer)Pointer.pointerToAddress(avcodec_find_encoder_by_name(Pointer.getPeer(name)), AVCodec.class);
    }
    @Ptr
    protected native long avcodec_find_encoder_by_name(@Ptr long name);
    /**
     * Encode a frame of audio.<br>
     * Takes input samples from frame and writes the next output packet, if<br>
     * available, to avpkt. The output packet does not necessarily contain data for<br>
     * the most recent frame, as encoders can delay, split, and combine input frames<br>
     * internally as needed.<br>
     * @param avctx     codec context<br>
     * @param avpkt     output AVPacket.<br>
     *                  The user can supply an output buffer by setting<br>
     *                  avpkt->data and avpkt->size prior to calling the<br>
     *                  function, but if the size of the user-provided data is not<br>
     *                  large enough, encoding will fail. If avpkt->data and<br>
     *                  avpkt->size are set, avpkt->destruct must also be set. All<br>
     *                  other AVPacket fields will be reset by the encoder using<br>
     *                  av_init_packet(). If avpkt->data is NULL, the encoder will<br>
     *                  allocate it. The encoder will set avpkt->size to the size<br>
     *                  of the output packet.<br>
     *                  If this function fails or produces no output, avpkt will be<br>
     *                  freed using av_free_packet() (i.e. avpkt->destruct will be<br>
     *                  called to free the user supplied buffer).<br>
     * @param[in] frame AVFrame containing the raw audio data to be encoded.<br>
     *                  May be NULL when flushing an encoder that has the<br>
     *                  AV_CODEC_CAP_DELAY capability set.<br>
     *                  If AV_CODEC_CAP_VARIABLE_FRAME_SIZE is set, then each frame<br>
     *                  can have any number of samples.<br>
     *                  If it is not set, frame->nb_samples must be equal to<br>
     *                  avctx->frame_size for all frames except the last.<br>
     *                  The final frame may be smaller than avctx->frame_size.<br>
     * @param[out] got_packet_ptr This field is set to 1 by libavcodec if the<br>
     *                            output packet is non-empty, and to 0 if it is<br>
     *                            empty. If the function returns an error, the<br>
     *                            packet can be assumed to be invalid, and the<br>
     *                            value of got_packet_ptr is undefined and should<br>
     *                            not be used.<br>
     * @return          0 on success, negative error code on failure<br>
     * Original signature : <code>int avcodec_encode_audio2(AVCodecContext*, AVPacket*, const AVFrame*, int*)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h:1712</i>
     */
    public int avcodec_encode_audio2(Pointer<AVCodecContext > avctx, Pointer<AVPacket > avpkt, Pointer<AVFrame > frame, Pointer<Integer > got_packet_ptr) {
        return avcodec_encode_audio2(Pointer.getPeer(avctx), Pointer.getPeer(avpkt), Pointer.getPeer(frame), Pointer.getPeer(got_packet_ptr));
    }
    protected native int avcodec_encode_audio2(@Ptr long avctx, @Ptr long avpkt, @Ptr long frame, @Ptr long got_packet_ptr);
    /**
     * Encode a frame of video.<br>
     * Takes input raw video data from frame and writes the next output packet, if<br>
     * available, to avpkt. The output packet does not necessarily contain data for<br>
     * the most recent frame, as encoders can delay and reorder input frames<br>
     * internally as needed.<br>
     * @param avctx     codec context<br>
     * @param avpkt     output AVPacket.<br>
     *                  The user can supply an output buffer by setting<br>
     *                  avpkt->data and avpkt->size prior to calling the<br>
     *                  function, but if the size of the user-provided data is not<br>
     *                  large enough, encoding will fail. All other AVPacket fields<br>
     *                  will be reset by the encoder using av_init_packet(). If<br>
     *                  avpkt->data is NULL, the encoder will allocate it.<br>
     *                  The encoder will set avpkt->size to the size of the<br>
     *                  output packet. The returned data (if any) belongs to the<br>
     *                  caller, he is responsible for freeing it.<br>
     *                  If this function fails or produces no output, avpkt will be<br>
     *                  freed using av_free_packet() (i.e. avpkt->destruct will be<br>
     *                  called to free the user supplied buffer).<br>
     * @param[in] frame AVFrame containing the raw video data to be encoded.<br>
     *                  May be NULL when flushing an encoder that has the<br>
     *                  AV_CODEC_CAP_DELAY capability set.<br>
     * @param[out] got_packet_ptr This field is set to 1 by libavcodec if the<br>
     *                            output packet is non-empty, and to 0 if it is<br>
     *                            empty. If the function returns an error, the<br>
     *                            packet can be assumed to be invalid, and the<br>
     *                            value of got_packet_ptr is undefined and should<br>
     *                            not be used.<br>
     * @return          0 on success, negative error code on failure<br>
     * Original signature : <code>int avcodec_encode_video2(AVCodecContext*, AVPacket*, const AVFrame*, int*)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h:1745</i>
     */
    public int avcodec_encode_video2(Pointer<AVCodecContext > avctx, Pointer<AVPacket > avpkt, Pointer<AVFrame > frame, Pointer<Integer > got_packet_ptr) {
        return avcodec_encode_video2(Pointer.getPeer(avctx), Pointer.getPeer(avpkt), Pointer.getPeer(frame), Pointer.getPeer(got_packet_ptr));
    }
    protected native int avcodec_encode_video2(@Ptr long avctx, @Ptr long avpkt, @Ptr long frame, @Ptr long got_packet_ptr);
    /**
     * Original signature : <code>int avcodec_encode_subtitle(AVCodecContext*, uint8_t*, int, const AVSubtitle*)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h:1747</i>
     */
    public int avcodec_encode_subtitle(Pointer<AVCodecContext > avctx, Pointer<Byte > buf, int buf_size, Pointer<AVSubtitle > sub) {
        return avcodec_encode_subtitle(Pointer.getPeer(avctx), Pointer.getPeer(buf), buf_size, Pointer.getPeer(sub));
    }
    protected native int avcodec_encode_subtitle(@Ptr long avctx, @Ptr long buf, int buf_size, @Ptr long sub);
    /**
     * Initialize audio resampling context.<br>
     * @param output_channels  number of output channels<br>
     * @param input_channels   number of input channels<br>
     * @param output_rate      output sample rate<br>
     * @param input_rate       input sample rate<br>
     * @param sample_fmt_out   requested output sample format<br>
     * @param sample_fmt_in    input sample format<br>
     * @param filter_length    length of each FIR filter in the filterbank relative to the cutoff frequency<br>
     * @param log2_phase_count log2 of the number of entries in the polyphase filterbank<br>
     * @param linear           if 1 then the used FIR filter will be linearly interpolated<br>
     * between the 2 closest, if 0 the closest will be used<br>
     * @param cutoff           cutoff frequency, 1.0 corresponds to half the output sampling rate<br>
     * @return allocated ReSampleContext, NULL if error occurred<br>
     * Original signature : <code>ReSampleContext* av_audio_resample_init(int, int, int, int, AVSampleFormat, AVSampleFormat, int, int, int, double)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h:1773</i>
     */
    public Pointer<AvcodecLibrary.ReSampleContext > av_audio_resample_init(int output_channels, int input_channels, int output_rate, int input_rate, IntValuedEnum<AVSampleFormat > sample_fmt_out, IntValuedEnum<AVSampleFormat > sample_fmt_in, int filter_length, int log2_phase_count, int linear, double cutoff) {
        return (Pointer)Pointer.pointerToAddress(av_audio_resample_init(output_channels, input_channels, output_rate, input_rate, (int)sample_fmt_out.value(), (int)sample_fmt_in.value(), filter_length, log2_phase_count, linear, cutoff), AvcodecLibrary.ReSampleContext.class);
    }
    @Ptr
    protected native long av_audio_resample_init(int output_channels, int input_channels, int output_rate, int input_rate, int sample_fmt_out, int sample_fmt_in, int filter_length, int log2_phase_count, int linear, double cutoff);
    /**
     * Original signature : <code>int audio_resample(ReSampleContext*, short*, short*, int)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h:1775</i>
     */
    public int audio_resample(Pointer<AvcodecLibrary.ReSampleContext > s, Pointer<Short > output, Pointer<Short > input, int nb_samples) {
        return audio_resample(Pointer.getPeer(s), Pointer.getPeer(output), Pointer.getPeer(input), nb_samples);
    }
    protected native int audio_resample(@Ptr long s, @Ptr long output, @Ptr long input, int nb_samples);
    /**
     * Free resample context.<br>
     * @param s a non-NULL pointer to a resample context previously<br>
     *          created with av_audio_resample_init()<br>
     * Original signature : <code>void audio_resample_close(ReSampleContext*)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h:1782</i>
     */
    public void audio_resample_close(Pointer<AvcodecLibrary.ReSampleContext > s) {
        audio_resample_close(Pointer.getPeer(s));
    }
    protected native void audio_resample_close(@Ptr long s);
    /**
     * Initialize an audio resampler.<br>
     * Note, if either rate is not an integer then simply scale both rates up so they are.<br>
     * @param filter_length length of each FIR filter in the filterbank relative to the cutoff freq<br>
     * @param log2_phase_count log2 of the number of entries in the polyphase filterbank<br>
     * @param linear If 1 then the used FIR filter will be linearly interpolated<br>
     * between the 2 closest, if 0 the closest will be used<br>
     * @param cutoff cutoff frequency, 1.0 corresponds to half the output sampling rate<br>
     * Original signature : <code>AVResampleContext* av_resample_init(int, int, int, int, int, double)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h:1793</i>
     */
    public Pointer<AvcodecLibrary.AVResampleContext > av_resample_init(int out_rate, int in_rate, int filter_length, int log2_phase_count, int linear, double cutoff) {
        return (Pointer)Pointer.pointerToAddress(av_resample_init$2(out_rate, in_rate, filter_length, log2_phase_count, linear, cutoff), AvcodecLibrary.AVResampleContext.class);
    }
    @Ptr
    @Name("av_resample_init")
    protected native long av_resample_init$2(int out_rate, int in_rate, int filter_length, int log2_phase_count, int linear, double cutoff);
    /**
     * Resample an array of samples using a previously configured context.<br>
     * @param src an array of unconsumed samples<br>
     * @param consumed the number of samples of src which have been consumed are returned here<br>
     * @param src_size the number of unconsumed samples available<br>
     * @param dst_size the amount of space in samples available in dst<br>
     * @param update_ctx If this is 0 then the context will not be modified, that way several channels can be resampled with the same context.<br>
     * @return the number of samples written in dst or -1 if an error occurred<br>
     * Original signature : <code>int av_resample(AVResampleContext*, short*, short*, int*, int, int, int)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h:1804</i>
     */
    public int av_resample(Pointer<AvcodecLibrary.AVResampleContext > c, Pointer<Short > dst, Pointer<Short > src, Pointer<Integer > consumed, int src_size, int dst_size, int update_ctx) {
        return av_resample(Pointer.getPeer(c), Pointer.getPeer(dst), Pointer.getPeer(src), Pointer.getPeer(consumed), src_size, dst_size, update_ctx);
    }
    protected native int av_resample(@Ptr long c, @Ptr long dst, @Ptr long src, @Ptr long consumed, int src_size, int dst_size, int update_ctx);
    /**
     * Compensate samplerate/timestamp drift. The compensation is done by changing<br>
     * the resampler parameters, so no audible clicks or similar distortions occur<br>
     * @param compensation_distance distance in output samples over which the compensation should be performed<br>
     * @param sample_delta number of output samples which should be output less<br>
     * example: av_resample_compensate(c, 10, 500)<br>
     * here instead of 510 samples only 500 samples would be output<br>
     * note, due to rounding the actual compensation might be slightly different,<br>
     * especially if the compensation_distance is large and the in_rate used during init is small<br>
     * Original signature : <code>void av_resample_compensate(AVResampleContext*, int, int)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h:1816</i>
     */
    public void av_resample_compensate(Pointer<AvcodecLibrary.AVResampleContext > c, int sample_delta, int compensation_distance) {
        av_resample_compensate(Pointer.getPeer(c), sample_delta, compensation_distance);
    }
    protected native void av_resample_compensate(@Ptr long c, int sample_delta, int compensation_distance);
    /**
     * Original signature : <code>void av_resample_close(AVResampleContext*)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h:1818</i>
     */
    public void av_resample_close(Pointer<AvcodecLibrary.AVResampleContext > c) {
        av_resample_close(Pointer.getPeer(c));
    }
    protected native void av_resample_close(@Ptr long c);
    /**
     * Allocate memory for the pixels of a picture and setup the AVPicture<br>
     * fields for it.<br>
     * Call avpicture_free() to free it.<br>
     * @param picture            the picture structure to be filled in<br>
     * @param pix_fmt            the pixel format of the picture<br>
     * @param width              the width of the picture<br>
     * @param height             the height of the picture<br>
     * @return zero if successful, a negative error code otherwise<br>
     * @see av_image_alloc(), avpicture_fill()<br>
     * Original signature : <code>int avpicture_alloc(AVPicture*, AVPixelFormat, int, int)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h:1831</i>
     */
    public int avpicture_alloc(Pointer<AVPicture > picture, IntValuedEnum<AVPixelFormat > pix_fmt, int width, int height) {
        return avpicture_alloc(Pointer.getPeer(picture), (int)pix_fmt.value(), width, height);
    }
    protected native int avpicture_alloc(@Ptr long picture, int pix_fmt, int width, int height);
    /**
     * Free a picture previously allocated by avpicture_alloc().<br>
     * The data buffer used by the AVPicture is freed, but the AVPicture structure<br>
     * itself is not.<br>
     * @param picture the AVPicture to be freed<br>
     * Original signature : <code>void avpicture_free(AVPicture*)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h:1839</i>
     */
    public void avpicture_free(Pointer<AVPicture > picture) {
        avpicture_free(Pointer.getPeer(picture));
    }
    protected native void avpicture_free(@Ptr long picture);
    /**
     * Setup the picture fields based on the specified image parameters<br>
     * and the provided image data buffer.<br>
     * The picture fields are filled in by using the image data buffer<br>
     * pointed to by ptr.<br>
     * If ptr is NULL, the function will fill only the picture linesize<br>
     * array and return the required size for the image buffer.<br>
     * To allocate an image buffer and fill the picture data in one call,<br>
     * use avpicture_alloc().<br>
     * @param picture       the picture to be filled in<br>
     * @param ptr           buffer where the image data is stored, or NULL<br>
     * @param pix_fmt       the pixel format of the image<br>
     * @param width         the width of the image in pixels<br>
     * @param height        the height of the image in pixels<br>
     * @return the size in bytes required for src, a negative error code<br>
     * in case of failure<br>
     * @see av_image_fill_arrays()<br>
     * Original signature : <code>int avpicture_fill(AVPicture*, const uint8_t*, AVPixelFormat, int, int)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h:1859</i>
     */
    public int avpicture_fill(Pointer<AVPicture > picture, Pointer<Byte > ptr, IntValuedEnum<AVPixelFormat > pix_fmt, int width, int height) {
        return avpicture_fill(Pointer.getPeer(picture), Pointer.getPeer(ptr), (int)pix_fmt.value(), width, height);
    }
    protected native int avpicture_fill(@Ptr long picture, @Ptr long ptr, int pix_fmt, int width, int height);
    /**
     * Copy pixel data from an AVPicture into a buffer.<br>
     * avpicture_get_size() can be used to compute the required size for<br>
     * the buffer to fill.<br>
     * @param src        source picture with filled data<br>
     * @param pix_fmt    picture pixel format<br>
     * @param width      picture width<br>
     * @param height     picture height<br>
     * @param dest       destination buffer<br>
     * @param dest_size  destination buffer size in bytes<br>
     * @return the number of bytes written to dest, or a negative value<br>
     * (error code) on error, for example if the destination buffer is not<br>
     * big enough<br>
     * @see av_image_copy_to_buffer()<br>
     * Original signature : <code>int avpicture_layout(const AVPicture*, AVPixelFormat, int, int, unsigned char*, int)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h:1876</i>
     */
    public int avpicture_layout(Pointer<AVPicture > src, IntValuedEnum<AVPixelFormat > pix_fmt, int width, int height, Pointer<Byte > dest, int dest_size) {
        return avpicture_layout(Pointer.getPeer(src), (int)pix_fmt.value(), width, height, Pointer.getPeer(dest), dest_size);
    }
    protected native int avpicture_layout(@Ptr long src, int pix_fmt, int width, int height, @Ptr long dest, int dest_size);
    /**
     * Calculate the size in bytes that a picture of the given width and height<br>
     * would occupy if stored in the given picture format.<br>
     * @param pix_fmt    picture pixel format<br>
     * @param width      picture width<br>
     * @param height     picture height<br>
     * @return the computed picture buffer size or a negative error code<br>
     * in case of error<br>
     * @see av_image_get_buffer_size().<br>
     * Original signature : <code>int avpicture_get_size(AVPixelFormat, int, int)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h:1888</i>
     */
    public int avpicture_get_size(IntValuedEnum<AVPixelFormat > pix_fmt, int width, int height) {
        return avpicture_get_size((int)pix_fmt.value(), width, height);
    }
    protected native int avpicture_get_size(int pix_fmt, int width, int height);
    /**
     * Copy image src to dst. Wraps av_image_copy().<br>
     * Original signature : <code>void av_picture_copy(AVPicture*, const AVPicture*, AVPixelFormat, int, int)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h:1893</i>
     */
    public void av_picture_copy(Pointer<AVPicture > dst, Pointer<AVPicture > src, IntValuedEnum<AVPixelFormat > pix_fmt, int width, int height) {
        av_picture_copy(Pointer.getPeer(dst), Pointer.getPeer(src), (int)pix_fmt.value(), width, height);
    }
    protected native void av_picture_copy(@Ptr long dst, @Ptr long src, int pix_fmt, int width, int height);
    /**
     * Crop image top and left side.<br>
     * Original signature : <code>int av_picture_crop(AVPicture*, const AVPicture*, AVPixelFormat, int, int)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h:1898</i>
     */
    public int av_picture_crop(Pointer<AVPicture > dst, Pointer<AVPicture > src, IntValuedEnum<AVPixelFormat > pix_fmt, int top_band, int left_band) {
        return av_picture_crop(Pointer.getPeer(dst), Pointer.getPeer(src), (int)pix_fmt.value(), top_band, left_band);
    }
    protected native int av_picture_crop(@Ptr long dst, @Ptr long src, int pix_fmt, int top_band, int left_band);
    /**
     * Pad image.<br>
     * Original signature : <code>int av_picture_pad(AVPicture*, const AVPicture*, int, int, AVPixelFormat, int, int, int, int, int*)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h:1903</i>
     */
    public int av_picture_pad(Pointer<AVPicture > dst, Pointer<AVPicture > src, int height, int width, IntValuedEnum<AVPixelFormat > pix_fmt, int padtop, int padbottom, int padleft, int padright, Pointer<Integer > color) {
        return av_picture_pad(Pointer.getPeer(dst), Pointer.getPeer(src), height, width, (int)pix_fmt.value(), padtop, padbottom, padleft, padright, Pointer.getPeer(color));
    }
    protected native int av_picture_pad(@Ptr long dst, @Ptr long src, int height, int width, int pix_fmt, int padtop, int padbottom, int padleft, int padright, @Ptr long color);
    /**
     * Utility function to access log2_chroma_w log2_chroma_h from<br>
     * the pixel format AVPixFmtDescriptor.<br>
     * This function asserts that pix_fmt is valid. See av_pix_fmt_get_chroma_sub_sample<br>
     * for one that returns a failure code and continues in case of invalid<br>
     * pix_fmts.<br>
     * @param[in]  pix_fmt the pixel format<br>
     * @param[out] h_shift store log2_chroma_w<br>
     * @param[out] v_shift store log2_chroma_h<br>
     * @see av_pix_fmt_get_chroma_sub_sample<br>
     * Original signature : <code>void avcodec_get_chroma_sub_sample(AVPixelFormat, int*, int*)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h:1916</i>
     */
    public void avcodec_get_chroma_sub_sample(IntValuedEnum<AVPixelFormat > pix_fmt, Pointer<Integer > h_shift, Pointer<Integer > v_shift) {
        avcodec_get_chroma_sub_sample((int)pix_fmt.value(), Pointer.getPeer(h_shift), Pointer.getPeer(v_shift));
    }
    protected native void avcodec_get_chroma_sub_sample(int pix_fmt, @Ptr long h_shift, @Ptr long v_shift);
    /**
     * Return a value representing the fourCC code associated to the<br>
     * pixel format pix_fmt, or 0 if no associated fourCC code can be<br>
     * found.<br>
     * Original signature : <code>int avcodec_pix_fmt_to_codec_tag(AVPixelFormat)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h:1923</i>
     */
    public int avcodec_pix_fmt_to_codec_tag(IntValuedEnum<AVPixelFormat > pix_fmt) {
        return avcodec_pix_fmt_to_codec_tag((int)pix_fmt.value());
    }
    protected native int avcodec_pix_fmt_to_codec_tag(int pix_fmt);
    /**
     * @deprecated see av_get_pix_fmt_loss()<br>
     * Original signature : <code>int avcodec_get_pix_fmt_loss(AVPixelFormat, AVPixelFormat, int)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h:1928</i>
     */
    public int avcodec_get_pix_fmt_loss(IntValuedEnum<AVPixelFormat > dst_pix_fmt, IntValuedEnum<AVPixelFormat > src_pix_fmt, int has_alpha) {
        return avcodec_get_pix_fmt_loss((int)dst_pix_fmt.value(), (int)src_pix_fmt.value(), has_alpha);
    }
    protected native int avcodec_get_pix_fmt_loss(int dst_pix_fmt, int src_pix_fmt, int has_alpha);
    /**
     * Find the best pixel format to convert to given a certain source pixel<br>
     * format.  When converting from one pixel format to another, information loss<br>
     * may occur.  For example, when converting from RGB24 to GRAY, the color<br>
     * information will be lost. Similarly, other losses occur when converting from<br>
     * some formats to other formats. avcodec_find_best_pix_fmt_of_2() searches which of<br>
     * the given pixel formats should be used to suffer the least amount of loss.<br>
     * The pixel formats from which it chooses one, are determined by the<br>
     * pix_fmt_list parameter.<br>
     * *<br>
     * @param[in] pix_fmt_list AV_PIX_FMT_NONE terminated array of pixel formats to choose from<br>
     * @param[in] src_pix_fmt source pixel format<br>
     * @param[in] has_alpha Whether the source pixel format alpha channel is used.<br>
     * @param[out] loss_ptr Combination of flags informing you what kind of losses will occur.<br>
     * @return The best pixel format to convert to or -1 if none was found.<br>
     * Original signature : <code>AVPixelFormat avcodec_find_best_pix_fmt_of_list(AVPixelFormat*, AVPixelFormat, int, int*)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h:1946</i>
     */
    public IntValuedEnum<AVPixelFormat > avcodec_find_best_pix_fmt_of_list(Pointer<IntValuedEnum<AVPixelFormat > > pix_fmt_list, IntValuedEnum<AVPixelFormat > src_pix_fmt, int has_alpha, Pointer<Integer > loss_ptr) {
        return FlagSet.fromValue(avcodec_find_best_pix_fmt_of_list(Pointer.getPeer(pix_fmt_list), (int)src_pix_fmt.value(), has_alpha, Pointer.getPeer(loss_ptr)), AVPixelFormat.class);
    }
    protected native int avcodec_find_best_pix_fmt_of_list(@Ptr long pix_fmt_list, int src_pix_fmt, int has_alpha, @Ptr long loss_ptr);
    /**
     * @deprecated see av_find_best_pix_fmt_of_2()<br>
     * Original signature : <code>AVPixelFormat avcodec_find_best_pix_fmt_of_2(AVPixelFormat, AVPixelFormat, AVPixelFormat, int, int*)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h:1951</i>
     */
    public IntValuedEnum<AVPixelFormat > avcodec_find_best_pix_fmt_of_2(IntValuedEnum<AVPixelFormat > dst_pix_fmt1, IntValuedEnum<AVPixelFormat > dst_pix_fmt2, IntValuedEnum<AVPixelFormat > src_pix_fmt, int has_alpha, Pointer<Integer > loss_ptr) {
        return FlagSet.fromValue(avcodec_find_best_pix_fmt_of_2((int)dst_pix_fmt1.value(), (int)dst_pix_fmt2.value(), (int)src_pix_fmt.value(), has_alpha, Pointer.getPeer(loss_ptr)), AVPixelFormat.class);
    }
    protected native int avcodec_find_best_pix_fmt_of_2(int dst_pix_fmt1, int dst_pix_fmt2, int src_pix_fmt, int has_alpha, @Ptr long loss_ptr);
    /**
     * Original signature : <code>AVPixelFormat avcodec_find_best_pix_fmt2(AVPixelFormat, AVPixelFormat, AVPixelFormat, int, int*)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h:1953</i>
     */
    public IntValuedEnum<AVPixelFormat > avcodec_find_best_pix_fmt2(IntValuedEnum<AVPixelFormat > dst_pix_fmt1, IntValuedEnum<AVPixelFormat > dst_pix_fmt2, IntValuedEnum<AVPixelFormat > src_pix_fmt, int has_alpha, Pointer<Integer > loss_ptr) {
        return FlagSet.fromValue(avcodec_find_best_pix_fmt2((int)dst_pix_fmt1.value(), (int)dst_pix_fmt2.value(), (int)src_pix_fmt.value(), has_alpha, Pointer.getPeer(loss_ptr)), AVPixelFormat.class);
    }
    protected native int avcodec_find_best_pix_fmt2(int dst_pix_fmt1, int dst_pix_fmt2, int src_pix_fmt, int has_alpha, @Ptr long loss_ptr);
    /**
     * Original signature : <code>AVPixelFormat avcodec_default_get_format(AVCodecContext*, AVPixelFormat*)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h:1955</i>
     */
    public IntValuedEnum<AVPixelFormat > avcodec_default_get_format(Pointer<AVCodecContext > s, Pointer<IntValuedEnum<AVPixelFormat > > fmt) {
        return FlagSet.fromValue(avcodec_default_get_format(Pointer.getPeer(s), Pointer.getPeer(fmt)), AVPixelFormat.class);
    }
    protected native int avcodec_default_get_format(@Ptr long s, @Ptr long fmt);
    /**
     * @deprecated this function is not supposed to be used from outside of lavc<br>
     * Original signature : <code>void avcodec_set_dimensions(AVCodecContext*, int, int)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h:1960</i>
     */
    public void avcodec_set_dimensions(Pointer<AVCodecContext > s, int width, int height) {
        avcodec_set_dimensions(Pointer.getPeer(s), width, height);
    }
    protected native void avcodec_set_dimensions(@Ptr long s, int width, int height);
    /**
     * Put a string representing the codec tag codec_tag in buf.<br>
     * @param buf       buffer to place codec tag in<br>
     * @param buf_size size in bytes of buf<br>
     * @param codec_tag codec tag to assign<br>
     * @return the length of the string that would have been generated if<br>
     * enough space had been available, excluding the trailing null<br>
     * Original signature : <code>size_t av_get_codec_tag_string(char*, size_t, unsigned int)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h:1970</i>
     */
    @Ptr
    public long av_get_codec_tag_string(Pointer<Byte > buf, @Ptr long buf_size, int codec_tag) {
        return av_get_codec_tag_string(Pointer.getPeer(buf), buf_size, codec_tag);
    }
    @Ptr
    protected native long av_get_codec_tag_string(@Ptr long buf, @Ptr long buf_size, int codec_tag);
    /**
     * Original signature : <code>void avcodec_string(char*, int, AVCodecContext*, int)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h:1972</i>
     */
    public void avcodec_string(Pointer<Byte > buf, int buf_size, Pointer<AVCodecContext > enc, int encode) {
        avcodec_string(Pointer.getPeer(buf), buf_size, Pointer.getPeer(enc), encode);
    }
    protected native void avcodec_string(@Ptr long buf, int buf_size, @Ptr long enc, int encode);
    /**
     * Return a name for the specified profile, if available.<br>
     * @param codec the codec that is searched for the given profile<br>
     * @param profile the profile value for which a name is requested<br>
     * @return A name for the profile if found, NULL otherwise.<br>
     * Original signature : <code>char* av_get_profile_name(const AVCodec*, int)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h:1980</i>
     */
    public Pointer<Byte > av_get_profile_name(Pointer<AVCodec > codec, int profile) {
        return (Pointer)Pointer.pointerToAddress(av_get_profile_name(Pointer.getPeer(codec), profile), Byte.class);
    }
    @Ptr
    protected native long av_get_profile_name(@Ptr long codec, int profile);
    /**
     * Original signature : <code>int avcodec_default_execute(AVCodecContext*, avcodec_default_execute_func_callback*, void*, int*, int, int)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h:1982</i>
     */
    public int avcodec_default_execute(Pointer<AVCodecContext > c, Pointer<AvcodecLibrary.avcodec_default_execute_func_callback > func, Pointer<? > arg, Pointer<Integer > ret, int count, int size) {
        return avcodec_default_execute(Pointer.getPeer(c), Pointer.getPeer(func), Pointer.getPeer(arg), Pointer.getPeer(ret), count, size);
    }
    protected native int avcodec_default_execute(@Ptr long c, @Ptr long func, @Ptr long arg, @Ptr long ret, int count, int size);
    /**
     * Original signature : <code>int avcodec_default_execute2(AVCodecContext*, avcodec_default_execute2_func_callback*, void*, int*, int)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h:1984</i>
     */
    public int avcodec_default_execute2(Pointer<AVCodecContext > c, Pointer<AvcodecLibrary.avcodec_default_execute2_func_callback > func, Pointer<? > arg, Pointer<Integer > ret, int count) {
        return avcodec_default_execute2(Pointer.getPeer(c), Pointer.getPeer(func), Pointer.getPeer(arg), Pointer.getPeer(ret), count);
    }
    protected native int avcodec_default_execute2(@Ptr long c, @Ptr long func, @Ptr long arg, @Ptr long ret, int count);
    /**
     * Fill AVFrame audio data and linesize pointers.<br>
     * The buffer buf must be a preallocated buffer with a size big enough<br>
     * to contain the specified samples amount. The filled AVFrame data<br>
     * pointers will point to this buffer.<br>
     * AVFrame extended_data channel pointers are allocated if necessary for<br>
     * planar audio.<br>
     * @param frame       the AVFrame<br>
     *                    frame->nb_samples must be set prior to calling the<br>
     *                    function. This function fills in frame->data,<br>
     *                    frame->extended_data, frame->linesize[0].<br>
     * @param nb_channels channel count<br>
     * @param sample_fmt  sample format<br>
     * @param buf         buffer to use for frame data<br>
     * @param buf_size    size of buffer<br>
     * @param align       plane size sample alignment (0 = default)<br>
     * @return            >=0 on success, negative error code on failure<br>
     * @todo return the size in bytes required to store the samples in<br>
     * case of success, at the next libavutil bump<br>
     * Original signature : <code>int avcodec_fill_audio_frame(AVFrame*, int, AVSampleFormat, const uint8_t*, int, int)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h:2006</i>
     */
    public int avcodec_fill_audio_frame(Pointer<AVFrame > frame, int nb_channels, IntValuedEnum<AVSampleFormat > sample_fmt, Pointer<Byte > buf, int buf_size, int align) {
        return avcodec_fill_audio_frame(Pointer.getPeer(frame), nb_channels, (int)sample_fmt.value(), Pointer.getPeer(buf), buf_size, align);
    }
    protected native int avcodec_fill_audio_frame(@Ptr long frame, int nb_channels, int sample_fmt, @Ptr long buf, int buf_size, int align);
    /**
     * Reset the internal decoder state / flush internal buffers. Should be called<br>
     * e.g. when seeking or when switching to a different stream.<br>
     * @note when refcounted frames are not used (i.e. avctx->refcounted_frames is 0),<br>
     * this invalidates the frames previously returned from the decoder. When<br>
     * refcounted frames are used, the decoder just releases any references it might<br>
     * keep internally, but the caller's reference remains valid.<br>
     * Original signature : <code>void avcodec_flush_buffers(AVCodecContext*)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h:2016</i>
     */
    public void avcodec_flush_buffers(Pointer<AVCodecContext > avctx) {
        avcodec_flush_buffers(Pointer.getPeer(avctx));
    }
    protected native void avcodec_flush_buffers(@Ptr long avctx);
    /**
     * Return codec bits per sample.<br>
     * @param[in] codec_id the codec<br>
     * @return Number of bits per sample or zero if unknown for the given codec.<br>
     * Original signature : <code>int av_get_bits_per_sample(AVCodecID)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h:2023</i>
     */
    public int av_get_bits_per_sample(IntValuedEnum<AvcodecLibrary.AVCodecID > codec_id) {
        return av_get_bits_per_sample((int)codec_id.value());
    }
    protected native int av_get_bits_per_sample(int codec_id);
    /**
     * Return the PCM codec associated with a sample format.<br>
     * @param be  endianness, 0 for little, 1 for big,<br>
     *            -1 (or anything else) for native<br>
     * @return  AV_CODEC_ID_PCM_* or AV_CODEC_ID_NONE<br>
     * Original signature : <code>AVCodecID av_get_pcm_codec(AVSampleFormat, int)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h:2031</i>
     */
    public IntValuedEnum<AvcodecLibrary.AVCodecID > av_get_pcm_codec(IntValuedEnum<AVSampleFormat > fmt, int be) {
        return FlagSet.fromValue(av_get_pcm_codec((int)fmt.value(), be), AvcodecLibrary.AVCodecID.class);
    }
    protected native int av_get_pcm_codec(int fmt, int be);
    /**
     * Return codec bits per sample.<br>
     * Only return non-zero if the bits per sample is exactly correct, not an<br>
     * approximation.<br>
     * @param[in] codec_id the codec<br>
     * @return Number of bits per sample or zero if unknown for the given codec.<br>
     * Original signature : <code>int av_get_exact_bits_per_sample(AVCodecID)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h:2040</i>
     */
    public int av_get_exact_bits_per_sample(IntValuedEnum<AvcodecLibrary.AVCodecID > codec_id) {
        return av_get_exact_bits_per_sample((int)codec_id.value());
    }
    protected native int av_get_exact_bits_per_sample(int codec_id);
    /**
     * Return audio frame duration.<br>
     * @param avctx        codec context<br>
     * @param frame_bytes  size of the frame, or 0 if unknown<br>
     * @return             frame duration, in samples, if known. 0 if not able to<br>
     *                     determine.<br>
     * Original signature : <code>int av_get_audio_frame_duration(AVCodecContext*, int)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h:2049</i>
     */
    public int av_get_audio_frame_duration(Pointer<AVCodecContext > avctx, int frame_bytes) {
        return av_get_audio_frame_duration(Pointer.getPeer(avctx), frame_bytes);
    }
    protected native int av_get_audio_frame_duration(@Ptr long avctx, int frame_bytes);
    /**
     * Register a bitstream filter.<br>
     * The filter will be accessible to the application code through<br>
     * av_bitstream_filter_next() or can be directly initialized with<br>
     * av_bitstream_filter_init().<br>
     * @see avcodec_register_all()<br>
     * Original signature : <code>void av_register_bitstream_filter(AVBitStreamFilter*)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h:2074</i>
     */
    public void av_register_bitstream_filter(Pointer<AVBitStreamFilter > bsf) {
        av_register_bitstream_filter(Pointer.getPeer(bsf));
    }
    protected native void av_register_bitstream_filter(@Ptr long bsf);
    /**
     * Create and initialize a bitstream filter context given a bitstream<br>
     * filter name.<br>
     * The returned context must be freed with av_bitstream_filter_close().<br>
     * @param name    the name of the bitstream filter<br>
     * @return a bitstream filter context if a matching filter was found<br>
     * and successfully initialized, NULL otherwise<br>
     * Original signature : <code>AVBitStreamFilterContext* av_bitstream_filter_init(const char*)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h:2084</i>
     */
    public Pointer<AVBitStreamFilterContext > av_bitstream_filter_init(Pointer<Byte > name) {
        return (Pointer)Pointer.pointerToAddress(av_bitstream_filter_init(Pointer.getPeer(name)), AVBitStreamFilterContext.class);
    }
    @Ptr
    protected native long av_bitstream_filter_init(@Ptr long name);
    /**
     * Filter bitstream.<br>
     * This function filters the buffer buf with size buf_size, and places the<br>
     * filtered buffer in the buffer pointed to by poutbuf.<br>
     * The output buffer must be freed by the caller.<br>
     * @param bsfc            bitstream filter context created by av_bitstream_filter_init()<br>
     * @param avctx           AVCodecContext accessed by the filter, may be NULL.<br>
     *                        If specified, this must point to the encoder context of the<br>
     *                        output stream the packet is sent to.<br>
     * @param args            arguments which specify the filter configuration, may be NULL<br>
     * @param poutbuf         pointer which is updated to point to the filtered buffer<br>
     * @param poutbuf_size    pointer which is updated to the filtered buffer size in bytes<br>
     * @param buf             buffer containing the data to filter<br>
     * @param buf_size        size in bytes of buf<br>
     * @param keyframe        set to non-zero if the buffer to filter corresponds to a key-frame packet data<br>
     * @return >= 0 in case of success, or a negative error code in case of failure<br>
     * If the return value is positive, an output buffer is allocated and<br>
     * is available in *poutbuf, and is distinct from the input buffer.<br>
     * If the return value is 0, the output buffer is not allocated and<br>
     * should be considered identical to the input buffer, or in case<br>
     * *poutbuf was set it points to the input buffer (not necessarily to<br>
     * its starting address).<br>
     * Original signature : <code>int av_bitstream_filter_filter(AVBitStreamFilterContext*, AVCodecContext*, const char*, uint8_t**, int*, const uint8_t*, int, int)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h:2109</i>
     */
    public int av_bitstream_filter_filter(Pointer<AVBitStreamFilterContext > bsfc, Pointer<AVCodecContext > avctx, Pointer<Byte > args, Pointer<Pointer<Byte > > poutbuf, Pointer<Integer > poutbuf_size, Pointer<Byte > buf, int buf_size, int keyframe) {
        return av_bitstream_filter_filter(Pointer.getPeer(bsfc), Pointer.getPeer(avctx), Pointer.getPeer(args), Pointer.getPeer(poutbuf), Pointer.getPeer(poutbuf_size), Pointer.getPeer(buf), buf_size, keyframe);
    }
    protected native int av_bitstream_filter_filter(@Ptr long bsfc, @Ptr long avctx, @Ptr long args, @Ptr long poutbuf, @Ptr long poutbuf_size, @Ptr long buf, int buf_size, int keyframe);
    /**
     * Release bitstream filter context.<br>
     * @param bsf the bitstream filter context created with<br>
     * av_bitstream_filter_init(), can be NULL<br>
     * Original signature : <code>void av_bitstream_filter_close(AVBitStreamFilterContext*)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h:2116</i>
     */
    public void av_bitstream_filter_close(Pointer<AVBitStreamFilterContext > bsf) {
        av_bitstream_filter_close(Pointer.getPeer(bsf));
    }
    protected native void av_bitstream_filter_close(@Ptr long bsf);
    /**
     * If f is NULL, return the first registered bitstream filter,<br>
     * if f is non-NULL, return the next registered bitstream filter<br>
     * after f, or NULL if f is the last one.<br>
     * This function can be used to iterate over all registered bitstream<br>
     * filters.<br>
     * Original signature : <code>AVBitStreamFilter* av_bitstream_filter_next(const AVBitStreamFilter*)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h:2125</i>
     */
    public Pointer<AVBitStreamFilter > av_bitstream_filter_next(Pointer<AVBitStreamFilter > f) {
        return (Pointer)Pointer.pointerToAddress(av_bitstream_filter_next(Pointer.getPeer(f)), AVBitStreamFilter.class);
    }
    @Ptr
    protected native long av_bitstream_filter_next(@Ptr long f);
    /**
     * Same behaviour av_fast_malloc but the buffer has additional<br>
     * AV_INPUT_BUFFER_PADDING_SIZE at the end which will always be 0.<br>
     * In addition the whole buffer will initially and after resizes<br>
     * be 0-initialized so that no uninitialized data will ever appear.<br>
     * Original signature : <code>void av_fast_padded_malloc(void*, unsigned int*, size_t)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h:2133</i>
     */
    public void av_fast_padded_malloc(Pointer<? > ptr, Pointer<Integer > size, @Ptr long min_size) {
        av_fast_padded_malloc(Pointer.getPeer(ptr), Pointer.getPeer(size), min_size);
    }
    protected native void av_fast_padded_malloc(@Ptr long ptr, @Ptr long size, @Ptr long min_size);
    /**
     * Same behaviour av_fast_padded_malloc except that buffer will always<br>
     * be 0-initialized after call.<br>
     * Original signature : <code>void av_fast_padded_mallocz(void*, unsigned int*, size_t)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h:2139</i>
     */
    public void av_fast_padded_mallocz(Pointer<? > ptr, Pointer<Integer > size, @Ptr long min_size) {
        av_fast_padded_mallocz(Pointer.getPeer(ptr), Pointer.getPeer(size), min_size);
    }
    protected native void av_fast_padded_mallocz(@Ptr long ptr, @Ptr long size, @Ptr long min_size);
    /**
     * Encode extradata length to a buffer. Used by xiph codecs.<br>
     * @param s buffer to write to; must be at least (v/255+1) bytes long<br>
     * @param v size of extradata in bytes<br>
     * @return number of bytes written to the buffer.<br>
     * Original signature : <code>int av_xiphlacing(unsigned char*, unsigned int)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h:2147</i>
     */
    public int av_xiphlacing(Pointer<Byte > s, int v) {
        return av_xiphlacing(Pointer.getPeer(s), v);
    }
    protected native int av_xiphlacing(@Ptr long s, int v);
    /**
     * Log a generic warning message about a missing feature. This function is<br>
     * intended to be used internally by FFmpeg (libavcodec, libavformat, etc.)<br>
     * only, and would normally not be used by applications.<br>
     * @param[in] avc a pointer to an arbitrary struct of which the first field is<br>
     * a pointer to an AVClass struct<br>
     * @param[in] feature string containing the name of the missing feature<br>
     * @param[in] want_sample indicates if samples are wanted which exhibit this feature.<br>
     * If want_sample is non-zero, additional verbage will be added to the log<br>
     * message which tells the user how to report samples to the development<br>
     * mailing list.<br>
     * @deprecated Use avpriv_report_missing_feature() instead.<br>
     * Original signature : <code>void av_log_missing_feature(void*, const char*, int)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h:2162</i>
     */
    public void av_log_missing_feature(Pointer<? > avc, Pointer<Byte > feature, int want_sample) {
        av_log_missing_feature(Pointer.getPeer(avc), Pointer.getPeer(feature), want_sample);
    }
    protected native void av_log_missing_feature(@Ptr long avc, @Ptr long feature, int want_sample);
    /**
     * Log a generic warning message asking for a sample. This function is<br>
     * intended to be used internally by FFmpeg (libavcodec, libavformat, etc.)<br>
     * only, and would normally not be used by applications.<br>
     * @param[in] avc a pointer to an arbitrary struct of which the first field is<br>
     * a pointer to an AVClass struct<br>
     * @param[in] msg string containing an optional message, or NULL if no message<br>
     * @deprecated Use avpriv_request_sample() instead.<br>
     * Original signature : <code>void av_log_ask_for_sample(void*, const char*, null)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h:2173</i>
     */
    public void av_log_ask_for_sample(Pointer<? > avc, Pointer<Byte > msg, Object... varArgs1) {
        av_log_ask_for_sample(Pointer.getPeer(avc), Pointer.getPeer(msg), varArgs1);
    }
    protected native void av_log_ask_for_sample(@Ptr long avc, @Ptr long msg, Object... varArgs1);
    /**
     * Register the hardware accelerator hwaccel.<br>
     * Original signature : <code>void av_register_hwaccel(AVHWAccel*)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h:2178</i>
     */
    public void av_register_hwaccel(Pointer<AVHWAccel > hwaccel) {
        av_register_hwaccel(Pointer.getPeer(hwaccel));
    }
    protected native void av_register_hwaccel(@Ptr long hwaccel);
    /**
     * If hwaccel is NULL, returns the first registered hardware accelerator,<br>
     * if hwaccel is non-NULL, returns the next registered hardware accelerator<br>
     * after hwaccel, or NULL if hwaccel is the last one.<br>
     * Original signature : <code>AVHWAccel* av_hwaccel_next(const AVHWAccel*)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h:2185</i>
     */
    public Pointer<AVHWAccel > av_hwaccel_next(Pointer<AVHWAccel > hwaccel) {
        return (Pointer)Pointer.pointerToAddress(av_hwaccel_next(Pointer.getPeer(hwaccel)), AVHWAccel.class);
    }
    @Ptr
    protected native long av_hwaccel_next(@Ptr long hwaccel);
    /**
     * Register a user provided lock manager supporting the operations<br>
     * specified by AVLockOp. The "mutex" argument to the function points<br>
     * to a (void *) where the lockmgr should store/get a pointer to a user<br>
     * allocated mutex. It is NULL upon AV_LOCK_CREATE and equal to the<br>
     * value left by the last call for all other ops. If the lock manager is<br>
     * unable to perform the op then it should leave the mutex in the same<br>
     * state as when it was called and return a non-zero value. However,<br>
     * when called with AV_LOCK_DESTROY the mutex will always be assumed to<br>
     * have been successfully destroyed. If av_lockmgr_register succeeds<br>
     * it will return a non-negative value, if it fails it will return a<br>
     * negative value and destroy all mutex and unregister all callbacks.<br>
     * av_lockmgr_register is not thread-safe, it must be called from a<br>
     * single thread before any calls which make use of locking are used.<br>
     * @param cb User defined callback. av_lockmgr_register invokes calls<br>
     *           to this callback and the previously registered callback.<br>
     *           The callback will be used to create more than one mutex<br>
     *           each of which must be backed by its own underlying locking<br>
     *           mechanism (i.e. do not use a single static object to<br>
     *           implement your lock manager). If cb is set to NULL the<br>
     *           lockmgr will be unregistered.<br>
     * Original signature : <code>int av_lockmgr_register(av_lockmgr_register_cb_callback*)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h:2220</i>
     */
    public int av_lockmgr_register(Pointer<AvcodecLibrary.av_lockmgr_register_cb_callback > cb) {
        return av_lockmgr_register(Pointer.getPeer(cb));
    }
    protected native int av_lockmgr_register(@Ptr long cb);
    /**
     * Get the type of the given codec.<br>
     * Original signature : <code>AVMediaType avcodec_get_type(AVCodecID)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h:2225</i>
     */
    public IntValuedEnum<AVMediaType > avcodec_get_type(IntValuedEnum<AvcodecLibrary.AVCodecID > codec_id) {
        return FlagSet.fromValue(avcodec_get_type((int)codec_id.value()), AVMediaType.class);
    }
    protected native int avcodec_get_type(int codec_id);
    /**
     * Get the name of a codec.<br>
     * @return  a static string identifying the codec; never NULL<br>
     * Original signature : <code>char* avcodec_get_name(AVCodecID)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h:2231</i>
     */
    public Pointer<Byte > avcodec_get_name(IntValuedEnum<AvcodecLibrary.AVCodecID > id) {
        return (Pointer)Pointer.pointerToAddress(avcodec_get_name((int)id.value()), Byte.class);
    }
    @Ptr
    protected native long avcodec_get_name(int id);
    /**
     * @return a positive value if s is open (i.e. avcodec_open2() was called on it<br>
     * with no corresponding avcodec_close()), 0 otherwise.<br>
     * Original signature : <code>int avcodec_is_open(AVCodecContext*)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h:2237</i>
     */
    public int avcodec_is_open(Pointer<AVCodecContext > s) {
        return avcodec_is_open(Pointer.getPeer(s));
    }
    protected native int avcodec_is_open(@Ptr long s);
    /**
     * @return a non-zero number if codec is an encoder, zero otherwise<br>
     * Original signature : <code>int av_codec_is_encoder(const AVCodec*)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h:2242</i>
     */
    public int av_codec_is_encoder(Pointer<AVCodec > codec) {
        return av_codec_is_encoder(Pointer.getPeer(codec));
    }
    protected native int av_codec_is_encoder(@Ptr long codec);
    /**
     * @return a non-zero number if codec is a decoder, zero otherwise<br>
     * Original signature : <code>int av_codec_is_decoder(const AVCodec*)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h:2247</i>
     */
    public int av_codec_is_decoder(Pointer<AVCodec > codec) {
        return av_codec_is_decoder(Pointer.getPeer(codec));
    }
    protected native int av_codec_is_decoder(@Ptr long codec);
    /**
     * @return descriptor for given codec ID or NULL if no descriptor exists.<br>
     * Original signature : <code>AVCodecDescriptor* avcodec_descriptor_get(AVCodecID)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h:2252</i>
     */
    public Pointer<AVCodecDescriptor > avcodec_descriptor_get(IntValuedEnum<AvcodecLibrary.AVCodecID > id) {
        return (Pointer)Pointer.pointerToAddress(avcodec_descriptor_get((int)id.value()), AVCodecDescriptor.class);
    }
    @Ptr
    protected native long avcodec_descriptor_get(int id);
    /**
     * Iterate over all codec descriptors known to libavcodec.<br>
     * @param prev previous descriptor. NULL to get the first descriptor.<br>
     * @return next descriptor or NULL after the last descriptor<br>
     * Original signature : <code>AVCodecDescriptor* avcodec_descriptor_next(const AVCodecDescriptor*)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h:2259</i>
     */
    public Pointer<AVCodecDescriptor > avcodec_descriptor_next(Pointer<AVCodecDescriptor > prev) {
        return (Pointer)Pointer.pointerToAddress(avcodec_descriptor_next(Pointer.getPeer(prev)), AVCodecDescriptor.class);
    }
    @Ptr
    protected native long avcodec_descriptor_next(@Ptr long prev);
    /**
     * @return codec descriptor with the given name or NULL if no such descriptor<br>
     *         exists.<br>
     * Original signature : <code>AVCodecDescriptor* avcodec_descriptor_get_by_name(const char*)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavcodec/avcodec.h:2265</i>
     */
    public Pointer<AVCodecDescriptor > avcodec_descriptor_get_by_name(Pointer<Byte > name) {
        return (Pointer)Pointer.pointerToAddress(avcodec_descriptor_get_by_name(Pointer.getPeer(name)), AVCodecDescriptor.class);
    }
    @Ptr
    protected native long avcodec_descriptor_get_by_name(@Ptr long name);
    /**
     * Create the video decoder.<br>
     * Original signature : <code>int ff_vda_create_decoder(vda_context*, uint8_t*, int)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavcodec/vda.h:27</i>
     */
    public int ff_vda_create_decoder(Pointer<vda_context > vda_ctx, Pointer<Byte > extradata, int extradata_size) {
        return ff_vda_create_decoder(Pointer.getPeer(vda_ctx), Pointer.getPeer(extradata), extradata_size);
    }
    protected native int ff_vda_create_decoder(@Ptr long vda_ctx, @Ptr long extradata, int extradata_size);
    /**
     * Destroy the video decoder.<br>
     * Original signature : <code>int ff_vda_destroy_decoder(vda_context*)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavcodec/vda.h:32</i>
     */
    public int ff_vda_destroy_decoder(Pointer<vda_context > vda_ctx) {
        return ff_vda_destroy_decoder(Pointer.getPeer(vda_ctx));
    }
    protected native int ff_vda_destroy_decoder(@Ptr long vda_ctx);
    /**
     * Allocate and initialize a VDA context.<br>
     * This function should be called from the get_format() callback when the caller<br>
     * selects the AV_PIX_FMT_VDA format. The caller must then create the decoder<br>
     * object (using the output callback provided by libavcodec) that will be used<br>
     * for VDA-accelerated decoding.<br>
     * When decoding with VDA is finished, the caller must destroy the decoder<br>
     * object and free the VDA context using av_free().<br>
     * @return the newly allocated context or NULL on failure<br>
     * Original signature : <code>AVVDAContext* av_vda_alloc_context()</code><br>
     * <i>native declaration : ffmpeg_build/include/libavcodec/vda.h:55</i>
     */
    public Pointer<AVVDAContext > av_vda_alloc_context() {
        return (Pointer)Pointer.pointerToAddress(av_vda_alloc_context$2(), AVVDAContext.class);
    }
    @Ptr
    @Name("av_vda_alloc_context")
    protected native long av_vda_alloc_context$2();
    /**
     * This is a convenience function that creates and sets up the VDA context using<br>
     * an internal implementation.<br>
     * @param avctx the corresponding codec context<br>
     * @return >= 0 on success, a negative AVERROR code on failure<br>
     * Original signature : <code>int av_vda_default_init(AVCodecContext*)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavcodec/vda.h:63</i>
     */
    public int av_vda_default_init(Pointer<AVCodecContext > avctx) {
        return av_vda_default_init(Pointer.getPeer(avctx));
    }
    protected native int av_vda_default_init(@Ptr long avctx);
    /**
     * This is a convenience function that creates and sets up the VDA context using<br>
     * an internal implementation.<br>
     * @param avctx the corresponding codec context<br>
     * @param vdactx the VDA context to use<br>
     * @return >= 0 on success, a negative AVERROR code on failure<br>
     * Original signature : <code>int av_vda_default_init2(AVCodecContext*, AVVDAContext*)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavcodec/vda.h:72</i>
     */
    public int av_vda_default_init2(Pointer<AVCodecContext > avctx, Pointer<AVVDAContext > vdactx) {
        return av_vda_default_init2(Pointer.getPeer(avctx), Pointer.getPeer(vdactx));
    }
    protected native int av_vda_default_init2(@Ptr long avctx, @Ptr long vdactx);
    /**
     * This function must be called to free the VDA context initialized with<br>
     * av_vda_default_init().<br>
     * @param avctx the corresponding codec context<br>
     * Original signature : <code>void av_vda_default_free(AVCodecContext*)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavcodec/vda.h:79</i>
     */
    public void av_vda_default_free(Pointer<AVCodecContext > avctx) {
        av_vda_default_free(Pointer.getPeer(avctx));
    }
    protected native void av_vda_default_free(@Ptr long avctx);
    /**
     * @brief allocation function for AVVDPAUContext<br>
     * Allows extending the struct without breaking API/ABI<br>
     * Original signature : <code>AVVDPAUContext* av_alloc_vdpaucontext()</code><br>
     * <i>native declaration : ffmpeg_build/include/libavcodec/vdpau.h:36</i>
     */
    public Pointer<AVVDPAUContext > av_alloc_vdpaucontext() {
        return (Pointer)Pointer.pointerToAddress(av_alloc_vdpaucontext$2(), AVVDPAUContext.class);
    }
    @Ptr
    @Name("av_alloc_vdpaucontext")
    protected native long av_alloc_vdpaucontext$2();
    /**
     * Original signature : <code>AVVDPAU_Render2 av_vdpau_hwaccel_get_render2(const AVVDPAUContext*)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavcodec/vdpau.h:38</i>
     */
    public Pointer<AvcodecLibrary.AVVDPAU_Render2 > av_vdpau_hwaccel_get_render2(Pointer<AVVDPAUContext > AVVDPAUContextPtr1) {
        return (Pointer)Pointer.pointerToAddress(av_vdpau_hwaccel_get_render2(Pointer.getPeer(AVVDPAUContextPtr1)), AvcodecLibrary.AVVDPAU_Render2.class);
    }
    @Ptr
    protected native long av_vdpau_hwaccel_get_render2(@Ptr long AVVDPAUContextPtr1);
    /**
     * Original signature : <code>void av_vdpau_hwaccel_set_render2(AVVDPAUContext*, AVVDPAU_Render2)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavcodec/vdpau.h:40</i>
     */
    public void av_vdpau_hwaccel_set_render2(Pointer<AVVDPAUContext > AVVDPAUContextPtr1, Pointer<AvcodecLibrary.AVVDPAU_Render2 > AVVDPAU_Render21) {
        av_vdpau_hwaccel_set_render2(Pointer.getPeer(AVVDPAUContextPtr1), Pointer.getPeer(AVVDPAU_Render21));
    }
    protected native void av_vdpau_hwaccel_set_render2(@Ptr long AVVDPAUContextPtr1, @Ptr long AVVDPAU_Render21);
    /**
     * Associate a VDPAU device with a codec context for hardware acceleration.<br>
     * This function is meant to be called from the get_format() codec callback,<br>
     * or earlier. It can also be called after avcodec_flush_buffers() to change<br>
     * the underlying VDPAU device mid-stream (e.g. to recover from non-transparent<br>
     * display preemption).<br>
     * @note get_format() must return AV_PIX_FMT_VDPAU if this function completes<br>
     * successfully.<br>
     * @param avctx decoding context whose get_format() callback is invoked<br>
     * @param device VDPAU device handle to use for hardware acceleration<br>
     * @param get_proc_address VDPAU device driver<br>
     * @param flags zero of more OR'd AV_HWACCEL_FLAG_* flags<br>
     * @return 0 on success, an AVERROR code on failure.<br>
     * Original signature : <code>int av_vdpau_bind_context(AVCodecContext*, VdpDevice, VdpGetProcAddress*, unsigned)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavcodec/vdpau.h:56</i>
     */
    public int av_vdpau_bind_context(Pointer<AVCodecContext > avctx, int device, Pointer get_proc_address, int flags) {
        return av_vdpau_bind_context(Pointer.getPeer(avctx), device, Pointer.getPeer(get_proc_address), flags);
    }
    protected native int av_vdpau_bind_context(@Ptr long avctx, int device, @Ptr long get_proc_address, int flags);
    /**
     * Gets the parameters to create an adequate VDPAU video surface for the codec<br>
     * context using VDPAU hardware decoding acceleration.<br>
     * @note Behavior is undefined if the context was not successfully bound to a<br>
     * VDPAU device using av_vdpau_bind_context().<br>
     * @param avctx the codec context being used for decoding the stream<br>
     * @param type storage space for the VDPAU video surface chroma type<br>
     *              (or NULL to ignore)<br>
     * @param width storage space for the VDPAU video surface pixel width<br>
     *              (or NULL to ignore)<br>
     * @param height storage space for the VDPAU video surface pixel height<br>
     *              (or NULL to ignore)<br>
     * @return 0 on success, a negative AVERROR code on failure.<br>
     * Original signature : <code>int av_vdpau_get_surface_parameters(AVCodecContext*, VdpChromaType*, uint32_t*, uint32_t*)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavcodec/vdpau.h:72</i>
     */
    public int av_vdpau_get_surface_parameters(Pointer<AVCodecContext > avctx, Pointer<Integer > type, Pointer<Integer > width, Pointer<Integer > height) {
        return av_vdpau_get_surface_parameters(Pointer.getPeer(avctx), Pointer.getPeer(type), Pointer.getPeer(width), Pointer.getPeer(height));
    }
    protected native int av_vdpau_get_surface_parameters(@Ptr long avctx, @Ptr long type, @Ptr long width, @Ptr long height);
    /**
     * Allocate an AVVDPAUContext.<br>
     * @return Newly-allocated AVVDPAUContext or NULL on failure.<br>
     * Original signature : <code>AVVDPAUContext* av_vdpau_alloc_context()</code><br>
     * <i>native declaration : ffmpeg_build/include/libavcodec/vdpau.h:78</i>
     */
    public Pointer<AVVDPAUContext > av_vdpau_alloc_context() {
        return (Pointer)Pointer.pointerToAddress(av_vdpau_alloc_context$2(), AVVDPAUContext.class);
    }
    @Ptr
    @Name("av_vdpau_alloc_context")
    protected native long av_vdpau_alloc_context$2();
    /**
     * Get a decoder profile that should be used for initializing a VDPAU decoder.<br>
     * Should be called from the AVCodecContext.get_format() callback.<br>
     * @deprecated Use av_vdpau_bind_context() instead.<br>
     * @param avctx the codec context being used for decoding the stream<br>
     * @param profile a pointer into which the result will be written on success.<br>
     *                The contents of profile are undefined if this function returns<br>
     *                an error.<br>
     * @return 0 on success (non-negative), a negative AVERROR on failure.<br>
     * Original signature : <code>int av_vdpau_get_profile(AVCodecContext*, VdpDecoderProfile*)</code><br>
     * <i>native declaration : ffmpeg_build/include/libavcodec/vdpau.h:90</i>
     */
    public int av_vdpau_get_profile(Pointer<AVCodecContext > avctx, Pointer<Integer > profile) {
        return av_vdpau_get_profile(Pointer.getPeer(avctx), Pointer.getPeer(profile));
    }
    protected native int av_vdpau_get_profile(@Ptr long avctx, @Ptr long profile);
    /** Undefined type */
    public static interface AVResampleContext {

    };
    /** Undefined type */
    public static interface MpegEncContext {

    };
    /** Undefined type */
    public static interface OSType {

    };
    /** Undefined type */
    public static interface AVCodecInternal {

    };
    /** Undefined type */
    public static interface CVPixelBufferRef {

    };
    /** Undefined type */
    public static interface ReSampleContext {

    };
    /** Undefined type */
    public static interface VDADecoderOutputCallback {

    };
    /** Undefined type */
    public static interface AVCodecDefault {

    };
    /** Undefined type */
    public static interface VDADecoder {

    };
}
